"use strict";(self.webpackChunksingulatron_api_docs=self.webpackChunksingulatron_api_docs||[]).push([[5462],{28453:(e,s,n)=>{n.d(s,{R:()=>a,x:()=>o});var i=n(96540);const t={},r=i.createContext(t);function a(e){const s=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),i.createElement(r.Provider,{value:s},e.children)}},83430:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"writing-custom-services/system-design-guidelines","title":"System design guidelines","description":"1Backend doesn\'t force you to use any particular patterns, languages, stacks, databases, or even conventions. 1Backend services themselves however follow some light conventions.","source":"@site/docs/writing-custom-services/system-design-guidelines.md","sourceDirName":"writing-custom-services","slug":"/writing-custom-services/system-design-guidelines","permalink":"/docs/writing-custom-services/system-design-guidelines","draft":false,"unlisted":false,"editUrl":"https://github.com/1backend/1backend/tree/main/docs-source/docs/writing-custom-services/system-design-guidelines.md","tags":[{"inline":true,"label":"test","permalink":"/docs/tags/test"}],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"tags":["test"]},"sidebar":"tutorialSidebar","previous":{"title":"Your first service","permalink":"/docs/writing-custom-services/your-first-service"},"next":{"title":"Command line","permalink":"/docs/category/command-line"}}');var t=n(74848),r=n(28453);const a={sidebar_position:4,tags:["test"]},o="System design guidelines",d={},l=[{value:"Pagination",id:"pagination",level:2},{value:"Offset vs. cursor pagination in distributed systems",id:"offset-vs-cursor-pagination-in-distributed-systems",level:3},{value:"Cursor-Based Pagination",id:"cursor-based-pagination",level:3},{value:"How It Works",id:"how-it-works",level:4},{value:"Cursor Format",id:"cursor-format",level:4},{value:"Example",id:"example",level:4},{value:"Field Name Conventions",id:"field-name-conventions",level:3},{value:"Common Ordering Strategies",id:"common-ordering-strategies",level:3},{value:"Why Timestamps Alone Are Not Enough",id:"why-timestamps-alone-are-not-enough",level:3},{value:"API naming guidelines",id:"api-naming-guidelines",level:2},{value:"List* endpoints",id:"list-endpoints",level:3},{value:"<code>ids</code> field",id:"ids-field",level:4},{value:"Save* endpoints",id:"save-endpoints",level:3},{value:"IDs",id:"ids",level:3}];function c(e){const s={br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.header,{children:(0,t.jsx)(s.h1,{id:"system-design-guidelines",children:"System design guidelines"})}),"\n",(0,t.jsx)(s.p,{children:"1Backend doesn't force you to use any particular patterns, languages, stacks, databases, or even conventions. 1Backend services themselves however follow some light conventions."}),"\n",(0,t.jsx)(s.h2,{id:"pagination",children:"Pagination"}),"\n",(0,t.jsx)(s.h3,{id:"offset-vs-cursor-pagination-in-distributed-systems",children:"Offset vs. cursor pagination in distributed systems"}),"\n",(0,t.jsxs)(s.p,{children:["In distributed systems\u2014especially when dealing with large datasets or high write volumes\u2014",(0,t.jsx)(s.strong,{children:"OFFSET-based pagination"})," is inefficient and unstable because:"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Performance:"})," The database still has to scan through all skipped rows before returning results."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Consistency:"})," New inserts or deletes between requests can cause missing or duplicated results."]}),"\n"]}),"\n",(0,t.jsx)(s.hr,{}),"\n",(0,t.jsx)(s.h3,{id:"cursor-based-pagination",children:"Cursor-Based Pagination"}),"\n",(0,t.jsx)(s.p,{children:"Cursor-based pagination is the preferred strategy in distributed systems because it avoids the problems of offset-based pagination \u2014 such as inconsistent results when data changes between pages, and performance issues with large offsets."}),"\n",(0,t.jsxs)(s.p,{children:["Instead of skipping rows, cursor-based pagination uses a ",(0,t.jsx)(s.strong,{children:"cursor value"})," to mark the position in the dataset and fetch the next page relative to that position."]}),"\n",(0,t.jsx)(s.hr,{}),"\n",(0,t.jsx)(s.h4,{id:"how-it-works",children:"How It Works"}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsxs)(s.li,{children:["The client receives a ",(0,t.jsx)(s.strong,{children:"cursor"})," from the API in each paginated response."]}),"\n",(0,t.jsx)(s.li,{children:"The client includes that cursor in the next request to fetch the next page."}),"\n",(0,t.jsx)(s.li,{children:"The server uses the cursor to determine where to resume from in the dataset."}),"\n"]}),"\n",(0,t.jsx)(s.hr,{}),"\n",(0,t.jsx)(s.h4,{id:"cursor-format",children:"Cursor Format"}),"\n",(0,t.jsxs)(s.p,{children:["The cursor is typically represented as a slice of values (",(0,t.jsx)(s.code,{children:"[]any"}),"), such as:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-json",children:'["2023-08-01T12:00:00Z", "user-123"]\n'})}),"\n",(0,t.jsxs)(s.p,{children:["This allows precise pagination even when multiple records share the same timestamp (e.g., ",(0,t.jsx)(s.code,{children:"createdAt"}),"). The second element (like a unique ID) ensures deterministic ordering and avoids skipping or duplicating records."]}),"\n",(0,t.jsx)(s.h4,{id:"example",children:"Example"}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Request 1"}),":"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-http",children:"GET /items?limit=10\n"})}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Response 1"}),":"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-json",children:'{\n  "items": [...],\n  // This is actually optional, one can easily take the fields from the last item in the list.\n  "nextCursor": ["2023-08-01T12:00:00Z", "user-123"]\n}\n'})}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-http",children:'GET /items?limit=10&after=["2023-08-01T12:00:00Z","user-123"]\n'})}),"\n",(0,t.jsx)(s.h3,{id:"field-name-conventions",children:"Field Name Conventions"}),"\n",(0,t.jsxs)(s.p,{children:["Pagination parameters should be top-level fields in a ",(0,t.jsx)(s.code,{children:"List"})," request. For example:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-json",children:'{\n  "limit": 10,\n  "after": ["2023-08-01T12:00:00Z", "user-123"],\n  "order": "asc",\n  "orderBy": "createdAt"\n}\n'})}),"\n",(0,t.jsx)(s.h3,{id:"common-ordering-strategies",children:"Common Ordering Strategies"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsxs)(s.strong,{children:[(0,t.jsx)(s.code,{children:"createdAt"})," (ascending)"]}),":",(0,t.jsx)(s.br,{}),"\n","Use when exporting or scanning all records from the beginning. This gives a complete, chronological view of the dataset."]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsxs)(s.strong,{children:[(0,t.jsx)(s.code,{children:"updatedAt"})," (descending)"]}),":",(0,t.jsx)(s.br,{}),"\n","Use when syncing recent changes (e.g., polling for updates). Returns the newest records first."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.hr,{}),"\n",(0,t.jsx)(s.h3,{id:"why-timestamps-alone-are-not-enough",children:"Why Timestamps Alone Are Not Enough"}),"\n",(0,t.jsxs)(s.p,{children:["Timestamps like ",(0,t.jsx)(s.code,{children:"createdAt"})," or ",(0,t.jsx)(s.code,{children:"updatedAt"})," are commonly used for ordering, but they are not unique. Multiple records can share the same timestamp, leading to unstable or overlapping pagination."]}),"\n",(0,t.jsxs)(s.p,{children:["To prevent this, always pair the timestamp with a ",(0,t.jsx)(s.strong,{children:"unique, stable identifier"})," (like an ID). This ensures:"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Deterministic ordering"}),"\n",(0,t.jsx)(s.li,{children:"No records are skipped or repeated"}),"\n",(0,t.jsx)(s.li,{children:"Proper continuation across pages, even when timestamps collide"}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:["No special parsing is required \u2014 the cursor is passed as a JSON array and can be unmarshaled directly as ",(0,t.jsx)(s.code,{children:"[]any"})," in Go."]}),"\n",(0,t.jsx)(s.h2,{id:"api-naming-guidelines",children:"API naming guidelines"}),"\n",(0,t.jsx)(s.h3,{id:"list-endpoints",children:"List* endpoints"}),"\n",(0,t.jsxs)(s.p,{children:["It is advised that endpoints returning entities are called ",(0,t.jsx)(s.code,{children:"ListEntities"}),", eg. ",(0,t.jsx)(s.code,{children:"ListMessages"}),". Do not create read/query endpoints that return a single entity unless you have good reasons to do so."]}),"\n",(0,t.jsx)(s.p,{children:"The list endpoints should have a few standard filters ideally:"}),"\n",(0,t.jsxs)(s.h4,{id:"ids-field",children:[(0,t.jsx)(s.code,{children:"ids"})," field"]}),"\n",(0,t.jsxs)(s.p,{children:["The field ",(0,t.jsx)(s.code,{children:"ids"})," should enable single and multiread by ID queries in list endpoints."]}),"\n",(0,t.jsx)(s.h3,{id:"save-endpoints",children:"Save* endpoints"}),"\n",(0,t.jsx)(s.p,{children:"For endpoints that create or update entities, it\u2019s recommended to use a unified SaveEntities naming convention (e.g., SaveMessages)."}),"\n",(0,t.jsx)(s.p,{children:"While separating Create and Update operations allows for more precise request schemas (since the required fields may differ), 1Backend favors the following principles:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Minimize the number of endpoints"})," \u2014 simpler APIs are easier to maintain and evolve."]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Prioritize idempotency"})," \u2014 Create endpoints typically aren't idempotent, while Save can be designed to be."]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Optimize for batch operations"})," \u2014 network calls are costly. Design endpoints to handle multiple entities at once. This not only improves efficiency but also makes it easier to scale or create specialized multi-* versions of your endpoint when performance demands arise."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"ids",children:"IDs"}),"\n",(0,t.jsxs)(s.p,{children:["Ids are by convention prefixed by a shorthand inspired by the entity name, think thread IDs being prefixed by ",(0,t.jsx)(s.code,{children:"thr_"}),"."]})]})}function h(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}}}]);