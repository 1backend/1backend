"use strict";(self.webpackChunksingulatron_api_docs=self.webpackChunksingulatron_api_docs||[]).push([[5462],{28453:(e,n,i)=>{i.d(n,{R:()=>d,x:()=>a});var s=i(96540);const t={},r=s.createContext(t);function d(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:d(e.components),s.createElement(r.Provider,{value:n},e.children)}},83430:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>u,frontMatter:()=>d,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"writing-custom-services/system-design-guidelines","title":"System design guidelines","description":"1Backend doesn\'t force you to use any particular patterns, languages, stacks, databases, or even conventions. 1Backend services themselves however follow some light conventions.","source":"@site/docs/writing-custom-services/system-design-guidelines.md","sourceDirName":"writing-custom-services","slug":"/writing-custom-services/system-design-guidelines","permalink":"/docs/writing-custom-services/system-design-guidelines","draft":false,"unlisted":false,"editUrl":"https://github.com/1backend/1backend/tree/main/docs-source/docs/writing-custom-services/system-design-guidelines.md","tags":[{"inline":true,"label":"test","permalink":"/docs/tags/test"}],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"tags":["test"]},"sidebar":"tutorialSidebar","previous":{"title":"Your first service","permalink":"/docs/writing-custom-services/your-first-service"},"next":{"title":"Command line","permalink":"/docs/category/command-line"}}');var t=i(74848),r=i(28453);const d={sidebar_position:4,tags:["test"]},a="System design guidelines",o={},l=[{value:"API naming guidelines",id:"api-naming-guidelines",level:2},{value:"List* endpoints",id:"list-endpoints",level:3},{value:"<code>ids</code> field",id:"ids-field",level:4},{value:"Pagination",id:"pagination",level:4},{value:"createdAt &amp; updatedAt ordering",id:"createdat--updatedat-ordering",level:4},{value:"Save* endpoints",id:"save-endpoints",level:2},{value:"IDs",id:"ids",level:3}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"system-design-guidelines",children:"System design guidelines"})}),"\n",(0,t.jsx)(n.p,{children:"1Backend doesn't force you to use any particular patterns, languages, stacks, databases, or even conventions. 1Backend services themselves however follow some light conventions."}),"\n",(0,t.jsx)(n.h2,{id:"api-naming-guidelines",children:"API naming guidelines"}),"\n",(0,t.jsx)(n.h3,{id:"list-endpoints",children:"List* endpoints"}),"\n",(0,t.jsxs)(n.p,{children:["It is advised that endpoints returning entities are called ",(0,t.jsx)(n.code,{children:"ListEntities"}),", eg. ",(0,t.jsx)(n.code,{children:"ListMessages"}),". Do not create read/query endpoints that return a single entity unless you have good reasons to do so."]}),"\n",(0,t.jsx)(n.p,{children:"The list endpoints should have a few standard filters ideally:"}),"\n",(0,t.jsxs)(n.h4,{id:"ids-field",children:[(0,t.jsx)(n.code,{children:"ids"})," field"]}),"\n",(0,t.jsxs)(n.p,{children:["The field ",(0,t.jsx)(n.code,{children:"ids"})," should enable single and multiread by ID queries in list endpoints."]}),"\n",(0,t.jsx)(n.h4,{id:"pagination",children:"Pagination"}),"\n",(0,t.jsx)(n.p,{children:"Pagination should happen with these fields in the top level of the List request:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "limit": 10,\n  "__comment_limit": "Limit is the maximum number of users to return.",\n\n  "afterTime": "2023-01-01T00:00:00Z",\n  "__comment_afterTime": "AfterTime is a time in RFC3339 format. It is used to paginate the results when the `orderBy` is set to `createdAt` or `updatedAt`. The results will be returned after this time.",\n\n  "order": "desc",\n  "orderBy": "createdAt",\n\n  "count": false,\n  "__comment_count": "Count is a flag that indicates if the count of the users should be returned."\n}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"createdat--updatedat-ordering",children:"createdAt & updatedAt ordering"}),"\n",(0,t.jsx)(n.p,{children:"Extracting data from microservices into external systems (like BigQuery) must respect service boundaries. Since each service owns its data, the only supported way to access it is through its API\u2014making efficient pagination essential."}),"\n",(0,t.jsx)(n.p,{children:"Traditional offset-based pagination can be inefficient in distributed systems, so 1Backend services use cursor-based pagination via the afterTime field."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Pagination using createdAt allows clients to perform a full scan of all records. This is typically done in ascending order, starting from the earliest entry."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Pagination using updatedAt is ideal for retrieving recently modified records. When sorted in descending order, it helps clients fetch the latest updates efficiently."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"save-endpoints",children:"Save* endpoints"}),"\n",(0,t.jsx)(n.p,{children:"For endpoints that create or update entities, it\u2019s recommended to use a unified SaveEntities naming convention (e.g., SaveMessages)."}),"\n",(0,t.jsx)(n.p,{children:"While separating Create and Update operations allows for more precise request schemas (since the required fields may differ), 1Backend favors the following principles:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Minimize the number of endpoints"})," \u2014 simpler APIs are easier to maintain and evolve."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Prioritize idempotency"})," \u2014 Create endpoints typically aren't idempotent, while Save can be designed to be."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Optimize for batch operations"})," \u2014 network calls are costly. Design endpoints to handle multiple entities at once. This not only improves efficiency but also makes it easier to scale or create specialized multi-* versions of your endpoint when performance demands arise."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"ids",children:"IDs"}),"\n",(0,t.jsxs)(n.p,{children:["Ids are by convention prefixed by a shorthand inspired by the entity name, think thread IDs being prefixed by ",(0,t.jsx)(n.code,{children:"thr_"}),"."]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}}}]);