"use strict";(self.webpackChunksingulatron_api_docs=self.webpackChunksingulatron_api_docs||[]).push([[5462],{28453:(e,n,s)=>{s.d(n,{R:()=>d,x:()=>o});var i=s(96540);const t={},r=i.createContext(t);function d(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:d(e.components),i.createElement(r.Provider,{value:n},e.children)}},83430:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>d,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"writing-custom-services/system-design-guidelines","title":"System design guidelines","description":"1Backend doesn\'t force you to use any particular patterns, languages, stacks, databases, or even conventions. 1Backend services themselves however follow some light conventions.","source":"@site/docs/writing-custom-services/system-design-guidelines.md","sourceDirName":"writing-custom-services","slug":"/writing-custom-services/system-design-guidelines","permalink":"/docs/writing-custom-services/system-design-guidelines","draft":false,"unlisted":false,"editUrl":"https://github.com/1backend/1backend/tree/main/docs-source/docs/writing-custom-services/system-design-guidelines.md","tags":[{"inline":true,"label":"test","permalink":"/docs/tags/test"}],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"tags":["test"]},"sidebar":"tutorialSidebar","previous":{"title":"Your first service","permalink":"/docs/writing-custom-services/your-first-service"},"next":{"title":"Command line","permalink":"/docs/category/command-line"}}');var t=s(74848),r=s(28453);const d={sidebar_position:4,tags:["test"]},o="System design guidelines",a={},l=[{value:"Pagination",id:"pagination",level:2},{value:"Offset vs. cursor pagination in distributed systems",id:"offset-vs-cursor-pagination-in-distributed-systems",level:3},{value:"Cursor-based pagination",id:"cursor-based-pagination",level:3},{value:"Example",id:"example",level:4},{value:"Field name conventions",id:"field-name-conventions",level:3},{value:"<code>createdAt</code> &amp; <code>updatedAt</code> ordering",id:"createdat--updatedat-ordering",level:3},{value:"Common ordering strategies",id:"common-ordering-strategies",level:3},{value:"<code>after</code> and <code>afterTime</code> Fields",id:"after-and-aftertime-fields",level:3},{value:"API naming guidelines",id:"api-naming-guidelines",level:2},{value:"List* endpoints",id:"list-endpoints",level:3},{value:"<code>ids</code> field",id:"ids-field",level:4},{value:"Save* endpoints",id:"save-endpoints",level:3},{value:"IDs",id:"ids",level:3}];function c(e){const n={br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"system-design-guidelines",children:"System design guidelines"})}),"\n",(0,t.jsx)(n.p,{children:"1Backend doesn't force you to use any particular patterns, languages, stacks, databases, or even conventions. 1Backend services themselves however follow some light conventions."}),"\n",(0,t.jsx)(n.h2,{id:"pagination",children:"Pagination"}),"\n",(0,t.jsx)(n.h3,{id:"offset-vs-cursor-pagination-in-distributed-systems",children:"Offset vs. cursor pagination in distributed systems"}),"\n",(0,t.jsxs)(n.p,{children:["In distributed systems\u2014especially when dealing with large datasets or high write volumes\u2014",(0,t.jsx)(n.strong,{children:"OFFSET-based pagination"})," is inefficient and unstable because:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Performance:"})," The database still has to scan through all skipped rows before returning results."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Consistency:"})," New inserts or deletes between requests can cause missing or duplicated results."]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"cursor-based-pagination",children:"Cursor-based pagination"}),"\n",(0,t.jsx)(n.p,{children:"Cursor-based pagination solves these problems by:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Using a ",(0,t.jsx)(n.strong,{children:"cursor"})," (often an encoded value, like a timestamp or an ID) that marks your position in the result set."]}),"\n",(0,t.jsxs)(n.li,{children:["Querying for results ",(0,t.jsx)(n.strong,{children:'"after"'})," that cursor instead of skipping rows."]}),"\n",(0,t.jsx)(n.li,{children:"Returning a new cursor in each response for the client to use for the next page."}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h4,{id:"example",children:"Example"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Request 1:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-http",children:"GET /items?limit=10\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Response 1:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "items": [...],\n  "next_cursor": "2023-08-01T12:00:00Z"\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Request 2:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-http",children:"GET /items?limit=10&after=2023-08-01T12:00:00Z\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Common names for cursor-bbased pagination"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Cursor pagination (common in APIs like GraphQL and Twitter API)"}),"\n",(0,t.jsx)(n.li,{children:"Keyset pagination (common in SQL performance discussions)"}),"\n",(0,t.jsx)(n.li,{children:'Sometimes just "after-based pagination" (naming it after the query parameter)'}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"field-name-conventions",children:"Field name conventions"}),"\n",(0,t.jsxs)(n.p,{children:["Pagination should happen with these fields in the top level of a ",(0,t.jsx)(n.code,{children:"List"})," request:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "limit": 10,\n  "__comment_limit": "Limit is the maximum number of users to return.",\n\n  "afterTime": "2023-01-01T00:00:00Z",\n  "__comment_afterTime": "AfterTime is a time in RFC3339 format. It is used to paginate the results when the `orderBy` is set to `createdAt` or `updatedAt`. The results will be returned after this time.",\n\n  "order": "desc",\n  "orderBy": "createdAt",\n\n  "count": false,\n  "__comment_count": "Count is a flag that indicates if the count of the users should be returned."\n}\n'})}),"\n",(0,t.jsxs)(n.h3,{id:"createdat--updatedat-ordering",children:[(0,t.jsx)(n.code,{children:"createdAt"})," & ",(0,t.jsx)(n.code,{children:"updatedAt"})," ordering"]}),"\n",(0,t.jsxs)(n.p,{children:["When exporting data from microservices into external systems (such as BigQuery), it\u2019s important to respect ",(0,t.jsx)(n.strong,{children:"service boundaries"}),".",(0,t.jsx)(n.br,{}),"\n","Each service owns its own data, and the only supported way to access it is through that service\u2019s API.",(0,t.jsx)(n.br,{}),"\n","This makes ",(0,t.jsx)(n.strong,{children:"efficient pagination"})," critical for both performance and reliability."]}),"\n",(0,t.jsxs)(n.p,{children:["Offset-based pagination (e.g., ",(0,t.jsx)(n.code,{children:"offset=100&limit=50"}),") can be slow and unreliable in distributed systems, especially as datasets grow or records change during retrieval.",(0,t.jsx)(n.br,{}),"\n","Instead, 1Backend services use ",(0,t.jsx)(n.strong,{children:"cursor-based pagination"}),", where the client provides a \u201cbookmark\u201d that tells the API where to resume.",(0,t.jsx)(n.br,{}),"\n","For time-based pagination, this bookmark is expressed through the ",(0,t.jsx)(n.code,{children:"afterTime"})," field."]}),"\n",(0,t.jsx)(n.h3,{id:"common-ordering-strategies",children:"Common ordering strategies"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsxs)(n.strong,{children:["Pagination by ",(0,t.jsx)(n.code,{children:"createdAt"})]}),(0,t.jsx)(n.br,{}),"\n","Use when you need to retrieve ",(0,t.jsx)(n.em,{children:"all"})," records from the beginning, such as during a full export.",(0,t.jsx)(n.br,{}),"\n","Typically ordered ",(0,t.jsx)(n.strong,{children:"ascending"}),", starting with the oldest entries and moving forward in time."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsxs)(n.strong,{children:["Pagination by ",(0,t.jsx)(n.code,{children:"updatedAt"})]}),(0,t.jsx)(n.br,{}),"\n","Use when you need to retrieve ",(0,t.jsx)(n.em,{children:"recently changed"})," records, such as for an incremental sync.",(0,t.jsx)(n.br,{}),"\n","Typically ordered ",(0,t.jsx)(n.strong,{children:"descending"}),", returning the most recent changes first."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsxs)(n.h3,{id:"after-and-aftertime-fields",children:[(0,t.jsx)(n.code,{children:"after"})," and ",(0,t.jsx)(n.code,{children:"afterTime"})," Fields"]}),"\n",(0,t.jsxs)(n.p,{children:["In theory, a pagination cursor could be named simply ",(0,t.jsx)(n.code,{children:"after"})," and accept any type of value (or an array of values).",(0,t.jsx)(n.br,{}),"\n","However, when the cursor represents a timestamp, using a generic ",(0,t.jsx)(n.code,{children:"after"})," field would require extra parsing logic to convert it into a ",(0,t.jsx)(n.code,{children:"time.Time"})," object in Go."]}),"\n",(0,t.jsxs)(n.p,{children:["To avoid this and allow ",(0,t.jsx)(n.strong,{children:"automatic unmarshaling"})," into ",(0,t.jsx)(n.code,{children:"time.Time"}),", the convention for time-based pagination is to name the field ",(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"afterTime"})}),".",(0,t.jsx)(n.br,{}),"\n","This makes the expected format explicit (RFC3339 timestamp) and removes the need for custom parsing."]}),"\n",(0,t.jsx)(n.h2,{id:"api-naming-guidelines",children:"API naming guidelines"}),"\n",(0,t.jsx)(n.h3,{id:"list-endpoints",children:"List* endpoints"}),"\n",(0,t.jsxs)(n.p,{children:["It is advised that endpoints returning entities are called ",(0,t.jsx)(n.code,{children:"ListEntities"}),", eg. ",(0,t.jsx)(n.code,{children:"ListMessages"}),". Do not create read/query endpoints that return a single entity unless you have good reasons to do so."]}),"\n",(0,t.jsx)(n.p,{children:"The list endpoints should have a few standard filters ideally:"}),"\n",(0,t.jsxs)(n.h4,{id:"ids-field",children:[(0,t.jsx)(n.code,{children:"ids"})," field"]}),"\n",(0,t.jsxs)(n.p,{children:["The field ",(0,t.jsx)(n.code,{children:"ids"})," should enable single and multiread by ID queries in list endpoints."]}),"\n",(0,t.jsx)(n.h3,{id:"save-endpoints",children:"Save* endpoints"}),"\n",(0,t.jsx)(n.p,{children:"For endpoints that create or update entities, it\u2019s recommended to use a unified SaveEntities naming convention (e.g., SaveMessages)."}),"\n",(0,t.jsx)(n.p,{children:"While separating Create and Update operations allows for more precise request schemas (since the required fields may differ), 1Backend favors the following principles:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Minimize the number of endpoints"})," \u2014 simpler APIs are easier to maintain and evolve."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Prioritize idempotency"})," \u2014 Create endpoints typically aren't idempotent, while Save can be designed to be."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Optimize for batch operations"})," \u2014 network calls are costly. Design endpoints to handle multiple entities at once. This not only improves efficiency but also makes it easier to scale or create specialized multi-* versions of your endpoint when performance demands arise."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"ids",children:"IDs"}),"\n",(0,t.jsxs)(n.p,{children:["Ids are by convention prefixed by a shorthand inspired by the entity name, think thread IDs being prefixed by ",(0,t.jsx)(n.code,{children:"thr_"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}}}]);