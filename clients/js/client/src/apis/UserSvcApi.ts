/* tslint:disable */
/* eslint-disable */
/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc8
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  UserSvcChangePasswordRequest,
  UserSvcCreateUserRequest,
  UserSvcErrorResponse,
  UserSvcExchangeTokenRequest,
  UserSvcExchangeTokenResponse,
  UserSvcGetPublicKeyResponse,
  UserSvcHasPermissionResponse,
  UserSvcListAppsRequest,
  UserSvcListAppsResponse,
  UserSvcListEnrollsRequest,
  UserSvcListEnrollsResponse,
  UserSvcListOrganizationsRequest,
  UserSvcListOrganizationsResponse,
  UserSvcListPermissionsResponse,
  UserSvcListPermitsRequest,
  UserSvcListPermitsResponse,
  UserSvcListUsersRequest,
  UserSvcListUsersResponse,
  UserSvcLoginRequest,
  UserSvcLoginResponse,
  UserSvcReadSelfRequest,
  UserSvcReadSelfResponse,
  UserSvcRefreshTokenResponse,
  UserSvcRegisterRequest,
  UserSvcRegisterResponse,
  UserSvcResetPasswordRequest,
  UserSvcRevokeTokensRequest,
  UserSvcSaveEnrollsRequest,
  UserSvcSaveEnrollsResponse,
  UserSvcSaveOrganizationRequest,
  UserSvcSaveOrganizationResponse,
  UserSvcSavePermitsRequest,
  UserSvcSaveSelfRequest,
  UserSvcSaveUserRequest,
} from '../models/index';
import {
    UserSvcChangePasswordRequestFromJSON,
    UserSvcChangePasswordRequestToJSON,
    UserSvcCreateUserRequestFromJSON,
    UserSvcCreateUserRequestToJSON,
    UserSvcErrorResponseFromJSON,
    UserSvcErrorResponseToJSON,
    UserSvcExchangeTokenRequestFromJSON,
    UserSvcExchangeTokenRequestToJSON,
    UserSvcExchangeTokenResponseFromJSON,
    UserSvcExchangeTokenResponseToJSON,
    UserSvcGetPublicKeyResponseFromJSON,
    UserSvcGetPublicKeyResponseToJSON,
    UserSvcHasPermissionResponseFromJSON,
    UserSvcHasPermissionResponseToJSON,
    UserSvcListAppsRequestFromJSON,
    UserSvcListAppsRequestToJSON,
    UserSvcListAppsResponseFromJSON,
    UserSvcListAppsResponseToJSON,
    UserSvcListEnrollsRequestFromJSON,
    UserSvcListEnrollsRequestToJSON,
    UserSvcListEnrollsResponseFromJSON,
    UserSvcListEnrollsResponseToJSON,
    UserSvcListOrganizationsRequestFromJSON,
    UserSvcListOrganizationsRequestToJSON,
    UserSvcListOrganizationsResponseFromJSON,
    UserSvcListOrganizationsResponseToJSON,
    UserSvcListPermissionsResponseFromJSON,
    UserSvcListPermissionsResponseToJSON,
    UserSvcListPermitsRequestFromJSON,
    UserSvcListPermitsRequestToJSON,
    UserSvcListPermitsResponseFromJSON,
    UserSvcListPermitsResponseToJSON,
    UserSvcListUsersRequestFromJSON,
    UserSvcListUsersRequestToJSON,
    UserSvcListUsersResponseFromJSON,
    UserSvcListUsersResponseToJSON,
    UserSvcLoginRequestFromJSON,
    UserSvcLoginRequestToJSON,
    UserSvcLoginResponseFromJSON,
    UserSvcLoginResponseToJSON,
    UserSvcReadSelfRequestFromJSON,
    UserSvcReadSelfRequestToJSON,
    UserSvcReadSelfResponseFromJSON,
    UserSvcReadSelfResponseToJSON,
    UserSvcRefreshTokenResponseFromJSON,
    UserSvcRefreshTokenResponseToJSON,
    UserSvcRegisterRequestFromJSON,
    UserSvcRegisterRequestToJSON,
    UserSvcRegisterResponseFromJSON,
    UserSvcRegisterResponseToJSON,
    UserSvcResetPasswordRequestFromJSON,
    UserSvcResetPasswordRequestToJSON,
    UserSvcRevokeTokensRequestFromJSON,
    UserSvcRevokeTokensRequestToJSON,
    UserSvcSaveEnrollsRequestFromJSON,
    UserSvcSaveEnrollsRequestToJSON,
    UserSvcSaveEnrollsResponseFromJSON,
    UserSvcSaveEnrollsResponseToJSON,
    UserSvcSaveOrganizationRequestFromJSON,
    UserSvcSaveOrganizationRequestToJSON,
    UserSvcSaveOrganizationResponseFromJSON,
    UserSvcSaveOrganizationResponseToJSON,
    UserSvcSavePermitsRequestFromJSON,
    UserSvcSavePermitsRequestToJSON,
    UserSvcSaveSelfRequestFromJSON,
    UserSvcSaveSelfRequestToJSON,
    UserSvcSaveUserRequestFromJSON,
    UserSvcSaveUserRequestToJSON,
} from '../models/index';

export interface ChangePasswordRequest {
    body: UserSvcChangePasswordRequest;
}

export interface CreateUserRequest {
    body: UserSvcCreateUserRequest;
}

export interface DeleteMembershipRequest {
    organizationId: string;
    userId: string;
    body?: object;
}

export interface DeleteUserRequest {
    userId: string;
}

export interface ExchangeTokenRequest {
    body: UserSvcExchangeTokenRequest;
}

export interface ExchangeToken0Request {
    body: UserSvcExchangeTokenRequest;
}

export interface HasPermissionRequest {
    permission: string;
}

export interface ListAppsRequest {
    body: UserSvcListAppsRequest;
}

export interface ListEnrollsRequest {
    body: UserSvcListEnrollsRequest;
}

export interface ListOrganizationsRequest {
    body?: UserSvcListOrganizationsRequest;
}

export interface ListPermissionsRequest {
    roleId: string;
}

export interface ListPermitsRequest {
    body: UserSvcListPermitsRequest;
}

export interface ListUsersRequest {
    body?: UserSvcListUsersRequest;
}

export interface LoginRequest {
    body: UserSvcLoginRequest;
}

export interface ReadSelfRequest {
    body?: UserSvcReadSelfRequest;
}

export interface RegisterRequest {
    body: UserSvcRegisterRequest;
}

export interface ResetPasswordRequest {
    userId: string;
    body: UserSvcResetPasswordRequest;
}

export interface RevokeTokensRequest {
    body?: UserSvcRevokeTokensRequest;
}

export interface SaveEnrollsRequest {
    body: UserSvcSaveEnrollsRequest;
}

export interface SaveMembershipRequest {
    organizationId: string;
    userId: string;
    body?: object;
}

export interface SaveOrganizationRequest {
    body: UserSvcSaveOrganizationRequest;
}

export interface SavePermitsRequest {
    body: UserSvcSavePermitsRequest;
}

export interface SaveSelfRequest {
    body: UserSvcSaveSelfRequest;
}

export interface SaveUserRequest {
    userId: string;
    body: UserSvcSaveUserRequest;
}

/**
 * 
 */
export class UserSvcApi extends runtime.BaseAPI {

    /**
     * Allows an authenticated user to change their own password.
     * Change Password
     */
    async changePasswordRaw(requestParameters: ChangePasswordRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling changePassword().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // BearerAuth authentication
        }


        let urlPath = `/user-svc/change-password`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UserSvcChangePasswordRequestToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Allows an authenticated user to change their own password.
     * Change Password
     */
    async changePassword(requestParameters: ChangePasswordRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.changePasswordRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Allows an authenticated administrator to create a new user with specified details.
     * Create a New User
     */
    async createUserRaw(requestParameters: CreateUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling createUser().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // BearerAuth authentication
        }


        let urlPath = `/user-svc/user`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UserSvcCreateUserRequestToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Allows an authenticated administrator to create a new user with specified details.
     * Create a New User
     */
    async createUser(requestParameters: CreateUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.createUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Allows an organization admin to remove a user from an organization.
     * Delete Membership
     */
    async deleteMembershipRaw(requestParameters: DeleteMembershipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters['organizationId'] == null) {
            throw new runtime.RequiredError(
                'organizationId',
                'Required parameter "organizationId" was null or undefined when calling deleteMembership().'
            );
        }

        if (requestParameters['userId'] == null) {
            throw new runtime.RequiredError(
                'userId',
                'Required parameter "userId" was null or undefined when calling deleteMembership().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // BearerAuth authentication
        }


        let urlPath = `/user-svc/organization/{organizationId}/user/{userId}`;
        urlPath = urlPath.replace(`{${"organizationId"}}`, encodeURIComponent(String(requestParameters['organizationId'])));
        urlPath = urlPath.replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters['userId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Allows an organization admin to remove a user from an organization.
     * Delete Membership
     */
    async deleteMembership(requestParameters: DeleteMembershipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.deleteMembershipRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a user based on the user ID.
     * Delete a User
     */
    async deleteUserRaw(requestParameters: DeleteUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters['userId'] == null) {
            throw new runtime.RequiredError(
                'userId',
                'Required parameter "userId" was null or undefined when calling deleteUser().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // BearerAuth authentication
        }


        let urlPath = `/user-svc/user/{userId}`;
        urlPath = urlPath.replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters['userId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Delete a user based on the user ID.
     * Delete a User
     */
    async deleteUser(requestParameters: DeleteUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.deleteUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Exchange an existing token for a new token scoped to a different app (namespace). The new token represents the same user but contains roles specific to the target app.  The original token remains valid. The minted token is not stored and cannot be refreshed (and will have the same expiration duration as normal tokens), unlike tokens acquired via login.  For now, token exchange is designed to be in situ — the User Svc must be contacted at exchange time. This introduces a stateful dependency on the User Svc, but simplifies things until broader use cases emerge.
     * Exchange Token
     */
    async exchangeTokenRaw(requestParameters: ExchangeTokenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserSvcExchangeTokenResponse>> {
        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling exchangeToken().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/user-svc/token/exchange`;

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UserSvcExchangeTokenRequestToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserSvcExchangeTokenResponseFromJSON(jsonValue));
    }

    /**
     * Exchange an existing token for a new token scoped to a different app (namespace). The new token represents the same user but contains roles specific to the target app.  The original token remains valid. The minted token is not stored and cannot be refreshed (and will have the same expiration duration as normal tokens), unlike tokens acquired via login.  For now, token exchange is designed to be in situ — the User Svc must be contacted at exchange time. This introduces a stateful dependency on the User Svc, but simplifies things until broader use cases emerge.
     * Exchange Token
     */
    async exchangeToken(requestParameters: ExchangeTokenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserSvcExchangeTokenResponse> {
        const response = await this.exchangeTokenRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Exchange an existing token for a new token scoped to a different app (namespace). The new token represents the same user but contains roles specific to the target app.  The original token remains valid. The minted token is not stored and cannot be refreshed (and will have the same expiration duration as normal tokens), unlike tokens acquired via login.  For now, token exchange is designed to be in situ — the User Svc must be contacted at exchange time. This introduces a stateful dependency on the User Svc, but simplifies things until broader use cases emerge.
     * Exchange Token
     */
    async exchangeToken_1Raw(requestParameters: ExchangeToken0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserSvcExchangeTokenResponse>> {
        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling exchangeToken_1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/user-svc/token/exchange`;

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UserSvcExchangeTokenRequestToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserSvcExchangeTokenResponseFromJSON(jsonValue));
    }

    /**
     * Exchange an existing token for a new token scoped to a different app (namespace). The new token represents the same user but contains roles specific to the target app.  The original token remains valid. The minted token is not stored and cannot be refreshed (and will have the same expiration duration as normal tokens), unlike tokens acquired via login.  For now, token exchange is designed to be in situ — the User Svc must be contacted at exchange time. This introduces a stateful dependency on the User Svc, but simplifies things until broader use cases emerge.
     * Exchange Token
     */
    async exchangeToken_1(requestParameters: ExchangeToken0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserSvcExchangeTokenResponse> {
        const response = await this.exchangeToken_1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the public key to verify the JWT signature.
     * Get Public Key
     */
    async getPublicKeyRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserSvcGetPublicKeyResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/user-svc/public-key`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserSvcGetPublicKeyResponseFromJSON(jsonValue));
    }

    /**
     * Get the public key to verify the JWT signature.
     * Get Public Key
     */
    async getPublicKey(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserSvcGetPublicKeyResponse> {
        const response = await this.getPublicKeyRaw(initOverrides);
        return await response.value();
    }

    /**
     * Checks whether the caller has a specific permission. Optimized for caching — only the caller and the permission are required. To assign a permission to a user or role, use the `Save Permits` endpoint.  This endpoint does not return 401 Unauthorized if access is denied. Instead, it always returns 200 OK with `Authorized: false` if the permission is missing. The response will still include the caller’s user information if not authorized.
     * Has Permission
     */
    async hasPermissionRaw(requestParameters: HasPermissionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserSvcHasPermissionResponse>> {
        if (requestParameters['permission'] == null) {
            throw new runtime.RequiredError(
                'permission',
                'Required parameter "permission" was null or undefined when calling hasPermission().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // BearerAuth authentication
        }


        let urlPath = `/user-svc/self/has/{permission}`;
        urlPath = urlPath.replace(`{${"permission"}}`, encodeURIComponent(String(requestParameters['permission'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserSvcHasPermissionResponseFromJSON(jsonValue));
    }

    /**
     * Checks whether the caller has a specific permission. Optimized for caching — only the caller and the permission are required. To assign a permission to a user or role, use the `Save Permits` endpoint.  This endpoint does not return 401 Unauthorized if access is denied. Instead, it always returns 200 OK with `Authorized: false` if the permission is missing. The response will still include the caller’s user information if not authorized.
     * Has Permission
     */
    async hasPermission(requestParameters: HasPermissionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserSvcHasPermissionResponse> {
        const response = await this.hasPermissionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List apps. Role, user ID or contact ID must be specified.  Requires the `user-svc:app:view` permission, which by default all users have. Caller can only list apps of roles they own (unless they are an admin).
     * List Apps
     */
    async listAppsRaw(requestParameters: ListAppsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserSvcListAppsResponse>> {
        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling listApps().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // BearerAuth authentication
        }


        let urlPath = `/user-svc/apps`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UserSvcListAppsRequestToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserSvcListAppsResponseFromJSON(jsonValue));
    }

    /**
     * List apps. Role, user ID or contact ID must be specified.  Requires the `user-svc:app:view` permission, which by default all users have. Caller can only list apps of roles they own (unless they are an admin).
     * List Apps
     */
    async listApps(requestParameters: ListAppsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserSvcListAppsResponse> {
        const response = await this.listAppsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List enrolls. Role, user ID or contact ID must be specified.  Requires the `user-svc:enroll:view` permission, which by default all users have. Caller can only list enrolls of roles they own (unless they are an admin).
     * List Enrolls
     */
    async listEnrollsRaw(requestParameters: ListEnrollsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserSvcListEnrollsResponse>> {
        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling listEnrolls().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // BearerAuth authentication
        }


        let urlPath = `/user-svc/enrolls`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UserSvcListEnrollsRequestToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserSvcListEnrollsResponseFromJSON(jsonValue));
    }

    /**
     * List enrolls. Role, user ID or contact ID must be specified.  Requires the `user-svc:enroll:view` permission, which by default all users have. Caller can only list enrolls of roles they own (unless they are an admin).
     * List Enrolls
     */
    async listEnrolls(requestParameters: ListEnrollsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserSvcListEnrollsResponse> {
        const response = await this.listEnrollsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Requires the `user-svc:organization:view` permission, that only admins have by default.
     * List Organizations
     */
    async listOrganizationsRaw(requestParameters: ListOrganizationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserSvcListOrganizationsResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // BearerAuth authentication
        }


        let urlPath = `/user-svc/organizations`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UserSvcListOrganizationsRequestToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserSvcListOrganizationsResponseFromJSON(jsonValue));
    }

    /**
     * Requires the `user-svc:organization:view` permission, that only admins have by default.
     * List Organizations
     */
    async listOrganizations(requestParameters: ListOrganizationsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserSvcListOrganizationsResponse> {
        const response = await this.listOrganizationsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List permissions by roles. Caller can only list permissions for roles they have.
     * List Permissions
     */
    async listPermissionsRaw(requestParameters: ListPermissionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserSvcListPermissionsResponse>> {
        if (requestParameters['roleId'] == null) {
            throw new runtime.RequiredError(
                'roleId',
                'Required parameter "roleId" was null or undefined when calling listPermissions().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // BearerAuth authentication
        }


        let urlPath = `/user-svc/permissions`;
        urlPath = urlPath.replace(`{${"roleId"}}`, encodeURIComponent(String(requestParameters['roleId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserSvcListPermissionsResponseFromJSON(jsonValue));
    }

    /**
     * List permissions by roles. Caller can only list permissions for roles they have.
     * List Permissions
     */
    async listPermissions(requestParameters: ListPermissionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserSvcListPermissionsResponse> {
        const response = await this.listPermissionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List permits. Requires the `user-svc:permit:view` permission, which only admins have by default. &todo Users should be able to list permits referring to them.
     * List Permits
     */
    async listPermitsRaw(requestParameters: ListPermitsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserSvcListPermitsResponse>> {
        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling listPermits().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // BearerAuth authentication
        }


        let urlPath = `/user-svc/permits`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UserSvcListPermitsRequestToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserSvcListPermitsResponseFromJSON(jsonValue));
    }

    /**
     * List permits. Requires the `user-svc:permit:view` permission, which only admins have by default. &todo Users should be able to list permits referring to them.
     * List Permits
     */
    async listPermits(requestParameters: ListPermitsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserSvcListPermitsResponse> {
        const response = await this.listPermitsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetches a list of users with optional query filters and pagination. Requires the `user-svc:user:view` permission that only admins have by default.
     * List Users
     */
    async listUsersRaw(requestParameters: ListUsersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserSvcListUsersResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // BearerAuth authentication
        }


        let urlPath = `/user-svc/users`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UserSvcListUsersRequestToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserSvcListUsersResponseFromJSON(jsonValue));
    }

    /**
     * Fetches a list of users with optional query filters and pagination. Requires the `user-svc:user:view` permission that only admins have by default.
     * List Users
     */
    async listUsers(requestParameters: ListUsersRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserSvcListUsersResponse> {
        const response = await this.listUsersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Authenticates a user and returns a token.
     * Login
     */
    async loginRaw(requestParameters: LoginRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserSvcLoginResponse>> {
        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling login().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/user-svc/login`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UserSvcLoginRequestToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserSvcLoginResponseFromJSON(jsonValue));
    }

    /**
     * Authenticates a user and returns a token.
     * Login
     */
    async login(requestParameters: LoginRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserSvcLoginResponse> {
        const response = await this.loginRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves user information based on the authentication token in the request header. Typically called by single-page applications during the initial page load. While some details (such as roles, slug, user ID, and active organization ID) can be extracted from the JWT, this endpoint returns additional data, including the full user object and associated organizations.  ReadSelf intentionally still works after token revocation until the token expires. This is to ensure that the user is not notified of token revocation (though some information is leaked by the count token functionality @todo).
     * Read Self
     */
    async readSelfRaw(requestParameters: ReadSelfRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserSvcReadSelfResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // BearerAuth authentication
        }


        let urlPath = `/user-svc/self`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UserSvcReadSelfRequestToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserSvcReadSelfResponseFromJSON(jsonValue));
    }

    /**
     * Retrieves user information based on the authentication token in the request header. Typically called by single-page applications during the initial page load. While some details (such as roles, slug, user ID, and active organization ID) can be extracted from the JWT, this endpoint returns additional data, including the full user object and associated organizations.  ReadSelf intentionally still works after token revocation until the token expires. This is to ensure that the user is not notified of token revocation (though some information is leaked by the count token functionality @todo).
     * Read Self
     */
    async readSelf(requestParameters: ReadSelfRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserSvcReadSelfResponse> {
        const response = await this.readSelfRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Refreshes an existing token, including inactive ones. The old token becomes inactive (if not already inactive), and a new, active token is issued. This allows continued verification of user roles without requiring a new login. Inactive tokens are refreshable unless explicitly revoked (no mechanism for this yet). Leaked tokens should be handled separately, via a revocation flag or deletion.
     * Refresh Token
     */
    async refreshTokenRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserSvcRefreshTokenResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/user-svc/refresh-token`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserSvcRefreshTokenResponseFromJSON(jsonValue));
    }

    /**
     * Refreshes an existing token, including inactive ones. The old token becomes inactive (if not already inactive), and a new, active token is issued. This allows continued verification of user roles without requiring a new login. Inactive tokens are refreshable unless explicitly revoked (no mechanism for this yet). Leaked tokens should be handled separately, via a revocation flag or deletion.
     * Refresh Token
     */
    async refreshToken(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserSvcRefreshTokenResponse> {
        const response = await this.refreshTokenRaw(initOverrides);
        return await response.value();
    }

    /**
     * Register a new user with a name, email, and password.
     * Register
     */
    async registerRaw(requestParameters: RegisterRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserSvcRegisterResponse>> {
        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling register().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/user-svc/register`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UserSvcRegisterRequestToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserSvcRegisterResponseFromJSON(jsonValue));
    }

    /**
     * Register a new user with a name, email, and password.
     * Register
     */
    async register(requestParameters: RegisterRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserSvcRegisterResponse> {
        const response = await this.registerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Allows an administrator to change a user\'s password.
     * Reset Password
     */
    async resetPasswordRaw(requestParameters: ResetPasswordRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters['userId'] == null) {
            throw new runtime.RequiredError(
                'userId',
                'Required parameter "userId" was null or undefined when calling resetPassword().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling resetPassword().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // BearerAuth authentication
        }


        let urlPath = `/user-svc/{userId}/reset-password`;
        urlPath = urlPath.replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters['userId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UserSvcResetPasswordRequestToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Allows an administrator to change a user\'s password.
     * Reset Password
     */
    async resetPassword(requestParameters: ResetPasswordRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.resetPasswordRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Revoke tokens in one of the following scenarios: - For the current user. - For another user (see `userId` field), if permitted (`user-svc:token:revoke` permission, typically by admins).
     * Revoke Tokens
     */
    async revokeTokensRaw(requestParameters: RevokeTokensRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // BearerAuth authentication
        }


        let urlPath = `/user-svc/tokens`;

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: UserSvcRevokeTokensRequestToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Revoke tokens in one of the following scenarios: - For the current user. - For another user (see `userId` field), if permitted (`user-svc:token:revoke` permission, typically by admins).
     * Revoke Tokens
     */
    async revokeTokens(requestParameters: RevokeTokensRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.revokeTokensRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Enroll a list of users by contact or user Id to acquire a role. Works on future or current users.  A user can only enroll an other user to a role if the user \"owns\" that role. A user who owns a role can enroll others in that roll in any app. The same request might contain enrolls for different apps.  A user \"owns\" a role in the following cases: - A static role where the role ID is prefixed with the caller\'s slug. - Any dynamic or static role where the caller is an admin (has `*:admin` postfix of that role).  Examples: - A user with the slug `joe-doe` owns roles like `joe-doe:*` such as `joe-doe:any-custom-role`. - A user with any slug who has the role `my-service:admin` owns `my-service:*` roles such as `my-service:user`. - A user with any slug who has the role `user-svc:org:{%orgId}:admin` owns `user-svc:org:{%orgId}:*` such as `user-svc:org:{%orgId}:user`.
     * Save Enrolls
     */
    async saveEnrollsRaw(requestParameters: SaveEnrollsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserSvcSaveEnrollsResponse>> {
        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling saveEnrolls().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // BearerAuth authentication
        }


        let urlPath = `/user-svc/enrolls`;

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UserSvcSaveEnrollsRequestToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserSvcSaveEnrollsResponseFromJSON(jsonValue));
    }

    /**
     * Enroll a list of users by contact or user Id to acquire a role. Works on future or current users.  A user can only enroll an other user to a role if the user \"owns\" that role. A user who owns a role can enroll others in that roll in any app. The same request might contain enrolls for different apps.  A user \"owns\" a role in the following cases: - A static role where the role ID is prefixed with the caller\'s slug. - Any dynamic or static role where the caller is an admin (has `*:admin` postfix of that role).  Examples: - A user with the slug `joe-doe` owns roles like `joe-doe:*` such as `joe-doe:any-custom-role`. - A user with any slug who has the role `my-service:admin` owns `my-service:*` roles such as `my-service:user`. - A user with any slug who has the role `user-svc:org:{%orgId}:admin` owns `user-svc:org:{%orgId}:*` such as `user-svc:org:{%orgId}:user`.
     * Save Enrolls
     */
    async saveEnrolls(requestParameters: SaveEnrollsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserSvcSaveEnrollsResponse> {
        const response = await this.saveEnrollsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Adds a user to an organization by saving a Membership. Also issues the corresponding Enroll, which grants the user their dynamic organization role (e.g. `user-svc:org:{org_123}:user`).
     * Save Membership
     */
    async saveMembershipRaw(requestParameters: SaveMembershipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters['organizationId'] == null) {
            throw new runtime.RequiredError(
                'organizationId',
                'Required parameter "organizationId" was null or undefined when calling saveMembership().'
            );
        }

        if (requestParameters['userId'] == null) {
            throw new runtime.RequiredError(
                'userId',
                'Required parameter "userId" was null or undefined when calling saveMembership().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // BearerAuth authentication
        }


        let urlPath = `/user-svc/organization/{organizationId}/user/{userId}`;
        urlPath = urlPath.replace(`{${"organizationId"}}`, encodeURIComponent(String(requestParameters['organizationId'])));
        urlPath = urlPath.replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters['userId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Adds a user to an organization by saving a Membership. Also issues the corresponding Enroll, which grants the user their dynamic organization role (e.g. `user-svc:org:{org_123}:user`).
     * Save Membership
     */
    async saveMembership(requestParameters: SaveMembershipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.saveMembershipRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Allows a logged-in user to save an organization. The user initiating the request will be assigned the role of admin for that organization. The initiating user will receive a dynamic role in the format `user-svc:org:{organizationId}:admin`, where `{organizationId}` is a unique identifier for the saved organization. Dynamic roles are generated based on specific user-resource associations (in this case the resource being the organization), offering more flexible permission management compared to static roles.
     * Save an Organization
     */
    async saveOrganizationRaw(requestParameters: SaveOrganizationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserSvcSaveOrganizationResponse>> {
        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling saveOrganization().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // BearerAuth authentication
        }


        let urlPath = `/user-svc/organization`;

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UserSvcSaveOrganizationRequestToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserSvcSaveOrganizationResponseFromJSON(jsonValue));
    }

    /**
     * Allows a logged-in user to save an organization. The user initiating the request will be assigned the role of admin for that organization. The initiating user will receive a dynamic role in the format `user-svc:org:{organizationId}:admin`, where `{organizationId}` is a unique identifier for the saved organization. Dynamic roles are generated based on specific user-resource associations (in this case the resource being the organization), offering more flexible permission management compared to static roles.
     * Save an Organization
     */
    async saveOrganization(requestParameters: SaveOrganizationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserSvcSaveOrganizationResponse> {
        const response = await this.saveOrganizationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Save permits. Permits give access to users with certain slugs and roles to permissions.
     * Save Permits
     */
    async savePermitsRaw(requestParameters: SavePermitsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling savePermits().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // BearerAuth authentication
        }


        let urlPath = `/user-svc/permits`;

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UserSvcSavePermitsRequestToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Save permits. Permits give access to users with certain slugs and roles to permissions.
     * Save Permits
     */
    async savePermits(requestParameters: SavePermitsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.savePermitsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Save user\'s own profile information.
     * Save User Profile
     */
    async saveSelfRaw(requestParameters: SaveSelfRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling saveSelf().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // BearerAuth authentication
        }


        let urlPath = `/user-svc/self`;

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UserSvcSaveSelfRequestToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Save user\'s own profile information.
     * Save User Profile
     */
    async saveSelf(requestParameters: SaveSelfRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.saveSelfRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Save user information based on the provided user ID. Intended for admins. Requires the `user-svc:user:edit` permission. For a user to edit their own profile, see `saveSelf`.
     * Save User
     */
    async saveUserRaw(requestParameters: SaveUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters['userId'] == null) {
            throw new runtime.RequiredError(
                'userId',
                'Required parameter "userId" was null or undefined when calling saveUser().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling saveUser().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // BearerAuth authentication
        }


        let urlPath = `/user-svc/user/{userId}`;
        urlPath = urlPath.replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters['userId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UserSvcSaveUserRequestToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Save user information based on the provided user ID. Intended for admins. Requires the `user-svc:user:edit` permission. For a user to edit their own profile, see `saveSelf`.
     * Save User
     */
    async saveUser(requestParameters: SaveUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.saveUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
