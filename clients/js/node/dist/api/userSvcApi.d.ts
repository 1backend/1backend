/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import http from 'http';
import { UserSvcChangePasswordRequest } from '../model/userSvcChangePasswordRequest';
import { UserSvcCreateUserRequest } from '../model/userSvcCreateUserRequest';
import { UserSvcExchangeTokenRequest } from '../model/userSvcExchangeTokenRequest';
import { UserSvcExchangeTokenResponse } from '../model/userSvcExchangeTokenResponse';
import { UserSvcGetPublicKeyResponse } from '../model/userSvcGetPublicKeyResponse';
import { UserSvcHasPermissionResponse } from '../model/userSvcHasPermissionResponse';
import { UserSvcListEnrollsRequest } from '../model/userSvcListEnrollsRequest';
import { UserSvcListEnrollsResponse } from '../model/userSvcListEnrollsResponse';
import { UserSvcListOrganizationsRequest } from '../model/userSvcListOrganizationsRequest';
import { UserSvcListOrganizationsResponse } from '../model/userSvcListOrganizationsResponse';
import { UserSvcListPermissionsResponse } from '../model/userSvcListPermissionsResponse';
import { UserSvcListPermitsRequest } from '../model/userSvcListPermitsRequest';
import { UserSvcListPermitsResponse } from '../model/userSvcListPermitsResponse';
import { UserSvcListUsersRequest } from '../model/userSvcListUsersRequest';
import { UserSvcListUsersResponse } from '../model/userSvcListUsersResponse';
import { UserSvcLoginRequest } from '../model/userSvcLoginRequest';
import { UserSvcLoginResponse } from '../model/userSvcLoginResponse';
import { UserSvcReadSelfRequest } from '../model/userSvcReadSelfRequest';
import { UserSvcReadSelfResponse } from '../model/userSvcReadSelfResponse';
import { UserSvcRefreshTokenResponse } from '../model/userSvcRefreshTokenResponse';
import { UserSvcRegisterRequest } from '../model/userSvcRegisterRequest';
import { UserSvcRegisterResponse } from '../model/userSvcRegisterResponse';
import { UserSvcResetPasswordRequest } from '../model/userSvcResetPasswordRequest';
import { UserSvcRevokeTokensRequest } from '../model/userSvcRevokeTokensRequest';
import { UserSvcSaveEnrollsRequest } from '../model/userSvcSaveEnrollsRequest';
import { UserSvcSaveEnrollsResponse } from '../model/userSvcSaveEnrollsResponse';
import { UserSvcSaveOrganizationRequest } from '../model/userSvcSaveOrganizationRequest';
import { UserSvcSaveOrganizationResponse } from '../model/userSvcSaveOrganizationResponse';
import { UserSvcSavePermitsRequest } from '../model/userSvcSavePermitsRequest';
import { UserSvcSaveSelfRequest } from '../model/userSvcSaveSelfRequest';
import { UserSvcSaveUserRequest } from '../model/userSvcSaveUserRequest';
import { Authentication, Interceptor } from '../model/models';
import { ApiKeyAuth } from '../model/models';
export declare enum UserSvcApiApiKeys {
    BearerAuth = 0
}
export declare class UserSvcApi {
    protected _basePath: string;
    protected _defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected authentications: {
        default: Authentication;
        BearerAuth: ApiKeyAuth;
    };
    protected interceptors: Interceptor[];
    constructor(basePath?: string);
    set useQuerystring(value: boolean);
    set basePath(basePath: string);
    set defaultHeaders(defaultHeaders: any);
    get defaultHeaders(): any;
    get basePath(): string;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: UserSvcApiApiKeys, value: string): void;
    addInterceptor(interceptor: Interceptor): void;
    /**
     * Allows an authenticated user to change their own password.
     * @summary Change Password
     * @param userSvcChangePasswordRequest Change Password Request
     */
    changePassword(userSvcChangePasswordRequest: UserSvcChangePasswordRequest, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: object;
    }>;
    /**
     * Allows an authenticated administrator to create a new user with specified details.
     * @summary Create a New User
     * @param userSvcCreateUserRequest Create User Request
     */
    createUser(userSvcCreateUserRequest: UserSvcCreateUserRequest, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: object;
    }>;
    /**
     * Allows an organization admin to remove a user from an organization.
     * @summary Delete Membership
     * @param organizationId Organization ID
     * @param userId User ID
     * @param body Remove User From Organization Request
     */
    deleteMembership(organizationId: string, userId: string, body?: object, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: object;
    }>;
    /**
     * Delete a user based on the user ID.
     * @summary Delete a User
     * @param userId User ID
     * @param body
     */
    deleteUser(userId: string, body?: object, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: object;
    }>;
    /**
     * Exchange an existing token for a new token scoped to a different app (namespace). The new token represents the same user but contains roles specific to the target app.  The original token remains valid. The minted token is not stored and cannot be refreshed (and will have the same expiration duration as normal tokens), unlike tokens acquired via login.  For now, token exchange is designed to be in situ — the User Svc must be contacted at exchange time. This introduces a stateful dependency on the User Svc, but simplifies things until broader use cases emerge.
     * @summary Exchange Token
     * @param userSvcExchangeTokenRequest ExchangeToken Request
     */
    exchangeToken(userSvcExchangeTokenRequest: UserSvcExchangeTokenRequest, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: UserSvcExchangeTokenResponse;
    }>;
    /**
     * Exchange an existing token for a new token scoped to a different app (namespace). The new token represents the same user but contains roles specific to the target app.  The original token remains valid. The minted token is not stored and cannot be refreshed (and will have the same expiration duration as normal tokens), unlike tokens acquired via login.  For now, token exchange is designed to be in situ — the User Svc must be contacted at exchange time. This introduces a stateful dependency on the User Svc, but simplifies things until broader use cases emerge.
     * @summary Exchange Token
     * @param userSvcExchangeTokenRequest ExchangeToken Request
     */
    exchangeToken_1(userSvcExchangeTokenRequest: UserSvcExchangeTokenRequest, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: UserSvcExchangeTokenResponse;
    }>;
    /**
     * Get the public key to verify the JWT signature.
     * @summary Get Public Key
     * @param body
     */
    getPublicKey(body?: object, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: UserSvcGetPublicKeyResponse;
    }>;
    /**
     * Checks whether the caller has a specific permission. Optimized for caching — only the caller and the permission are required. To assign a permission to a user or role, use the `Save Permits` endpoint.  This endpoint does not return 401 Unauthorized if access is denied. Instead, it always returns 200 OK with `Authorized: false` if the permission is missing. The response will still include the caller’s user information if not authorized.
     * @summary Has Permission
     * @param permission Permission
     * @param body
     */
    hasPermission(permission: string, body?: object, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: UserSvcHasPermissionResponse;
    }>;
    /**
     * List enrolls. Role, user ID or contact ID must be specified.  Requires the `user-svc:enroll:view` permission, which by default all users have. Caller can only list enrolls of roles they own (unless they are an admin).
     * @summary List Enrolls
     * @param userSvcListEnrollsRequest List Enrolls Request
     */
    listEnrolls(userSvcListEnrollsRequest: UserSvcListEnrollsRequest, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: UserSvcListEnrollsResponse;
    }>;
    /**
     * Requires the `user-svc:organization:view` permission, that only admins have by default.
     * @summary List Organizations
     * @param userSvcListOrganizationsRequest List Organizations Request
     */
    listOrganizations(userSvcListOrganizationsRequest: UserSvcListOrganizationsRequest, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: UserSvcListOrganizationsResponse;
    }>;
    /**
     * List permissions by roles. Caller can only list permissions for roles they have.
     * @summary List Permissions
     * @param roleId Role ID
     * @param body
     */
    listPermissions(roleId: string, body?: object, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: UserSvcListPermissionsResponse;
    }>;
    /**
     * List permits. Requires the `user-svc:permit:view` permission, which only admins have by default. &todo Users should be able to list permits referring to them.
     * @summary List Permits
     * @param userSvcListPermitsRequest List Permits Request
     */
    listPermits(userSvcListPermitsRequest: UserSvcListPermitsRequest, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: UserSvcListPermitsResponse;
    }>;
    /**
     * Fetches a list of users with optional query filters and pagination. Requires the `user-svc:user:view` permission that only admins have by default.
     * @summary List Users
     * @param userSvcListUsersRequest List Users Request
     */
    listUsers(userSvcListUsersRequest?: UserSvcListUsersRequest, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: UserSvcListUsersResponse;
    }>;
    /**
     * Authenticates a user and returns a token.
     * @summary Login
     * @param userSvcLoginRequest Login Request
     */
    login(userSvcLoginRequest: UserSvcLoginRequest, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: UserSvcLoginResponse;
    }>;
    /**
     * Retrieves user information based on the authentication token in the request header. Typically called by single-page applications during the initial page load. While some details (such as roles, slug, user ID, and active organization ID) can be extracted from the JWT, this endpoint returns additional data, including the full user object and associated organizations.  ReadSelf intentionally still works after token revocation until the token expires. This is to ensure that the user is not notified of token revocation (though some information is leaked by the count token functionality @todo).
     * @summary Read Self
     * @param userSvcReadSelfRequest Read Self Request
     */
    readSelf(userSvcReadSelfRequest?: UserSvcReadSelfRequest, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: UserSvcReadSelfResponse;
    }>;
    /**
     * Refreshes an existing token, including inactive ones. The old token becomes inactive (if not already inactive), and a new, active token is issued. This allows continued verification of user roles without requiring a new login. Inactive tokens are refreshable unless explicitly revoked (no mechanism for this yet). Leaked tokens should be handled separately, via a revocation flag or deletion.
     * @summary Refresh Token
     * @param body
     */
    refreshToken(body?: object, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: UserSvcRefreshTokenResponse;
    }>;
    /**
     * Register a new user with a name, email, and password.
     * @summary Register
     * @param userSvcRegisterRequest Register Request
     */
    register(userSvcRegisterRequest: UserSvcRegisterRequest, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: UserSvcRegisterResponse;
    }>;
    /**
     * Allows an administrator to change a user\'s password.
     * @summary Reset Password
     * @param userId User ID
     * @param userSvcResetPasswordRequest Change Password Request
     */
    resetPassword(userId: string, userSvcResetPasswordRequest: UserSvcResetPasswordRequest, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: object;
    }>;
    /**
     * Revoke tokens in one of the following scenarios: - For the current user. - For another user (see `userId` field), if permitted (`user-svc:token:revoke` permission, typically by admins).
     * @summary Revoke Tokens
     * @param userSvcRevokeTokensRequest Revoke Tokens Request
     */
    revokeTokens(userSvcRevokeTokensRequest?: UserSvcRevokeTokensRequest, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: object;
    }>;
    /**
     * Enroll a list of users by contact or user Id to acquire a role. Works on future or current users.  Requires the `user-svc:enroll:edit` permission, which by default all users have. A user can only enroll an other user to a role if the user \"owns\" that role.  A user \"owns\" a role in the following cases: - A static role where the role ID is prefixed with the caller\'s slug. - Any dynamic or static role where the caller is an admin (has `*:admin` postfix of that role).  Examples: - A user with the slug `joe-doe` owns roles like `joe-doe:*` such as `joe-doe:any-custom-role`. - A user with any slug who has the role `my-service:admin` owns `my-service:*` roles such as `my-service:user`. - A user with any slug who has the role `user-svc:org:{%orgId}:admin` owns `user-svc:org:{%orgId}:*` such as `user-svc:org:{%orgId}:user`.
     * @summary Save Enrolls
     * @param userSvcSaveEnrollsRequest Save Enrolls Request
     */
    saveEnrolls(userSvcSaveEnrollsRequest: UserSvcSaveEnrollsRequest, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: UserSvcSaveEnrollsResponse;
    }>;
    /**
     * Allows an organization admin to add a user to the organization.
     * @summary Save Membership
     * @param organizationId Organization ID
     * @param userId User ID
     * @param body Add User to Organization Request
     */
    saveMembership(organizationId: string, userId: string, body?: object, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: object;
    }>;
    /**
     * Allows a logged-in user to save an organization. The user initiating the request will be assigned the role of admin for that organization. The initiating user will receive a dynamic role in the format `user-svc:org:{organizationId}:admin`, where `{organizationId}` is a unique identifier for the saved organization. Dynamic roles are generated based on specific user-resource associations (in this case the resource being the organization), offering more flexible permission management compared to static roles.
     * @summary Save an Organization
     * @param userSvcSaveOrganizationRequest Save User Request
     */
    saveOrganization(userSvcSaveOrganizationRequest: UserSvcSaveOrganizationRequest, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: UserSvcSaveOrganizationResponse;
    }>;
    /**
     * Save permits. Permits give access to users with certain slugs and roles to permissions.
     * @summary Save Permits
     * @param userSvcSavePermitsRequest Save Permits Request
     */
    savePermits(userSvcSavePermitsRequest: UserSvcSavePermitsRequest, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: object;
    }>;
    /**
     * Save user\'s own profile information.
     * @summary Save User Profile
     * @param userSvcSaveSelfRequest Save Profile Request
     */
    saveSelf(userSvcSaveSelfRequest: UserSvcSaveSelfRequest, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: object;
    }>;
    /**
     * Save user information based on the provided user ID. Intended for admins. Requires the `user-svc:user:edit` permission. For a user to edit their own profile, see `saveSelf`.
     * @summary Save User
     * @param userId User ID
     * @param userSvcSaveUserRequest Save Profile Request
     */
    saveUser(userId: string, userSvcSaveUserRequest: UserSvcSaveUserRequest, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: object;
    }>;
}
