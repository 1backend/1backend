import { __awaiter } from 'tslib';
import localVarRequest from 'request';

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ChatSvcEventMessageAdded {
    static getAttributeTypeMap() {
        return ChatSvcEventMessageAdded.attributeTypeMap;
    }
}
ChatSvcEventMessageAdded.discriminator = undefined;
ChatSvcEventMessageAdded.attributeTypeMap = [
    {
        "name": "threadId",
        "baseName": "threadId",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ChatSvcEventThreadAdded {
    static getAttributeTypeMap() {
        return ChatSvcEventThreadAdded.attributeTypeMap;
    }
}
ChatSvcEventThreadAdded.discriminator = undefined;
ChatSvcEventThreadAdded.attributeTypeMap = [
    {
        "name": "threadId",
        "baseName": "threadId",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ChatSvcEventThreadUpdate {
    static getAttributeTypeMap() {
        return ChatSvcEventThreadUpdate.attributeTypeMap;
    }
}
ChatSvcEventThreadUpdate.discriminator = undefined;
ChatSvcEventThreadUpdate.attributeTypeMap = [
    {
        "name": "threadId",
        "baseName": "threadId",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ChatSvcListMessagesRequest {
    static getAttributeTypeMap() {
        return ChatSvcListMessagesRequest.attributeTypeMap;
    }
}
ChatSvcListMessagesRequest.discriminator = undefined;
ChatSvcListMessagesRequest.attributeTypeMap = [
    {
        "name": "ids",
        "baseName": "ids",
        "type": "Array<string>"
    },
    {
        "name": "threadId",
        "baseName": "threadId",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ChatSvcListMessagesResponse {
    static getAttributeTypeMap() {
        return ChatSvcListMessagesResponse.attributeTypeMap;
    }
}
ChatSvcListMessagesResponse.discriminator = undefined;
ChatSvcListMessagesResponse.attributeTypeMap = [
    {
        "name": "messages",
        "baseName": "messages",
        "type": "Array<ChatSvcMessage>"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ChatSvcListThreadsRequest {
    static getAttributeTypeMap() {
        return ChatSvcListThreadsRequest.attributeTypeMap;
    }
}
ChatSvcListThreadsRequest.discriminator = undefined;
ChatSvcListThreadsRequest.attributeTypeMap = [
    {
        "name": "ids",
        "baseName": "ids",
        "type": "Array<string>"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ChatSvcListThreadsResponse {
    static getAttributeTypeMap() {
        return ChatSvcListThreadsResponse.attributeTypeMap;
    }
}
ChatSvcListThreadsResponse.discriminator = undefined;
ChatSvcListThreadsResponse.attributeTypeMap = [
    {
        "name": "threads",
        "baseName": "threads",
        "type": "Array<ChatSvcThread>"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
* Response message contains the response text and files. This field is populated only for synchronous prompts (`sync = true`). For asynchronous prompts, the response will provided in the associated message identified by the `responseMessageId` of the `promptSvc.prompt` object once the prompt completes.
*/
class ChatSvcMessage {
    static getAttributeTypeMap() {
        return ChatSvcMessage.attributeTypeMap;
    }
}
ChatSvcMessage.discriminator = undefined;
ChatSvcMessage.attributeTypeMap = [
    {
        "name": "createdAt",
        "baseName": "createdAt",
        "type": "string"
    },
    {
        "name": "fileIds",
        "baseName": "fileIds",
        "type": "Array<string>"
    },
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "meta",
        "baseName": "meta",
        "type": "{ [key: string]: any; }"
    },
    {
        "name": "text",
        "baseName": "text",
        "type": "string"
    },
    {
        "name": "threadId",
        "baseName": "threadId",
        "type": "string"
    },
    {
        "name": "updatedAt",
        "baseName": "updatedAt",
        "type": "string"
    },
    {
        "name": "userId",
        "baseName": "userId",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ChatSvcSaveMessageRequest {
    static getAttributeTypeMap() {
        return ChatSvcSaveMessageRequest.attributeTypeMap;
    }
}
ChatSvcSaveMessageRequest.discriminator = undefined;
ChatSvcSaveMessageRequest.attributeTypeMap = [
    {
        "name": "fileIds",
        "baseName": "fileIds",
        "type": "Array<string>"
    },
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "meta",
        "baseName": "meta",
        "type": "{ [key: string]: any; }"
    },
    {
        "name": "text",
        "baseName": "text",
        "type": "string"
    },
    {
        "name": "threadId",
        "baseName": "threadId",
        "type": "string"
    },
    {
        "name": "userId",
        "baseName": "userId",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ChatSvcSaveThreadRequest {
    static getAttributeTypeMap() {
        return ChatSvcSaveThreadRequest.attributeTypeMap;
    }
}
ChatSvcSaveThreadRequest.discriminator = undefined;
ChatSvcSaveThreadRequest.attributeTypeMap = [
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "title",
        "baseName": "title",
        "type": "string"
    },
    {
        "name": "topicIds",
        "baseName": "topicIds",
        "type": "Array<string>"
    },
    {
        "name": "userIds",
        "baseName": "userIds",
        "type": "Array<string>"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ChatSvcSaveThreadResponse {
    static getAttributeTypeMap() {
        return ChatSvcSaveThreadResponse.attributeTypeMap;
    }
}
ChatSvcSaveThreadResponse.discriminator = undefined;
ChatSvcSaveThreadResponse.attributeTypeMap = [
    {
        "name": "thread",
        "baseName": "thread",
        "type": "ChatSvcThread"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ChatSvcThread {
    static getAttributeTypeMap() {
        return ChatSvcThread.attributeTypeMap;
    }
}
ChatSvcThread.discriminator = undefined;
ChatSvcThread.attributeTypeMap = [
    {
        "name": "createdAt",
        "baseName": "createdAt",
        "type": "string"
    },
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "title",
        "baseName": "title",
        "type": "string"
    },
    {
        "name": "topicIds",
        "baseName": "topicIds",
        "type": "Array<string>"
    },
    {
        "name": "updatedAt",
        "baseName": "updatedAt",
        "type": "string"
    },
    {
        "name": "userIds",
        "baseName": "userIds",
        "type": "Array<string>"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ConfigSvcConfig {
    static getAttributeTypeMap() {
        return ConfigSvcConfig.attributeTypeMap;
    }
}
ConfigSvcConfig.discriminator = undefined;
ConfigSvcConfig.attributeTypeMap = [
    {
        "name": "app",
        "baseName": "app",
        "type": "string"
    },
    {
        "name": "createdAt",
        "baseName": "createdAt",
        "type": "string"
    },
    {
        "name": "data",
        "baseName": "data",
        "type": "{ [key: string]: any; }"
    },
    {
        "name": "dataJson",
        "baseName": "dataJson",
        "type": "string"
    },
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "key",
        "baseName": "key",
        "type": "string"
    },
    {
        "name": "updatedAt",
        "baseName": "updatedAt",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ConfigSvcListConfigsRequest {
    static getAttributeTypeMap() {
        return ConfigSvcListConfigsRequest.attributeTypeMap;
    }
}
ConfigSvcListConfigsRequest.discriminator = undefined;
ConfigSvcListConfigsRequest.attributeTypeMap = [
    {
        "name": "app",
        "baseName": "app",
        "type": "string"
    },
    {
        "name": "keys",
        "baseName": "keys",
        "type": "Array<string>"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ConfigSvcListConfigsResponse {
    static getAttributeTypeMap() {
        return ConfigSvcListConfigsResponse.attributeTypeMap;
    }
}
ConfigSvcListConfigsResponse.discriminator = undefined;
ConfigSvcListConfigsResponse.attributeTypeMap = [
    {
        "name": "configs",
        "baseName": "configs",
        "type": "{ [key: string]: ConfigSvcConfig; }"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ConfigSvcSaveConfigRequest {
    static getAttributeTypeMap() {
        return ConfigSvcSaveConfigRequest.attributeTypeMap;
    }
}
ConfigSvcSaveConfigRequest.discriminator = undefined;
ConfigSvcSaveConfigRequest.attributeTypeMap = [
    {
        "name": "app",
        "baseName": "app",
        "type": "string"
    },
    {
        "name": "data",
        "baseName": "data",
        "type": "{ [key: string]: any; }"
    },
    {
        "name": "dataJson",
        "baseName": "dataJson",
        "type": "string"
    },
    {
        "name": "key",
        "baseName": "key",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ContainerSvcAsset {
    static getAttributeTypeMap() {
        return ContainerSvcAsset.attributeTypeMap;
    }
}
ContainerSvcAsset.discriminator = undefined;
ContainerSvcAsset.attributeTypeMap = [
    {
        "name": "envVarKey",
        "baseName": "envVarKey",
        "type": "string"
    },
    {
        "name": "url",
        "baseName": "url",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ContainerSvcBuildImageRequest {
    static getAttributeTypeMap() {
        return ContainerSvcBuildImageRequest.attributeTypeMap;
    }
}
ContainerSvcBuildImageRequest.discriminator = undefined;
ContainerSvcBuildImageRequest.attributeTypeMap = [
    {
        "name": "contextPath",
        "baseName": "contextPath",
        "type": "string"
    },
    {
        "name": "dockerfilePath",
        "baseName": "dockerfilePath",
        "type": "string"
    },
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
* Capabilities define additional runtime features, such as GPU support.
*/
class ContainerSvcCapabilities {
    static getAttributeTypeMap() {
        return ContainerSvcCapabilities.attributeTypeMap;
    }
}
ContainerSvcCapabilities.discriminator = undefined;
ContainerSvcCapabilities.attributeTypeMap = [
    {
        "name": "gpuEnabled",
        "baseName": "gpuEnabled",
        "type": "boolean"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ContainerSvcContainer {
    static getAttributeTypeMap() {
        return ContainerSvcContainer.attributeTypeMap;
    }
}
ContainerSvcContainer.discriminator = undefined;
ContainerSvcContainer.attributeTypeMap = [
    {
        "name": "assets",
        "baseName": "assets",
        "type": "Array<ContainerSvcAsset>"
    },
    {
        "name": "capabilities",
        "baseName": "capabilities",
        "type": "ContainerSvcCapabilities"
    },
    {
        "name": "envs",
        "baseName": "envs",
        "type": "Array<ContainerSvcEnvVar>"
    },
    {
        "name": "hash",
        "baseName": "hash",
        "type": "string"
    },
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "image",
        "baseName": "image",
        "type": "string"
    },
    {
        "name": "keeps",
        "baseName": "keeps",
        "type": "Array<ContainerSvcKeep>"
    },
    {
        "name": "labels",
        "baseName": "labels",
        "type": "Array<ContainerSvcLabel>"
    },
    {
        "name": "names",
        "baseName": "names",
        "type": "Array<string>"
    },
    {
        "name": "network",
        "baseName": "network",
        "type": "ContainerSvcNetwork"
    },
    {
        "name": "nodeId",
        "baseName": "nodeId",
        "type": "string"
    },
    {
        "name": "ports",
        "baseName": "ports",
        "type": "Array<ContainerSvcPortMapping>"
    },
    {
        "name": "resources",
        "baseName": "resources",
        "type": "ContainerSvcResources"
    },
    {
        "name": "runtime",
        "baseName": "runtime",
        "type": "string"
    },
    {
        "name": "status",
        "baseName": "status",
        "type": "string"
    },
    {
        "name": "volumes",
        "baseName": "volumes",
        "type": "Array<ContainerSvcVolume>"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ContainerSvcContainerIsRunningResponse {
    static getAttributeTypeMap() {
        return ContainerSvcContainerIsRunningResponse.attributeTypeMap;
    }
}
ContainerSvcContainerIsRunningResponse.discriminator = undefined;
ContainerSvcContainerIsRunningResponse.attributeTypeMap = [
    {
        "name": "isRunning",
        "baseName": "isRunning",
        "type": "boolean"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ContainerSvcDaemonInfoResponse {
    static getAttributeTypeMap() {
        return ContainerSvcDaemonInfoResponse.attributeTypeMap;
    }
}
ContainerSvcDaemonInfoResponse.discriminator = undefined;
ContainerSvcDaemonInfoResponse.attributeTypeMap = [
    {
        "name": "address",
        "baseName": "address",
        "type": "string"
    },
    {
        "name": "available",
        "baseName": "available",
        "type": "boolean"
    },
    {
        "name": "error",
        "baseName": "error",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ContainerSvcEnvVar {
    static getAttributeTypeMap() {
        return ContainerSvcEnvVar.attributeTypeMap;
    }
}
ContainerSvcEnvVar.discriminator = undefined;
ContainerSvcEnvVar.attributeTypeMap = [
    {
        "name": "key",
        "baseName": "key",
        "type": "string"
    },
    {
        "name": "value",
        "baseName": "value",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ContainerSvcErrorResponse {
    static getAttributeTypeMap() {
        return ContainerSvcErrorResponse.attributeTypeMap;
    }
}
ContainerSvcErrorResponse.discriminator = undefined;
ContainerSvcErrorResponse.attributeTypeMap = [
    {
        "name": "error",
        "baseName": "error",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ContainerSvcGetContainerSummaryResponse {
    static getAttributeTypeMap() {
        return ContainerSvcGetContainerSummaryResponse.attributeTypeMap;
    }
}
ContainerSvcGetContainerSummaryResponse.discriminator = undefined;
ContainerSvcGetContainerSummaryResponse.attributeTypeMap = [
    {
        "name": "logs",
        "baseName": "logs",
        "type": "string"
    },
    {
        "name": "status",
        "baseName": "status",
        "type": "string"
    },
    {
        "name": "summary",
        "baseName": "summary",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ContainerSvcGetHostResponse {
    static getAttributeTypeMap() {
        return ContainerSvcGetHostResponse.attributeTypeMap;
    }
}
ContainerSvcGetHostResponse.discriminator = undefined;
ContainerSvcGetHostResponse.attributeTypeMap = [
    {
        "name": "host",
        "baseName": "host",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ContainerSvcImagePullableResponse {
    static getAttributeTypeMap() {
        return ContainerSvcImagePullableResponse.attributeTypeMap;
    }
}
ContainerSvcImagePullableResponse.discriminator = undefined;
ContainerSvcImagePullableResponse.attributeTypeMap = [
    {
        "name": "pullable",
        "baseName": "pullable",
        "type": "boolean"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ContainerSvcKeep {
    static getAttributeTypeMap() {
        return ContainerSvcKeep.attributeTypeMap;
    }
}
ContainerSvcKeep.discriminator = undefined;
ContainerSvcKeep.attributeTypeMap = [
    {
        "name": "path",
        "baseName": "path",
        "type": "string"
    },
    {
        "name": "readOnly",
        "baseName": "readOnly",
        "type": "boolean"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ContainerSvcLabel {
    static getAttributeTypeMap() {
        return ContainerSvcLabel.attributeTypeMap;
    }
}
ContainerSvcLabel.discriminator = undefined;
ContainerSvcLabel.attributeTypeMap = [
    {
        "name": "key",
        "baseName": "key",
        "type": "string"
    },
    {
        "name": "value",
        "baseName": "value",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ContainerSvcListContainersRequest {
    static getAttributeTypeMap() {
        return ContainerSvcListContainersRequest.attributeTypeMap;
    }
}
ContainerSvcListContainersRequest.discriminator = undefined;
ContainerSvcListContainersRequest.attributeTypeMap = [
    {
        "name": "containerId",
        "baseName": "containerId",
        "type": "string"
    },
    {
        "name": "limit",
        "baseName": "limit",
        "type": "number"
    },
    {
        "name": "nodeId",
        "baseName": "nodeId",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ContainerSvcListContainersResponse {
    static getAttributeTypeMap() {
        return ContainerSvcListContainersResponse.attributeTypeMap;
    }
}
ContainerSvcListContainersResponse.discriminator = undefined;
ContainerSvcListContainersResponse.attributeTypeMap = [
    {
        "name": "containers",
        "baseName": "containers",
        "type": "Array<ContainerSvcContainer>"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ContainerSvcListLogsRequest {
    static getAttributeTypeMap() {
        return ContainerSvcListLogsRequest.attributeTypeMap;
    }
}
ContainerSvcListLogsRequest.discriminator = undefined;
ContainerSvcListLogsRequest.attributeTypeMap = [
    {
        "name": "containerId",
        "baseName": "containerId",
        "type": "string"
    },
    {
        "name": "limit",
        "baseName": "limit",
        "type": "number"
    },
    {
        "name": "nodeId",
        "baseName": "nodeId",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ContainerSvcListLogsResponse {
    static getAttributeTypeMap() {
        return ContainerSvcListLogsResponse.attributeTypeMap;
    }
}
ContainerSvcListLogsResponse.discriminator = undefined;
ContainerSvcListLogsResponse.attributeTypeMap = [
    {
        "name": "logs",
        "baseName": "logs",
        "type": "Array<ContainerSvcLog>"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ContainerSvcLog {
    static getAttributeTypeMap() {
        return ContainerSvcLog.attributeTypeMap;
    }
}
ContainerSvcLog.discriminator = undefined;
ContainerSvcLog.attributeTypeMap = [
    {
        "name": "containerId",
        "baseName": "containerId",
        "type": "string"
    },
    {
        "name": "content",
        "baseName": "content",
        "type": "string"
    },
    {
        "name": "createdAt",
        "baseName": "createdAt",
        "type": "string"
    },
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "nodeId",
        "baseName": "nodeId",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
* Network contains networking-related information for the container.
*/
class ContainerSvcNetwork {
    static getAttributeTypeMap() {
        return ContainerSvcNetwork.attributeTypeMap;
    }
}
ContainerSvcNetwork.discriminator = undefined;
ContainerSvcNetwork.attributeTypeMap = [
    {
        "name": "ipAddress",
        "baseName": "ipAddress",
        "type": "string"
    },
    {
        "name": "macAddress",
        "baseName": "macAddress",
        "type": "string"
    },
    {
        "name": "mode",
        "baseName": "mode",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ContainerSvcPortMapping {
    static getAttributeTypeMap() {
        return ContainerSvcPortMapping.attributeTypeMap;
    }
}
ContainerSvcPortMapping.discriminator = undefined;
ContainerSvcPortMapping.attributeTypeMap = [
    {
        "name": "host",
        "baseName": "host",
        "type": "number"
    },
    {
        "name": "internal",
        "baseName": "internal",
        "type": "number"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
* Resources defines CPU, memory, and disk constraints for the container.
*/
class ContainerSvcResources {
    static getAttributeTypeMap() {
        return ContainerSvcResources.attributeTypeMap;
    }
}
ContainerSvcResources.discriminator = undefined;
ContainerSvcResources.attributeTypeMap = [
    {
        "name": "cpu",
        "baseName": "cpu",
        "type": "number"
    },
    {
        "name": "diskMB",
        "baseName": "diskMB",
        "type": "number"
    },
    {
        "name": "memoryMB",
        "baseName": "memoryMB",
        "type": "number"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ContainerSvcRunContainerRequest {
    static getAttributeTypeMap() {
        return ContainerSvcRunContainerRequest.attributeTypeMap;
    }
}
ContainerSvcRunContainerRequest.discriminator = undefined;
ContainerSvcRunContainerRequest.attributeTypeMap = [
    {
        "name": "assets",
        "baseName": "assets",
        "type": "Array<ContainerSvcAsset>"
    },
    {
        "name": "capabilities",
        "baseName": "capabilities",
        "type": "ContainerSvcCapabilities"
    },
    {
        "name": "envs",
        "baseName": "envs",
        "type": "Array<ContainerSvcEnvVar>"
    },
    {
        "name": "hash",
        "baseName": "hash",
        "type": "string"
    },
    {
        "name": "image",
        "baseName": "image",
        "type": "string"
    },
    {
        "name": "keeps",
        "baseName": "keeps",
        "type": "Array<ContainerSvcKeep>"
    },
    {
        "name": "labels",
        "baseName": "labels",
        "type": "Array<ContainerSvcLabel>"
    },
    {
        "name": "names",
        "baseName": "names",
        "type": "Array<string>"
    },
    {
        "name": "ports",
        "baseName": "ports",
        "type": "Array<ContainerSvcPortMapping>"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ContainerSvcRunContainerResponse {
    static getAttributeTypeMap() {
        return ContainerSvcRunContainerResponse.attributeTypeMap;
    }
}
ContainerSvcRunContainerResponse.discriminator = undefined;
ContainerSvcRunContainerResponse.attributeTypeMap = [
    {
        "name": "ports",
        "baseName": "ports",
        "type": "Array<ContainerSvcPortMapping>"
    },
    {
        "name": "started",
        "baseName": "started",
        "type": "boolean"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ContainerSvcStopContainerRequest {
    static getAttributeTypeMap() {
        return ContainerSvcStopContainerRequest.attributeTypeMap;
    }
}
ContainerSvcStopContainerRequest.discriminator = undefined;
ContainerSvcStopContainerRequest.attributeTypeMap = [
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ContainerSvcVolume {
    static getAttributeTypeMap() {
        return ContainerSvcVolume.attributeTypeMap;
    }
}
ContainerSvcVolume.discriminator = undefined;
ContainerSvcVolume.attributeTypeMap = [
    {
        "name": "destination",
        "baseName": "destination",
        "type": "string"
    },
    {
        "name": "readOnly",
        "baseName": "readOnly",
        "type": "boolean"
    },
    {
        "name": "source",
        "baseName": "source",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class DataSvcCreateObjectFields {
    static getAttributeTypeMap() {
        return DataSvcCreateObjectFields.attributeTypeMap;
    }
}
DataSvcCreateObjectFields.discriminator = undefined;
DataSvcCreateObjectFields.attributeTypeMap = [
    {
        "name": "authors",
        "baseName": "authors",
        "type": "Array<string>"
    },
    {
        "name": "data",
        "baseName": "data",
        "type": "{ [key: string]: any; }"
    },
    {
        "name": "deleters",
        "baseName": "deleters",
        "type": "Array<string>"
    },
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "readers",
        "baseName": "readers",
        "type": "Array<string>"
    },
    {
        "name": "table",
        "baseName": "table",
        "type": "string"
    },
    {
        "name": "writers",
        "baseName": "writers",
        "type": "Array<string>"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class DataSvcCreateObjectRequest {
    static getAttributeTypeMap() {
        return DataSvcCreateObjectRequest.attributeTypeMap;
    }
}
DataSvcCreateObjectRequest.discriminator = undefined;
DataSvcCreateObjectRequest.attributeTypeMap = [
    {
        "name": "object",
        "baseName": "object",
        "type": "DataSvcCreateObjectFields"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class DataSvcCreateObjectResponse {
    static getAttributeTypeMap() {
        return DataSvcCreateObjectResponse.attributeTypeMap;
    }
}
DataSvcCreateObjectResponse.discriminator = undefined;
DataSvcCreateObjectResponse.attributeTypeMap = [
    {
        "name": "object",
        "baseName": "object",
        "type": "DataSvcObject"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class DataSvcDeleteObjectRequest {
    static getAttributeTypeMap() {
        return DataSvcDeleteObjectRequest.attributeTypeMap;
    }
}
DataSvcDeleteObjectRequest.discriminator = undefined;
DataSvcDeleteObjectRequest.attributeTypeMap = [
    {
        "name": "filters",
        "baseName": "filters",
        "type": "Array<DatastoreFilter>"
    },
    {
        "name": "table",
        "baseName": "table",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class DataSvcErrorResponse {
    static getAttributeTypeMap() {
        return DataSvcErrorResponse.attributeTypeMap;
    }
}
DataSvcErrorResponse.discriminator = undefined;
DataSvcErrorResponse.attributeTypeMap = [
    {
        "name": "error",
        "baseName": "error",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
* The object containing the fields to update in matching objects.
*/
class DataSvcObject {
    static getAttributeTypeMap() {
        return DataSvcObject.attributeTypeMap;
    }
}
DataSvcObject.discriminator = undefined;
DataSvcObject.attributeTypeMap = [
    {
        "name": "authors",
        "baseName": "authors",
        "type": "Array<string>"
    },
    {
        "name": "createdAt",
        "baseName": "createdAt",
        "type": "string"
    },
    {
        "name": "data",
        "baseName": "data",
        "type": "{ [key: string]: any; }"
    },
    {
        "name": "deleters",
        "baseName": "deleters",
        "type": "Array<string>"
    },
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "readers",
        "baseName": "readers",
        "type": "Array<string>"
    },
    {
        "name": "table",
        "baseName": "table",
        "type": "string"
    },
    {
        "name": "updatedAt",
        "baseName": "updatedAt",
        "type": "string"
    },
    {
        "name": "writers",
        "baseName": "writers",
        "type": "Array<string>"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class DataSvcQueryRequest {
    static getAttributeTypeMap() {
        return DataSvcQueryRequest.attributeTypeMap;
    }
}
DataSvcQueryRequest.discriminator = undefined;
DataSvcQueryRequest.attributeTypeMap = [
    {
        "name": "query",
        "baseName": "query",
        "type": "DatastoreQuery"
    },
    {
        "name": "readers",
        "baseName": "readers",
        "type": "Array<string>"
    },
    {
        "name": "table",
        "baseName": "table",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class DataSvcQueryResponse {
    static getAttributeTypeMap() {
        return DataSvcQueryResponse.attributeTypeMap;
    }
}
DataSvcQueryResponse.discriminator = undefined;
DataSvcQueryResponse.attributeTypeMap = [
    {
        "name": "objects",
        "baseName": "objects",
        "type": "Array<DataSvcObject>"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class DataSvcUpdateObjectsRequest {
    static getAttributeTypeMap() {
        return DataSvcUpdateObjectsRequest.attributeTypeMap;
    }
}
DataSvcUpdateObjectsRequest.discriminator = undefined;
DataSvcUpdateObjectsRequest.attributeTypeMap = [
    {
        "name": "filters",
        "baseName": "filters",
        "type": "Array<DatastoreFilter>"
    },
    {
        "name": "object",
        "baseName": "object",
        "type": "DataSvcObject"
    },
    {
        "name": "table",
        "baseName": "table",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class DataSvcUpsertObjectRequest {
    static getAttributeTypeMap() {
        return DataSvcUpsertObjectRequest.attributeTypeMap;
    }
}
DataSvcUpsertObjectRequest.discriminator = undefined;
DataSvcUpsertObjectRequest.attributeTypeMap = [
    {
        "name": "object",
        "baseName": "object",
        "type": "DataSvcCreateObjectFields"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class DataSvcUpsertObjectResponse {
    static getAttributeTypeMap() {
        return DataSvcUpsertObjectResponse.attributeTypeMap;
    }
}
DataSvcUpsertObjectResponse.discriminator = undefined;
DataSvcUpsertObjectResponse.attributeTypeMap = [
    {
        "name": "object",
        "baseName": "object",
        "type": "DataSvcObject"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class DatastoreFilter {
    static getAttributeTypeMap() {
        return DatastoreFilter.attributeTypeMap;
    }
}
DatastoreFilter.discriminator = undefined;
DatastoreFilter.attributeTypeMap = [
    {
        "name": "fields",
        "baseName": "fields",
        "type": "Array<string>"
    },
    {
        "name": "op",
        "baseName": "op",
        "type": "string"
    },
    {
        "name": "subFilters",
        "baseName": "subFilters",
        "type": "Array<DatastoreFilter>"
    },
    {
        "name": "values",
        "baseName": "values",
        "type": "Array<any>"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class DatastoreOrderBy {
    static getAttributeTypeMap() {
        return DatastoreOrderBy.attributeTypeMap;
    }
}
DatastoreOrderBy.discriminator = undefined;
DatastoreOrderBy.attributeTypeMap = [
    {
        "name": "desc",
        "baseName": "desc",
        "type": "boolean"
    },
    {
        "name": "field",
        "baseName": "field",
        "type": "string"
    },
    {
        "name": "sortingType",
        "baseName": "sortingType",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class DatastoreQuery {
    static getAttributeTypeMap() {
        return DatastoreQuery.attributeTypeMap;
    }
}
DatastoreQuery.discriminator = undefined;
DatastoreQuery.attributeTypeMap = [
    {
        "name": "after",
        "baseName": "after",
        "type": "Array<any>"
    },
    {
        "name": "count",
        "baseName": "count",
        "type": "boolean"
    },
    {
        "name": "filters",
        "baseName": "filters",
        "type": "Array<DatastoreFilter>"
    },
    {
        "name": "limit",
        "baseName": "limit",
        "type": "number"
    },
    {
        "name": "orderBys",
        "baseName": "orderBys",
        "type": "Array<DatastoreOrderBy>"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
* Optional: Auto-scaling rules
*/
class DeploySvcAutoScalingConfig {
    static getAttributeTypeMap() {
        return DeploySvcAutoScalingConfig.attributeTypeMap;
    }
}
DeploySvcAutoScalingConfig.discriminator = undefined;
DeploySvcAutoScalingConfig.attributeTypeMap = [
    {
        "name": "cpuThreshold",
        "baseName": "cpuThreshold",
        "type": "number"
    },
    {
        "name": "maxReplicas",
        "baseName": "maxReplicas",
        "type": "number"
    },
    {
        "name": "minReplicas",
        "baseName": "minReplicas",
        "type": "number"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class DeploySvcDeleteDeploymentRequest {
    static getAttributeTypeMap() {
        return DeploySvcDeleteDeploymentRequest.attributeTypeMap;
    }
}
DeploySvcDeleteDeploymentRequest.discriminator = undefined;
DeploySvcDeleteDeploymentRequest.attributeTypeMap = [
    {
        "name": "deploymentId",
        "baseName": "deploymentId",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class DeploySvcDeployment {
    static getAttributeTypeMap() {
        return DeploySvcDeployment.attributeTypeMap;
    }
}
DeploySvcDeployment.discriminator = undefined;
DeploySvcDeployment.attributeTypeMap = [
    {
        "name": "autoScaling",
        "baseName": "autoScaling",
        "type": "DeploySvcAutoScalingConfig"
    },
    {
        "name": "definitionId",
        "baseName": "definitionId",
        "type": "string"
    },
    {
        "name": "description",
        "baseName": "description",
        "type": "string"
    },
    {
        "name": "details",
        "baseName": "details",
        "type": "string"
    },
    {
        "name": "envars",
        "baseName": "envars",
        "type": "{ [key: string]: string; }"
    },
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "replicas",
        "baseName": "replicas",
        "type": "number"
    },
    {
        "name": "resources",
        "baseName": "resources",
        "type": "DeploySvcResourceLimits"
    },
    {
        "name": "status",
        "baseName": "status",
        "type": "string"
    },
    {
        "name": "strategy",
        "baseName": "strategy",
        "type": "DeploySvcDeploymentStrategy"
    },
    {
        "name": "targetRegions",
        "baseName": "targetRegions",
        "type": "Array<DeploySvcTargetRegion>"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
* Deployment strategy (e.g., rolling update)
*/
class DeploySvcDeploymentStrategy {
    static getAttributeTypeMap() {
        return DeploySvcDeploymentStrategy.attributeTypeMap;
    }
}
DeploySvcDeploymentStrategy.discriminator = undefined;
DeploySvcDeploymentStrategy.attributeTypeMap = [
    {
        "name": "maxSurge",
        "baseName": "maxSurge",
        "type": "number"
    },
    {
        "name": "maxUnavailable",
        "baseName": "maxUnavailable",
        "type": "number"
    },
    {
        "name": "type",
        "baseName": "type",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class DeploySvcErrorResponse {
    static getAttributeTypeMap() {
        return DeploySvcErrorResponse.attributeTypeMap;
    }
}
DeploySvcErrorResponse.discriminator = undefined;
DeploySvcErrorResponse.attributeTypeMap = [
    {
        "name": "error",
        "baseName": "error",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class DeploySvcListDeploymentsResponse {
    static getAttributeTypeMap() {
        return DeploySvcListDeploymentsResponse.attributeTypeMap;
    }
}
DeploySvcListDeploymentsResponse.discriminator = undefined;
DeploySvcListDeploymentsResponse.attributeTypeMap = [
    {
        "name": "deployments",
        "baseName": "deployments",
        "type": "Array<DeploySvcDeployment>"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
* Resource requirements for each replica
*/
class DeploySvcResourceLimits {
    static getAttributeTypeMap() {
        return DeploySvcResourceLimits.attributeTypeMap;
    }
}
DeploySvcResourceLimits.discriminator = undefined;
DeploySvcResourceLimits.attributeTypeMap = [
    {
        "name": "cpu",
        "baseName": "cpu",
        "type": "string"
    },
    {
        "name": "memory",
        "baseName": "memory",
        "type": "string"
    },
    {
        "name": "vram",
        "baseName": "vram",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class DeploySvcSaveDeploymentRequest {
    static getAttributeTypeMap() {
        return DeploySvcSaveDeploymentRequest.attributeTypeMap;
    }
}
DeploySvcSaveDeploymentRequest.discriminator = undefined;
DeploySvcSaveDeploymentRequest.attributeTypeMap = [
    {
        "name": "deployment",
        "baseName": "deployment",
        "type": "DeploySvcDeployment"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class DeploySvcTargetRegion {
    static getAttributeTypeMap() {
        return DeploySvcTargetRegion.attributeTypeMap;
    }
}
DeploySvcTargetRegion.discriminator = undefined;
DeploySvcTargetRegion.attributeTypeMap = [
    {
        "name": "cluster",
        "baseName": "cluster",
        "type": "string"
    },
    {
        "name": "zone",
        "baseName": "zone",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class EmailSvcAttachment {
    static getAttributeTypeMap() {
        return EmailSvcAttachment.attributeTypeMap;
    }
}
EmailSvcAttachment.discriminator = undefined;
EmailSvcAttachment.attributeTypeMap = [
    {
        "name": "content",
        "baseName": "content",
        "type": "string"
    },
    {
        "name": "contentType",
        "baseName": "contentType",
        "type": "string"
    },
    {
        "name": "fileId",
        "baseName": "fileId",
        "type": "string"
    },
    {
        "name": "filename",
        "baseName": "filename",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class EmailSvcErrorResponse {
    static getAttributeTypeMap() {
        return EmailSvcErrorResponse.attributeTypeMap;
    }
}
EmailSvcErrorResponse.discriminator = undefined;
EmailSvcErrorResponse.attributeTypeMap = [
    {
        "name": "error",
        "baseName": "error",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class EmailSvcSendEmailRequest {
    static getAttributeTypeMap() {
        return EmailSvcSendEmailRequest.attributeTypeMap;
    }
}
EmailSvcSendEmailRequest.discriminator = undefined;
EmailSvcSendEmailRequest.attributeTypeMap = [
    {
        "name": "attachments",
        "baseName": "attachments",
        "type": "Array<EmailSvcAttachment>"
    },
    {
        "name": "bcc",
        "baseName": "bcc",
        "type": "Array<string>"
    },
    {
        "name": "body",
        "baseName": "body",
        "type": "string"
    },
    {
        "name": "cc",
        "baseName": "cc",
        "type": "Array<string>"
    },
    {
        "name": "contentType",
        "baseName": "contentType",
        "type": "string"
    },
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "subject",
        "baseName": "subject",
        "type": "string"
    },
    {
        "name": "to",
        "baseName": "to",
        "type": "Array<string>"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class EmailSvcSendEmailResponse {
    static getAttributeTypeMap() {
        return EmailSvcSendEmailResponse.attributeTypeMap;
    }
}
EmailSvcSendEmailResponse.discriminator = undefined;
EmailSvcSendEmailResponse.attributeTypeMap = [
    {
        "name": "emailId",
        "baseName": "emailId",
        "type": "string"
    },
    {
        "name": "status",
        "baseName": "status",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class Events200Response {
    static getAttributeTypeMap() {
        return Events200Response.attributeTypeMap;
    }
}
Events200Response.discriminator = undefined;
Events200Response.attributeTypeMap = [
    {
        "name": "threadId",
        "baseName": "threadId",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class FileSvcDownload {
    static getAttributeTypeMap() {
        return FileSvcDownload.attributeTypeMap;
    }
}
FileSvcDownload.discriminator = undefined;
FileSvcDownload.attributeTypeMap = [
    {
        "name": "createdAt",
        "baseName": "createdAt",
        "type": "string"
    },
    {
        "name": "downloadedBytes",
        "baseName": "downloadedBytes",
        "type": "number"
    },
    {
        "name": "error",
        "baseName": "error",
        "type": "string"
    },
    {
        "name": "fileName",
        "baseName": "fileName",
        "type": "string"
    },
    {
        "name": "filePath",
        "baseName": "filePath",
        "type": "string"
    },
    {
        "name": "fileSize",
        "baseName": "fileSize",
        "type": "number"
    },
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "progress",
        "baseName": "progress",
        "type": "number"
    },
    {
        "name": "status",
        "baseName": "status",
        "type": "string"
    },
    {
        "name": "updatedAt",
        "baseName": "updatedAt",
        "type": "string"
    },
    {
        "name": "url",
        "baseName": "url",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class FileSvcDownloadFileRequest {
    static getAttributeTypeMap() {
        return FileSvcDownloadFileRequest.attributeTypeMap;
    }
}
FileSvcDownloadFileRequest.discriminator = undefined;
FileSvcDownloadFileRequest.attributeTypeMap = [
    {
        "name": "folderPath",
        "baseName": "folderPath",
        "type": "string"
    },
    {
        "name": "url",
        "baseName": "url",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class FileSvcDownloadsResponse {
    static getAttributeTypeMap() {
        return FileSvcDownloadsResponse.attributeTypeMap;
    }
}
FileSvcDownloadsResponse.discriminator = undefined;
FileSvcDownloadsResponse.attributeTypeMap = [
    {
        "name": "downloads",
        "baseName": "downloads",
        "type": "Array<FileSvcDownload>"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class FileSvcErrorResponse {
    static getAttributeTypeMap() {
        return FileSvcErrorResponse.attributeTypeMap;
    }
}
FileSvcErrorResponse.discriminator = undefined;
FileSvcErrorResponse.attributeTypeMap = [
    {
        "name": "error",
        "baseName": "error",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class FileSvcGetDownloadResponse {
    static getAttributeTypeMap() {
        return FileSvcGetDownloadResponse.attributeTypeMap;
    }
}
FileSvcGetDownloadResponse.discriminator = undefined;
FileSvcGetDownloadResponse.attributeTypeMap = [
    {
        "name": "download",
        "baseName": "download",
        "type": "FileSvcDownload"
    },
    {
        "name": "exists",
        "baseName": "exists",
        "type": "boolean"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class FileSvcListUploadsRequest {
    static getAttributeTypeMap() {
        return FileSvcListUploadsRequest.attributeTypeMap;
    }
}
FileSvcListUploadsRequest.discriminator = undefined;
FileSvcListUploadsRequest.attributeTypeMap = [
    {
        "name": "after",
        "baseName": "after",
        "type": "string"
    },
    {
        "name": "limit",
        "baseName": "limit",
        "type": "number"
    },
    {
        "name": "userId",
        "baseName": "userId",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class FileSvcListUploadsResponse {
    static getAttributeTypeMap() {
        return FileSvcListUploadsResponse.attributeTypeMap;
    }
}
FileSvcListUploadsResponse.discriminator = undefined;
FileSvcListUploadsResponse.attributeTypeMap = [
    {
        "name": "uploads",
        "baseName": "uploads",
        "type": "Array<FileSvcUpload>"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class FileSvcUpload {
    static getAttributeTypeMap() {
        return FileSvcUpload.attributeTypeMap;
    }
}
FileSvcUpload.discriminator = undefined;
FileSvcUpload.attributeTypeMap = [
    {
        "name": "createdAt",
        "baseName": "createdAt",
        "type": "string"
    },
    {
        "name": "fileId",
        "baseName": "fileId",
        "type": "string"
    },
    {
        "name": "fileName",
        "baseName": "fileName",
        "type": "string"
    },
    {
        "name": "filePath",
        "baseName": "filePath",
        "type": "string"
    },
    {
        "name": "fileSize",
        "baseName": "fileSize",
        "type": "number"
    },
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "nodeId",
        "baseName": "nodeId",
        "type": "string"
    },
    {
        "name": "updatedAt",
        "baseName": "updatedAt",
        "type": "string"
    },
    {
        "name": "userId",
        "baseName": "userId",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class FileSvcUploadFileResponse {
    static getAttributeTypeMap() {
        return FileSvcUploadFileResponse.attributeTypeMap;
    }
}
FileSvcUploadFileResponse.discriminator = undefined;
FileSvcUploadFileResponse.attributeTypeMap = [
    {
        "name": "upload",
        "baseName": "upload",
        "type": "FileSvcUpload"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class FirehoseSvcErrorResponse {
    static getAttributeTypeMap() {
        return FirehoseSvcErrorResponse.attributeTypeMap;
    }
}
FirehoseSvcErrorResponse.discriminator = undefined;
FirehoseSvcErrorResponse.attributeTypeMap = [
    {
        "name": "error",
        "baseName": "error",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class FirehoseSvcEvent {
    static getAttributeTypeMap() {
        return FirehoseSvcEvent.attributeTypeMap;
    }
}
FirehoseSvcEvent.discriminator = undefined;
FirehoseSvcEvent.attributeTypeMap = [
    {
        "name": "data",
        "baseName": "data",
        "type": "any"
    },
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class FirehoseSvcEventPublishRequest {
    static getAttributeTypeMap() {
        return FirehoseSvcEventPublishRequest.attributeTypeMap;
    }
}
FirehoseSvcEventPublishRequest.discriminator = undefined;
FirehoseSvcEventPublishRequest.attributeTypeMap = [
    {
        "name": "event",
        "baseName": "event",
        "type": "FirehoseSvcEvent"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ImageSvcErrorResponse {
    static getAttributeTypeMap() {
        return ImageSvcErrorResponse.attributeTypeMap;
    }
}
ImageSvcErrorResponse.discriminator = undefined;
ImageSvcErrorResponse.attributeTypeMap = [
    {
        "name": "error",
        "baseName": "error",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ModelSvcArchitectures {
    static getAttributeTypeMap() {
        return ModelSvcArchitectures.attributeTypeMap;
    }
}
ModelSvcArchitectures.discriminator = undefined;
ModelSvcArchitectures.attributeTypeMap = [
    {
        "name": "cuda",
        "baseName": "cuda",
        "type": "ModelSvcCudaParameters"
    },
    {
        "name": "_default",
        "baseName": "default",
        "type": "ModelSvcDefaultParameters"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ModelSvcAsset {
    static getAttributeTypeMap() {
        return ModelSvcAsset.attributeTypeMap;
    }
}
ModelSvcAsset.discriminator = undefined;
ModelSvcAsset.attributeTypeMap = [
    {
        "name": "envVarKey",
        "baseName": "envVarKey",
        "type": "string"
    },
    {
        "name": "url",
        "baseName": "url",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
* Container configuration related to CUDA usage.
*/
class ModelSvcContainer {
    static getAttributeTypeMap() {
        return ModelSvcContainer.attributeTypeMap;
    }
}
ModelSvcContainer.discriminator = undefined;
ModelSvcContainer.attributeTypeMap = [
    {
        "name": "envars",
        "baseName": "envars",
        "type": "Array<ModelSvcEnvVar>"
    },
    {
        "name": "imageTemplate",
        "baseName": "imageTemplate",
        "type": "string"
    },
    {
        "name": "keeps",
        "baseName": "keeps",
        "type": "Array<ModelSvcKeep>"
    },
    {
        "name": "port",
        "baseName": "port",
        "type": "number"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
* CUDA-specific container parameters, if applicable.
*/
class ModelSvcCudaParameters {
    static getAttributeTypeMap() {
        return ModelSvcCudaParameters.attributeTypeMap;
    }
}
ModelSvcCudaParameters.discriminator = undefined;
ModelSvcCudaParameters.attributeTypeMap = [
    {
        "name": "container",
        "baseName": "container",
        "type": "ModelSvcContainer"
    },
    {
        "name": "cudaVersionPrecision",
        "baseName": "cudaVersionPrecision",
        "type": "number"
    },
    {
        "name": "defaultCudaVersion",
        "baseName": "defaultCudaVersion",
        "type": "string"
    },
    {
        "name": "defaultCudnnVersion",
        "baseName": "defaultCudnnVersion",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
* Default container configuration for non-GPU environments.
*/
class ModelSvcDefaultParameters {
    static getAttributeTypeMap() {
        return ModelSvcDefaultParameters.attributeTypeMap;
    }
}
ModelSvcDefaultParameters.discriminator = undefined;
ModelSvcDefaultParameters.attributeTypeMap = [
    {
        "name": "container",
        "baseName": "container",
        "type": "ModelSvcContainer"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ModelSvcEnvVar {
    static getAttributeTypeMap() {
        return ModelSvcEnvVar.attributeTypeMap;
    }
}
ModelSvcEnvVar.discriminator = undefined;
ModelSvcEnvVar.attributeTypeMap = [
    {
        "name": "key",
        "baseName": "key",
        "type": "string"
    },
    {
        "name": "value",
        "baseName": "value",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ModelSvcErrorResponse {
    static getAttributeTypeMap() {
        return ModelSvcErrorResponse.attributeTypeMap;
    }
}
ModelSvcErrorResponse.discriminator = undefined;
ModelSvcErrorResponse.attributeTypeMap = [
    {
        "name": "error",
        "baseName": "error",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ModelSvcGetModelResponse {
    static getAttributeTypeMap() {
        return ModelSvcGetModelResponse.attributeTypeMap;
    }
}
ModelSvcGetModelResponse.discriminator = undefined;
ModelSvcGetModelResponse.attributeTypeMap = [
    {
        "name": "exists",
        "baseName": "exists",
        "type": "boolean"
    },
    {
        "name": "model",
        "baseName": "model",
        "type": "ModelSvcModel"
    },
    {
        "name": "platform",
        "baseName": "platform",
        "type": "ModelSvcPlatform"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ModelSvcKeep {
    static getAttributeTypeMap() {
        return ModelSvcKeep.attributeTypeMap;
    }
}
ModelSvcKeep.discriminator = undefined;
ModelSvcKeep.attributeTypeMap = [
    {
        "name": "path",
        "baseName": "path",
        "type": "string"
    },
    {
        "name": "readOnly",
        "baseName": "readOnly",
        "type": "boolean"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ModelSvcListModelsResponse {
    static getAttributeTypeMap() {
        return ModelSvcListModelsResponse.attributeTypeMap;
    }
}
ModelSvcListModelsResponse.discriminator = undefined;
ModelSvcListModelsResponse.attributeTypeMap = [
    {
        "name": "models",
        "baseName": "models",
        "type": "Array<ModelSvcModel>"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ModelSvcListPlatformsResponse {
    static getAttributeTypeMap() {
        return ModelSvcListPlatformsResponse.attributeTypeMap;
    }
}
ModelSvcListPlatformsResponse.discriminator = undefined;
ModelSvcListPlatformsResponse.attributeTypeMap = [
    {
        "name": "platforms",
        "baseName": "platforms",
        "type": "Array<ModelSvcPlatform>"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ModelSvcModel {
    static getAttributeTypeMap() {
        return ModelSvcModel.attributeTypeMap;
    }
}
ModelSvcModel.discriminator = undefined;
ModelSvcModel.attributeTypeMap = [
    {
        "name": "assets",
        "baseName": "assets",
        "type": "Array<ModelSvcAsset>"
    },
    {
        "name": "bits",
        "baseName": "bits",
        "type": "number"
    },
    {
        "name": "description",
        "baseName": "description",
        "type": "string"
    },
    {
        "name": "extension",
        "baseName": "extension",
        "type": "string"
    },
    {
        "name": "flavour",
        "baseName": "flavour",
        "type": "string"
    },
    {
        "name": "fullName",
        "baseName": "fullName",
        "type": "string"
    },
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "maxBits",
        "baseName": "maxBits",
        "type": "number"
    },
    {
        "name": "maxRam",
        "baseName": "maxRam",
        "type": "number"
    },
    {
        "name": "mirrors",
        "baseName": "mirrors",
        "type": "Array<string>"
    },
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "parameters",
        "baseName": "parameters",
        "type": "string"
    },
    {
        "name": "platformId",
        "baseName": "platformId",
        "type": "string"
    },
    {
        "name": "promptTemplate",
        "baseName": "promptTemplate",
        "type": "string"
    },
    {
        "name": "quality",
        "baseName": "quality",
        "type": "string"
    },
    {
        "name": "quantComment",
        "baseName": "quantComment",
        "type": "string"
    },
    {
        "name": "size",
        "baseName": "size",
        "type": "number"
    },
    {
        "name": "tags",
        "baseName": "tags",
        "type": "Array<string>"
    },
    {
        "name": "uncensored",
        "baseName": "uncensored",
        "type": "boolean"
    },
    {
        "name": "version",
        "baseName": "version",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ModelSvcModelStatus {
    static getAttributeTypeMap() {
        return ModelSvcModelStatus.attributeTypeMap;
    }
}
ModelSvcModelStatus.discriminator = undefined;
ModelSvcModelStatus.attributeTypeMap = [
    {
        "name": "address",
        "baseName": "address",
        "type": "string"
    },
    {
        "name": "assetsReady",
        "baseName": "assetsReady",
        "type": "boolean"
    },
    {
        "name": "running",
        "baseName": "running",
        "type": "boolean"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ModelSvcPlatform {
    static getAttributeTypeMap() {
        return ModelSvcPlatform.attributeTypeMap;
    }
}
ModelSvcPlatform.discriminator = undefined;
ModelSvcPlatform.attributeTypeMap = [
    {
        "name": "architectures",
        "baseName": "architectures",
        "type": "ModelSvcArchitectures"
    },
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "types",
        "baseName": "types",
        "type": "Array<string>"
    },
    {
        "name": "version",
        "baseName": "version",
        "type": "number"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ModelSvcStatusResponse {
    static getAttributeTypeMap() {
        return ModelSvcStatusResponse.attributeTypeMap;
    }
}
ModelSvcStatusResponse.discriminator = undefined;
ModelSvcStatusResponse.attributeTypeMap = [
    {
        "name": "status",
        "baseName": "status",
        "type": "ModelSvcModelStatus"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class PolicySvcBlocklistParameters {
    static getAttributeTypeMap() {
        return PolicySvcBlocklistParameters.attributeTypeMap;
    }
}
PolicySvcBlocklistParameters.discriminator = undefined;
PolicySvcBlocklistParameters.attributeTypeMap = [
    {
        "name": "blockedIPs",
        "baseName": "blockedIPs",
        "type": "Array<string>"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class PolicySvcCheckRequest {
    static getAttributeTypeMap() {
        return PolicySvcCheckRequest.attributeTypeMap;
    }
}
PolicySvcCheckRequest.discriminator = undefined;
PolicySvcCheckRequest.attributeTypeMap = [
    {
        "name": "endpoint",
        "baseName": "endpoint",
        "type": "string"
    },
    {
        "name": "ip",
        "baseName": "ip",
        "type": "string"
    },
    {
        "name": "method",
        "baseName": "method",
        "type": "string"
    },
    {
        "name": "userId",
        "baseName": "userId",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class PolicySvcCheckResponse {
    static getAttributeTypeMap() {
        return PolicySvcCheckResponse.attributeTypeMap;
    }
}
PolicySvcCheckResponse.discriminator = undefined;
PolicySvcCheckResponse.attributeTypeMap = [
    {
        "name": "allowed",
        "baseName": "allowed",
        "type": "boolean"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class PolicySvcErrorResponse {
    static getAttributeTypeMap() {
        return PolicySvcErrorResponse.attributeTypeMap;
    }
}
PolicySvcErrorResponse.discriminator = undefined;
PolicySvcErrorResponse.attributeTypeMap = [
    {
        "name": "error",
        "baseName": "error",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class PolicySvcInstance {
    static getAttributeTypeMap() {
        return PolicySvcInstance.attributeTypeMap;
    }
}
PolicySvcInstance.discriminator = undefined;
PolicySvcInstance.attributeTypeMap = [
    {
        "name": "endpoint",
        "baseName": "endpoint",
        "type": "string"
    },
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "parameters",
        "baseName": "parameters",
        "type": "PolicySvcParameters"
    },
    {
        "name": "templateId",
        "baseName": "templateId",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class PolicySvcParameters {
    static getAttributeTypeMap() {
        return PolicySvcParameters.attributeTypeMap;
    }
}
PolicySvcParameters.discriminator = undefined;
PolicySvcParameters.attributeTypeMap = [
    {
        "name": "blocklist",
        "baseName": "blocklist",
        "type": "PolicySvcBlocklistParameters"
    },
    {
        "name": "rateLimit",
        "baseName": "rateLimit",
        "type": "PolicySvcRateLimitParameters"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class PolicySvcRateLimitParameters {
    static getAttributeTypeMap() {
        return PolicySvcRateLimitParameters.attributeTypeMap;
    }
}
PolicySvcRateLimitParameters.discriminator = undefined;
PolicySvcRateLimitParameters.attributeTypeMap = [
    {
        "name": "entity",
        "baseName": "entity",
        "type": "string"
    },
    {
        "name": "maxRequests",
        "baseName": "maxRequests",
        "type": "number"
    },
    {
        "name": "scope",
        "baseName": "scope",
        "type": "string"
    },
    {
        "name": "timeWindow",
        "baseName": "timeWindow",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class PolicySvcUpsertInstanceRequest {
    static getAttributeTypeMap() {
        return PolicySvcUpsertInstanceRequest.attributeTypeMap;
    }
}
PolicySvcUpsertInstanceRequest.discriminator = undefined;
PolicySvcUpsertInstanceRequest.attributeTypeMap = [
    {
        "name": "instance",
        "baseName": "instance",
        "type": "PolicySvcInstance"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
* AI engine/platform (eg. Llama, Stable Diffusion) specific parameters
*/
class PromptSvcEngineParameters {
    static getAttributeTypeMap() {
        return PromptSvcEngineParameters.attributeTypeMap;
    }
}
PromptSvcEngineParameters.discriminator = undefined;
PromptSvcEngineParameters.attributeTypeMap = [
    {
        "name": "llamaCppParameters",
        "baseName": "llamaCppParameters",
        "type": "PromptSvcLlamaCppParameters"
    },
    {
        "name": "stableDiffusion",
        "baseName": "stableDiffusion",
        "type": "PromptSvcStableDiffusionParameters"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class PromptSvcErrorResponse {
    static getAttributeTypeMap() {
        return PromptSvcErrorResponse.attributeTypeMap;
    }
}
PromptSvcErrorResponse.discriminator = undefined;
PromptSvcErrorResponse.attributeTypeMap = [
    {
        "name": "error",
        "baseName": "error",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class PromptSvcListPromptsRequest {
    static getAttributeTypeMap() {
        return PromptSvcListPromptsRequest.attributeTypeMap;
    }
}
PromptSvcListPromptsRequest.discriminator = undefined;
PromptSvcListPromptsRequest.attributeTypeMap = [
    {
        "name": "query",
        "baseName": "query",
        "type": "DatastoreQuery"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class PromptSvcListPromptsResponse {
    static getAttributeTypeMap() {
        return PromptSvcListPromptsResponse.attributeTypeMap;
    }
}
PromptSvcListPromptsResponse.discriminator = undefined;
PromptSvcListPromptsResponse.attributeTypeMap = [
    {
        "name": "after",
        "baseName": "after",
        "type": "any"
    },
    {
        "name": "count",
        "baseName": "count",
        "type": "number"
    },
    {
        "name": "prompts",
        "baseName": "prompts",
        "type": "Array<PromptSvcPrompt>"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class PromptSvcLlamaCppParameters {
    static getAttributeTypeMap() {
        return PromptSvcLlamaCppParameters.attributeTypeMap;
    }
}
PromptSvcLlamaCppParameters.discriminator = undefined;
PromptSvcLlamaCppParameters.attributeTypeMap = [
    {
        "name": "template",
        "baseName": "template",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
* AI engine/platform (eg. Llama, Stable Diffusion) agnostic parameters. Use these high level parameters when you don\'t care about the actual engine, only the functionality (eg. text to image, image to image) it provides.
*/
class PromptSvcParameters {
    static getAttributeTypeMap() {
        return PromptSvcParameters.attributeTypeMap;
    }
}
PromptSvcParameters.discriminator = undefined;
PromptSvcParameters.attributeTypeMap = [
    {
        "name": "textToImage",
        "baseName": "textToImage",
        "type": "PromptSvcTextToImageParameters"
    },
    {
        "name": "textToText",
        "baseName": "textToText",
        "type": "PromptSvcTextToTextParameters"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
* Prompt contains the details of the prompt that was just created by this request. This includes the ID, prompt text, status, and other associated metadata.
*/
class PromptSvcPrompt {
    static getAttributeTypeMap() {
        return PromptSvcPrompt.attributeTypeMap;
    }
}
PromptSvcPrompt.discriminator = undefined;
PromptSvcPrompt.attributeTypeMap = [
    {
        "name": "createdAt",
        "baseName": "createdAt",
        "type": "string"
    },
    {
        "name": "engineParameters",
        "baseName": "engineParameters",
        "type": "PromptSvcEngineParameters"
    },
    {
        "name": "error",
        "baseName": "error",
        "type": "string"
    },
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "lastRun",
        "baseName": "lastRun",
        "type": "string"
    },
    {
        "name": "maxRetries",
        "baseName": "maxRetries",
        "type": "number"
    },
    {
        "name": "modelId",
        "baseName": "modelId",
        "type": "string"
    },
    {
        "name": "parameters",
        "baseName": "parameters",
        "type": "PromptSvcParameters"
    },
    {
        "name": "prompt",
        "baseName": "prompt",
        "type": "string"
    },
    {
        "name": "requestMessageId",
        "baseName": "requestMessageId",
        "type": "string"
    },
    {
        "name": "responseMessageId",
        "baseName": "responseMessageId",
        "type": "string"
    },
    {
        "name": "runCount",
        "baseName": "runCount",
        "type": "number"
    },
    {
        "name": "status",
        "baseName": "status",
        "type": "string"
    },
    {
        "name": "sync",
        "baseName": "sync",
        "type": "boolean"
    },
    {
        "name": "threadId",
        "baseName": "threadId",
        "type": "string"
    },
    {
        "name": "type",
        "baseName": "type",
        "type": "string"
    },
    {
        "name": "updatedAt",
        "baseName": "updatedAt",
        "type": "string"
    },
    {
        "name": "userId",
        "baseName": "userId",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class PromptSvcPromptRequest {
    static getAttributeTypeMap() {
        return PromptSvcPromptRequest.attributeTypeMap;
    }
}
PromptSvcPromptRequest.discriminator = undefined;
PromptSvcPromptRequest.attributeTypeMap = [
    {
        "name": "engineParameters",
        "baseName": "engineParameters",
        "type": "PromptSvcEngineParameters"
    },
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "maxRetries",
        "baseName": "maxRetries",
        "type": "number"
    },
    {
        "name": "modelId",
        "baseName": "modelId",
        "type": "string"
    },
    {
        "name": "parameters",
        "baseName": "parameters",
        "type": "PromptSvcParameters"
    },
    {
        "name": "prompt",
        "baseName": "prompt",
        "type": "string"
    },
    {
        "name": "sync",
        "baseName": "sync",
        "type": "boolean"
    },
    {
        "name": "threadId",
        "baseName": "threadId",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class PromptSvcPromptResponse {
    static getAttributeTypeMap() {
        return PromptSvcPromptResponse.attributeTypeMap;
    }
}
PromptSvcPromptResponse.discriminator = undefined;
PromptSvcPromptResponse.attributeTypeMap = [
    {
        "name": "prompt",
        "baseName": "prompt",
        "type": "PromptSvcPrompt"
    },
    {
        "name": "responseMessage",
        "baseName": "responseMessage",
        "type": "ChatSvcMessage"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class PromptSvcRemovePromptRequest {
    static getAttributeTypeMap() {
        return PromptSvcRemovePromptRequest.attributeTypeMap;
    }
}
PromptSvcRemovePromptRequest.discriminator = undefined;
PromptSvcRemovePromptRequest.attributeTypeMap = [
    {
        "name": "promptId",
        "baseName": "promptId",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class PromptSvcStableDiffusionParameters {
    static getAttributeTypeMap() {
        return PromptSvcStableDiffusionParameters.attributeTypeMap;
    }
}
PromptSvcStableDiffusionParameters.discriminator = undefined;
PromptSvcStableDiffusionParameters.attributeTypeMap = [
    {
        "name": "txt2Img",
        "baseName": "txt2Img",
        "type": "StableDiffusionTxt2ImgRequest"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class PromptSvcStreamChunk {
    static getAttributeTypeMap() {
        return PromptSvcStreamChunk.attributeTypeMap;
    }
}
PromptSvcStreamChunk.discriminator = undefined;
PromptSvcStreamChunk.attributeTypeMap = [
    {
        "name": "messageId",
        "baseName": "messageId",
        "type": "string"
    },
    {
        "name": "text",
        "baseName": "text",
        "type": "string"
    },
    {
        "name": "type",
        "baseName": "type",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class PromptSvcTextToImageParameters {
    static getAttributeTypeMap() {
        return PromptSvcTextToImageParameters.attributeTypeMap;
    }
}
PromptSvcTextToImageParameters.discriminator = undefined;
PromptSvcTextToImageParameters.attributeTypeMap = [
    {
        "name": "aspectRatio",
        "baseName": "aspectRatio",
        "type": "string"
    },
    {
        "name": "batchSize",
        "baseName": "batchSize",
        "type": "number"
    },
    {
        "name": "denoisingStrength",
        "baseName": "denoisingStrength",
        "type": "number"
    },
    {
        "name": "enableUpscaling",
        "baseName": "enableUpscaling",
        "type": "boolean"
    },
    {
        "name": "format",
        "baseName": "format",
        "type": "string"
    },
    {
        "name": "guidanceScale",
        "baseName": "guidanceScale",
        "type": "number"
    },
    {
        "name": "height",
        "baseName": "height",
        "type": "number"
    },
    {
        "name": "negativePrompt",
        "baseName": "negativePrompt",
        "type": "string"
    },
    {
        "name": "numIterations",
        "baseName": "numIterations",
        "type": "number"
    },
    {
        "name": "prompt",
        "baseName": "prompt",
        "type": "string"
    },
    {
        "name": "qualityPreset",
        "baseName": "qualityPreset",
        "type": "string"
    },
    {
        "name": "restoreFaces",
        "baseName": "restoreFaces",
        "type": "boolean"
    },
    {
        "name": "scheduler",
        "baseName": "scheduler",
        "type": "string"
    },
    {
        "name": "seed",
        "baseName": "seed",
        "type": "number"
    },
    {
        "name": "steps",
        "baseName": "steps",
        "type": "number"
    },
    {
        "name": "styles",
        "baseName": "styles",
        "type": "Array<string>"
    },
    {
        "name": "width",
        "baseName": "width",
        "type": "number"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class PromptSvcTextToTextParameters {
    static getAttributeTypeMap() {
        return PromptSvcTextToTextParameters.attributeTypeMap;
    }
}
PromptSvcTextToTextParameters.discriminator = undefined;
PromptSvcTextToTextParameters.attributeTypeMap = [
    {
        "name": "template",
        "baseName": "template",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class PromptSvcTypesResponse {
    static getAttributeTypeMap() {
        return PromptSvcTypesResponse.attributeTypeMap;
    }
}
PromptSvcTypesResponse.discriminator = undefined;
PromptSvcTypesResponse.attributeTypeMap = [
    {
        "name": "chunk",
        "baseName": "chunk",
        "type": "PromptSvcStreamChunk"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ProxySvcCert {
    static getAttributeTypeMap() {
        return ProxySvcCert.attributeTypeMap;
    }
}
ProxySvcCert.discriminator = undefined;
ProxySvcCert.attributeTypeMap = [
    {
        "name": "cert",
        "baseName": "cert",
        "type": "string"
    },
    {
        "name": "commonName",
        "baseName": "commonName",
        "type": "string"
    },
    {
        "name": "createdAt",
        "baseName": "createdAt",
        "type": "string"
    },
    {
        "name": "dnsNames",
        "baseName": "dnsNames",
        "type": "Array<string>"
    },
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "isCA",
        "baseName": "isCA",
        "type": "boolean"
    },
    {
        "name": "issuer",
        "baseName": "issuer",
        "type": "string"
    },
    {
        "name": "notAfter",
        "baseName": "notAfter",
        "type": "string"
    },
    {
        "name": "notBefore",
        "baseName": "notBefore",
        "type": "string"
    },
    {
        "name": "publicKeyAlgorithm",
        "baseName": "publicKeyAlgorithm",
        "type": "string"
    },
    {
        "name": "publicKeyBitLength",
        "baseName": "publicKeyBitLength",
        "type": "number"
    },
    {
        "name": "serialNumber",
        "baseName": "serialNumber",
        "type": "string"
    },
    {
        "name": "signatureAlgorithm",
        "baseName": "signatureAlgorithm",
        "type": "string"
    },
    {
        "name": "updatedAt",
        "baseName": "updatedAt",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ProxySvcCertInput {
    static getAttributeTypeMap() {
        return ProxySvcCertInput.attributeTypeMap;
    }
}
ProxySvcCertInput.discriminator = undefined;
ProxySvcCertInput.attributeTypeMap = [
    {
        "name": "cert",
        "baseName": "cert",
        "type": "string"
    },
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ProxySvcErrorResponse {
    static getAttributeTypeMap() {
        return ProxySvcErrorResponse.attributeTypeMap;
    }
}
ProxySvcErrorResponse.discriminator = undefined;
ProxySvcErrorResponse.attributeTypeMap = [
    {
        "name": "error",
        "baseName": "error",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ProxySvcListCertsRequest {
    static getAttributeTypeMap() {
        return ProxySvcListCertsRequest.attributeTypeMap;
    }
}
ProxySvcListCertsRequest.discriminator = undefined;
ProxySvcListCertsRequest.attributeTypeMap = [
    {
        "name": "ids",
        "baseName": "ids",
        "type": "Array<string>"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ProxySvcListCertsResponse {
    static getAttributeTypeMap() {
        return ProxySvcListCertsResponse.attributeTypeMap;
    }
}
ProxySvcListCertsResponse.discriminator = undefined;
ProxySvcListCertsResponse.attributeTypeMap = [
    {
        "name": "certs",
        "baseName": "certs",
        "type": "Array<ProxySvcCert>"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ProxySvcListRoutesRequest {
    static getAttributeTypeMap() {
        return ProxySvcListRoutesRequest.attributeTypeMap;
    }
}
ProxySvcListRoutesRequest.discriminator = undefined;
ProxySvcListRoutesRequest.attributeTypeMap = [
    {
        "name": "ids",
        "baseName": "ids",
        "type": "Array<string>"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ProxySvcListRoutesResponse {
    static getAttributeTypeMap() {
        return ProxySvcListRoutesResponse.attributeTypeMap;
    }
}
ProxySvcListRoutesResponse.discriminator = undefined;
ProxySvcListRoutesResponse.attributeTypeMap = [
    {
        "name": "routes",
        "baseName": "routes",
        "type": "Array<ProxySvcRoute>"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ProxySvcRoute {
    static getAttributeTypeMap() {
        return ProxySvcRoute.attributeTypeMap;
    }
}
ProxySvcRoute.discriminator = undefined;
ProxySvcRoute.attributeTypeMap = [
    {
        "name": "createdAt",
        "baseName": "createdAt",
        "type": "string"
    },
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "target",
        "baseName": "target",
        "type": "string"
    },
    {
        "name": "updatedAt",
        "baseName": "updatedAt",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ProxySvcRouteInput {
    static getAttributeTypeMap() {
        return ProxySvcRouteInput.attributeTypeMap;
    }
}
ProxySvcRouteInput.discriminator = undefined;
ProxySvcRouteInput.attributeTypeMap = [
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "target",
        "baseName": "target",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ProxySvcSaveCertsRequest {
    static getAttributeTypeMap() {
        return ProxySvcSaveCertsRequest.attributeTypeMap;
    }
}
ProxySvcSaveCertsRequest.discriminator = undefined;
ProxySvcSaveCertsRequest.attributeTypeMap = [
    {
        "name": "certs",
        "baseName": "certs",
        "type": "Array<ProxySvcCertInput>"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ProxySvcSaveRoutesRequest {
    static getAttributeTypeMap() {
        return ProxySvcSaveRoutesRequest.attributeTypeMap;
    }
}
ProxySvcSaveRoutesRequest.discriminator = undefined;
ProxySvcSaveRoutesRequest.attributeTypeMap = [
    {
        "name": "routes",
        "baseName": "routes",
        "type": "Array<ProxySvcRouteInput>"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ProxySvcSaveRoutesResponse {
    static getAttributeTypeMap() {
        return ProxySvcSaveRoutesResponse.attributeTypeMap;
    }
}
ProxySvcSaveRoutesResponse.discriminator = undefined;
ProxySvcSaveRoutesResponse.attributeTypeMap = [
    {
        "name": "routes",
        "baseName": "routes",
        "type": "Array<ProxySvcRoute>"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class RegistrySvcAPISpec {
    static getAttributeTypeMap() {
        return RegistrySvcAPISpec.attributeTypeMap;
    }
}
RegistrySvcAPISpec.discriminator = undefined;
RegistrySvcAPISpec.attributeTypeMap = [
    {
        "name": "metadata",
        "baseName": "metadata",
        "type": "{ [key: string]: string; }"
    },
    {
        "name": "protocolType",
        "baseName": "protocolType",
        "type": "string"
    },
    {
        "name": "url",
        "baseName": "url",
        "type": "string"
    },
    {
        "name": "version",
        "baseName": "version",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class RegistrySvcClient {
    static getAttributeTypeMap() {
        return RegistrySvcClient.attributeTypeMap;
    }
}
RegistrySvcClient.discriminator = undefined;
RegistrySvcClient.attributeTypeMap = [
    {
        "name": "language",
        "baseName": "language",
        "type": "string"
    },
    {
        "name": "url",
        "baseName": "url",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class RegistrySvcDefinition {
    static getAttributeTypeMap() {
        return RegistrySvcDefinition.attributeTypeMap;
    }
}
RegistrySvcDefinition.discriminator = undefined;
RegistrySvcDefinition.attributeTypeMap = [
    {
        "name": "apiSpecs",
        "baseName": "apiSpecs",
        "type": "Array<RegistrySvcAPISpec>"
    },
    {
        "name": "clients",
        "baseName": "clients",
        "type": "Array<RegistrySvcClient>"
    },
    {
        "name": "envars",
        "baseName": "envars",
        "type": "Array<RegistrySvcEnvVar>"
    },
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "image",
        "baseName": "image",
        "type": "RegistrySvcImageSpec"
    },
    {
        "name": "ports",
        "baseName": "ports",
        "type": "Array<RegistrySvcPortMapping>"
    },
    {
        "name": "repository",
        "baseName": "repository",
        "type": "RegistrySvcRepositorySpec"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class RegistrySvcEnvVar {
    static getAttributeTypeMap() {
        return RegistrySvcEnvVar.attributeTypeMap;
    }
}
RegistrySvcEnvVar.discriminator = undefined;
RegistrySvcEnvVar.attributeTypeMap = [
    {
        "name": "key",
        "baseName": "key",
        "type": "string"
    },
    {
        "name": "value",
        "baseName": "value",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class RegistrySvcErrorResponse {
    static getAttributeTypeMap() {
        return RegistrySvcErrorResponse.attributeTypeMap;
    }
}
RegistrySvcErrorResponse.discriminator = undefined;
RegistrySvcErrorResponse.attributeTypeMap = [
    {
        "name": "error",
        "baseName": "error",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class RegistrySvcGPU {
    static getAttributeTypeMap() {
        return RegistrySvcGPU.attributeTypeMap;
    }
}
RegistrySvcGPU.discriminator = undefined;
RegistrySvcGPU.attributeTypeMap = [
    {
        "name": "busId",
        "baseName": "busId",
        "type": "string"
    },
    {
        "name": "computeMode",
        "baseName": "computeMode",
        "type": "string"
    },
    {
        "name": "cudaVersion",
        "baseName": "cudaVersion",
        "type": "string"
    },
    {
        "name": "gpuUtilization",
        "baseName": "gpuUtilization",
        "type": "number"
    },
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "intraNodeId",
        "baseName": "intraNodeId",
        "type": "number"
    },
    {
        "name": "memoryTotal",
        "baseName": "memoryTotal",
        "type": "number"
    },
    {
        "name": "memoryUsage",
        "baseName": "memoryUsage",
        "type": "number"
    },
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "performanceState",
        "baseName": "performanceState",
        "type": "string"
    },
    {
        "name": "powerCap",
        "baseName": "powerCap",
        "type": "number"
    },
    {
        "name": "powerUsage",
        "baseName": "powerUsage",
        "type": "number"
    },
    {
        "name": "processDetails",
        "baseName": "processDetails",
        "type": "Array<RegistrySvcProcess>"
    },
    {
        "name": "temperature",
        "baseName": "temperature",
        "type": "number"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
* Container specifications for Docker, K8s, etc. Use this to deploy already built images.
*/
class RegistrySvcImageSpec {
    static getAttributeTypeMap() {
        return RegistrySvcImageSpec.attributeTypeMap;
    }
}
RegistrySvcImageSpec.discriminator = undefined;
RegistrySvcImageSpec.attributeTypeMap = [
    {
        "name": "internalPorts",
        "baseName": "internalPorts",
        "type": "Array<number>"
    },
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class RegistrySvcInstance {
    static getAttributeTypeMap() {
        return RegistrySvcInstance.attributeTypeMap;
    }
}
RegistrySvcInstance.discriminator = undefined;
RegistrySvcInstance.attributeTypeMap = [
    {
        "name": "deploymentId",
        "baseName": "deploymentId",
        "type": "string"
    },
    {
        "name": "details",
        "baseName": "details",
        "type": "string"
    },
    {
        "name": "host",
        "baseName": "host",
        "type": "string"
    },
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "ip",
        "baseName": "ip",
        "type": "string"
    },
    {
        "name": "lastHeartbeat",
        "baseName": "lastHeartbeat",
        "type": "string"
    },
    {
        "name": "nodeUrl",
        "baseName": "nodeUrl",
        "type": "string"
    },
    {
        "name": "path",
        "baseName": "path",
        "type": "string"
    },
    {
        "name": "port",
        "baseName": "port",
        "type": "number"
    },
    {
        "name": "scheme",
        "baseName": "scheme",
        "type": "string"
    },
    {
        "name": "slug",
        "baseName": "slug",
        "type": "string"
    },
    {
        "name": "status",
        "baseName": "status",
        "type": "string"
    },
    {
        "name": "tags",
        "baseName": "tags",
        "type": "Array<string>"
    },
    {
        "name": "url",
        "baseName": "url",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class RegistrySvcListDefinitionsResponse {
    static getAttributeTypeMap() {
        return RegistrySvcListDefinitionsResponse.attributeTypeMap;
    }
}
RegistrySvcListDefinitionsResponse.discriminator = undefined;
RegistrySvcListDefinitionsResponse.attributeTypeMap = [
    {
        "name": "definitions",
        "baseName": "definitions",
        "type": "Array<RegistrySvcDefinition>"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class RegistrySvcListInstancesResponse {
    static getAttributeTypeMap() {
        return RegistrySvcListInstancesResponse.attributeTypeMap;
    }
}
RegistrySvcListInstancesResponse.discriminator = undefined;
RegistrySvcListInstancesResponse.attributeTypeMap = [
    {
        "name": "instances",
        "baseName": "instances",
        "type": "Array<RegistrySvcInstance>"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class RegistrySvcListNodesRequest {
    static getAttributeTypeMap() {
        return RegistrySvcListNodesRequest.attributeTypeMap;
    }
}
RegistrySvcListNodesRequest.discriminator = undefined;
RegistrySvcListNodesRequest.attributeTypeMap = [
    {
        "name": "ids",
        "baseName": "ids",
        "type": "Array<string>"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class RegistrySvcListNodesResponse {
    static getAttributeTypeMap() {
        return RegistrySvcListNodesResponse.attributeTypeMap;
    }
}
RegistrySvcListNodesResponse.discriminator = undefined;
RegistrySvcListNodesResponse.attributeTypeMap = [
    {
        "name": "nodes",
        "baseName": "nodes",
        "type": "Array<RegistrySvcNode>"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class RegistrySvcNode {
    static getAttributeTypeMap() {
        return RegistrySvcNode.attributeTypeMap;
    }
}
RegistrySvcNode.discriminator = undefined;
RegistrySvcNode.attributeTypeMap = [
    {
        "name": "availabilityZone",
        "baseName": "availabilityZone",
        "type": "string"
    },
    {
        "name": "gpus",
        "baseName": "gpus",
        "type": "Array<RegistrySvcGPU>"
    },
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "lastHeartbeat",
        "baseName": "lastHeartbeat",
        "type": "string"
    },
    {
        "name": "region",
        "baseName": "region",
        "type": "string"
    },
    {
        "name": "url",
        "baseName": "url",
        "type": "string"
    },
    {
        "name": "usage",
        "baseName": "usage",
        "type": "RegistrySvcResourceUsage"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class RegistrySvcNodeSelfResponse {
    static getAttributeTypeMap() {
        return RegistrySvcNodeSelfResponse.attributeTypeMap;
    }
}
RegistrySvcNodeSelfResponse.discriminator = undefined;
RegistrySvcNodeSelfResponse.attributeTypeMap = [
    {
        "name": "node",
        "baseName": "node",
        "type": "RegistrySvcNode"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class RegistrySvcPortMapping {
    static getAttributeTypeMap() {
        return RegistrySvcPortMapping.attributeTypeMap;
    }
}
RegistrySvcPortMapping.discriminator = undefined;
RegistrySvcPortMapping.attributeTypeMap = [
    {
        "name": "host",
        "baseName": "host",
        "type": "number"
    },
    {
        "name": "internal",
        "baseName": "internal",
        "type": "number"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class RegistrySvcProcess {
    static getAttributeTypeMap() {
        return RegistrySvcProcess.attributeTypeMap;
    }
}
RegistrySvcProcess.discriminator = undefined;
RegistrySvcProcess.attributeTypeMap = [
    {
        "name": "memoryUsage",
        "baseName": "memoryUsage",
        "type": "number"
    },
    {
        "name": "pid",
        "baseName": "pid",
        "type": "number"
    },
    {
        "name": "processName",
        "baseName": "processName",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class RegistrySvcRegisterInstanceRequest {
    static getAttributeTypeMap() {
        return RegistrySvcRegisterInstanceRequest.attributeTypeMap;
    }
}
RegistrySvcRegisterInstanceRequest.discriminator = undefined;
RegistrySvcRegisterInstanceRequest.attributeTypeMap = [
    {
        "name": "deploymentId",
        "baseName": "deploymentId",
        "type": "string"
    },
    {
        "name": "host",
        "baseName": "host",
        "type": "string"
    },
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "ip",
        "baseName": "ip",
        "type": "string"
    },
    {
        "name": "path",
        "baseName": "path",
        "type": "string"
    },
    {
        "name": "port",
        "baseName": "port",
        "type": "number"
    },
    {
        "name": "scheme",
        "baseName": "scheme",
        "type": "string"
    },
    {
        "name": "url",
        "baseName": "url",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
* Repository based definitions is an alternative to Image definitions. Instead of deploying an already built and pushed image, a source code repository url can be provided. The container will be built from the source.
*/
class RegistrySvcRepositorySpec {
    static getAttributeTypeMap() {
        return RegistrySvcRepositorySpec.attributeTypeMap;
    }
}
RegistrySvcRepositorySpec.discriminator = undefined;
RegistrySvcRepositorySpec.attributeTypeMap = [
    {
        "name": "buildContext",
        "baseName": "buildContext",
        "type": "string"
    },
    {
        "name": "containerFile",
        "baseName": "containerFile",
        "type": "string"
    },
    {
        "name": "internalPorts",
        "baseName": "internalPorts",
        "type": "Array<number>"
    },
    {
        "name": "url",
        "baseName": "url",
        "type": "string"
    },
    {
        "name": "version",
        "baseName": "version",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
* Resource usage metrics of the node.
*/
class RegistrySvcResourceUsage {
    static getAttributeTypeMap() {
        return RegistrySvcResourceUsage.attributeTypeMap;
    }
}
RegistrySvcResourceUsage.discriminator = undefined;
RegistrySvcResourceUsage.attributeTypeMap = [
    {
        "name": "cpu",
        "baseName": "cpu",
        "type": "RegistrySvcUsage"
    },
    {
        "name": "disk",
        "baseName": "disk",
        "type": "RegistrySvcUsage"
    },
    {
        "name": "memory",
        "baseName": "memory",
        "type": "RegistrySvcUsage"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class RegistrySvcSaveDefinitionRequest {
    static getAttributeTypeMap() {
        return RegistrySvcSaveDefinitionRequest.attributeTypeMap;
    }
}
RegistrySvcSaveDefinitionRequest.discriminator = undefined;
RegistrySvcSaveDefinitionRequest.attributeTypeMap = [
    {
        "name": "definition",
        "baseName": "definition",
        "type": "RegistrySvcDefinition"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
* CPU usage metrics.
*/
class RegistrySvcUsage {
    static getAttributeTypeMap() {
        return RegistrySvcUsage.attributeTypeMap;
    }
}
RegistrySvcUsage.discriminator = undefined;
RegistrySvcUsage.attributeTypeMap = [
    {
        "name": "percent",
        "baseName": "percent",
        "type": "number"
    },
    {
        "name": "total",
        "baseName": "total",
        "type": "number"
    },
    {
        "name": "used",
        "baseName": "used",
        "type": "number"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class SecretSvcDecryptValueRequest {
    static getAttributeTypeMap() {
        return SecretSvcDecryptValueRequest.attributeTypeMap;
    }
}
SecretSvcDecryptValueRequest.discriminator = undefined;
SecretSvcDecryptValueRequest.attributeTypeMap = [
    {
        "name": "value",
        "baseName": "value",
        "type": "string"
    },
    {
        "name": "values",
        "baseName": "values",
        "type": "Array<string>"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class SecretSvcDecryptValueResponse {
    static getAttributeTypeMap() {
        return SecretSvcDecryptValueResponse.attributeTypeMap;
    }
}
SecretSvcDecryptValueResponse.discriminator = undefined;
SecretSvcDecryptValueResponse.attributeTypeMap = [
    {
        "name": "value",
        "baseName": "value",
        "type": "string"
    },
    {
        "name": "values",
        "baseName": "values",
        "type": "Array<string>"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class SecretSvcEncryptValueRequest {
    static getAttributeTypeMap() {
        return SecretSvcEncryptValueRequest.attributeTypeMap;
    }
}
SecretSvcEncryptValueRequest.discriminator = undefined;
SecretSvcEncryptValueRequest.attributeTypeMap = [
    {
        "name": "value",
        "baseName": "value",
        "type": "string"
    },
    {
        "name": "values",
        "baseName": "values",
        "type": "Array<string>"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class SecretSvcEncryptValueResponse {
    static getAttributeTypeMap() {
        return SecretSvcEncryptValueResponse.attributeTypeMap;
    }
}
SecretSvcEncryptValueResponse.discriminator = undefined;
SecretSvcEncryptValueResponse.attributeTypeMap = [
    {
        "name": "value",
        "baseName": "value",
        "type": "string"
    },
    {
        "name": "values",
        "baseName": "values",
        "type": "Array<string>"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class SecretSvcIsSecureResponse {
    static getAttributeTypeMap() {
        return SecretSvcIsSecureResponse.attributeTypeMap;
    }
}
SecretSvcIsSecureResponse.discriminator = undefined;
SecretSvcIsSecureResponse.attributeTypeMap = [
    {
        "name": "isSecure",
        "baseName": "isSecure",
        "type": "boolean"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class SecretSvcListSecretsRequest {
    static getAttributeTypeMap() {
        return SecretSvcListSecretsRequest.attributeTypeMap;
    }
}
SecretSvcListSecretsRequest.discriminator = undefined;
SecretSvcListSecretsRequest.attributeTypeMap = [
    {
        "name": "key",
        "baseName": "key",
        "type": "string"
    },
    {
        "name": "keys",
        "baseName": "keys",
        "type": "Array<string>"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class SecretSvcListSecretsResponse {
    static getAttributeTypeMap() {
        return SecretSvcListSecretsResponse.attributeTypeMap;
    }
}
SecretSvcListSecretsResponse.discriminator = undefined;
SecretSvcListSecretsResponse.attributeTypeMap = [
    {
        "name": "secrets",
        "baseName": "secrets",
        "type": "Array<SecretSvcSecret>"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class SecretSvcRemoveSecretsRequest {
    static getAttributeTypeMap() {
        return SecretSvcRemoveSecretsRequest.attributeTypeMap;
    }
}
SecretSvcRemoveSecretsRequest.discriminator = undefined;
SecretSvcRemoveSecretsRequest.attributeTypeMap = [
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "ids",
        "baseName": "ids",
        "type": "Array<string>"
    },
    {
        "name": "key",
        "baseName": "key",
        "type": "string"
    },
    {
        "name": "keys",
        "baseName": "keys",
        "type": "Array<string>"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class SecretSvcSaveSecretsRequest {
    static getAttributeTypeMap() {
        return SecretSvcSaveSecretsRequest.attributeTypeMap;
    }
}
SecretSvcSaveSecretsRequest.discriminator = undefined;
SecretSvcSaveSecretsRequest.attributeTypeMap = [
    {
        "name": "secrets",
        "baseName": "secrets",
        "type": "Array<SecretSvcSecret>"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class SecretSvcSecret {
    static getAttributeTypeMap() {
        return SecretSvcSecret.attributeTypeMap;
    }
}
SecretSvcSecret.discriminator = undefined;
SecretSvcSecret.attributeTypeMap = [
    {
        "name": "app",
        "baseName": "app",
        "type": "string"
    },
    {
        "name": "canChangeDeleters",
        "baseName": "canChangeDeleters",
        "type": "Array<string>"
    },
    {
        "name": "canChangeReaders",
        "baseName": "canChangeReaders",
        "type": "Array<string>"
    },
    {
        "name": "canChangeWriters",
        "baseName": "canChangeWriters",
        "type": "Array<string>"
    },
    {
        "name": "checksum",
        "baseName": "checksum",
        "type": "string"
    },
    {
        "name": "checksumAlgorithm",
        "baseName": "checksumAlgorithm",
        "type": "string"
    },
    {
        "name": "deleters",
        "baseName": "deleters",
        "type": "Array<string>"
    },
    {
        "name": "encrypted",
        "baseName": "encrypted",
        "type": "boolean"
    },
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "key",
        "baseName": "key",
        "type": "string"
    },
    {
        "name": "readers",
        "baseName": "readers",
        "type": "Array<string>"
    },
    {
        "name": "value",
        "baseName": "value",
        "type": "string"
    },
    {
        "name": "writers",
        "baseName": "writers",
        "type": "Array<string>"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class SourceSvcCheckoutRepoRequest {
    static getAttributeTypeMap() {
        return SourceSvcCheckoutRepoRequest.attributeTypeMap;
    }
}
SourceSvcCheckoutRepoRequest.discriminator = undefined;
SourceSvcCheckoutRepoRequest.attributeTypeMap = [
    {
        "name": "password",
        "baseName": "password",
        "type": "string"
    },
    {
        "name": "ssh_key",
        "baseName": "ssh_key",
        "type": "string"
    },
    {
        "name": "ssh_key_pwd",
        "baseName": "ssh_key_pwd",
        "type": "string"
    },
    {
        "name": "token",
        "baseName": "token",
        "type": "string"
    },
    {
        "name": "url",
        "baseName": "url",
        "type": "string"
    },
    {
        "name": "username",
        "baseName": "username",
        "type": "string"
    },
    {
        "name": "version",
        "baseName": "version",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class SourceSvcCheckoutRepoResponse {
    static getAttributeTypeMap() {
        return SourceSvcCheckoutRepoResponse.attributeTypeMap;
    }
}
SourceSvcCheckoutRepoResponse.discriminator = undefined;
SourceSvcCheckoutRepoResponse.attributeTypeMap = [
    {
        "name": "dir",
        "baseName": "dir",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class SourceSvcErrorResponse {
    static getAttributeTypeMap() {
        return SourceSvcErrorResponse.attributeTypeMap;
    }
}
SourceSvcErrorResponse.discriminator = undefined;
SourceSvcErrorResponse.attributeTypeMap = [
    {
        "name": "error",
        "baseName": "error",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
* Text to image parameters
*/
class StableDiffusionTxt2ImgRequest {
    static getAttributeTypeMap() {
        return StableDiffusionTxt2ImgRequest.attributeTypeMap;
    }
}
StableDiffusionTxt2ImgRequest.discriminator = undefined;
StableDiffusionTxt2ImgRequest.attributeTypeMap = [
    {
        "name": "alwayson_scripts",
        "baseName": "alwayson_scripts",
        "type": "{ [key: string]: string; }"
    },
    {
        "name": "batch_size",
        "baseName": "batch_size",
        "type": "number"
    },
    {
        "name": "cfg_scale",
        "baseName": "cfg_scale",
        "type": "number"
    },
    {
        "name": "comments",
        "baseName": "comments",
        "type": "{ [key: string]: string; }"
    },
    {
        "name": "denoising_strength",
        "baseName": "denoising_strength",
        "type": "number"
    },
    {
        "name": "disable_extra_networks",
        "baseName": "disable_extra_networks",
        "type": "boolean"
    },
    {
        "name": "do_not_save_grid",
        "baseName": "do_not_save_grid",
        "type": "boolean"
    },
    {
        "name": "do_not_save_samples",
        "baseName": "do_not_save_samples",
        "type": "boolean"
    },
    {
        "name": "enable_hr",
        "baseName": "enable_hr",
        "type": "boolean"
    },
    {
        "name": "eta",
        "baseName": "eta",
        "type": "number"
    },
    {
        "name": "firstpass_image",
        "baseName": "firstpass_image",
        "type": "string"
    },
    {
        "name": "firstphase_height",
        "baseName": "firstphase_height",
        "type": "number"
    },
    {
        "name": "firstphase_width",
        "baseName": "firstphase_width",
        "type": "number"
    },
    {
        "name": "force_task_id",
        "baseName": "force_task_id",
        "type": "string"
    },
    {
        "name": "height",
        "baseName": "height",
        "type": "number"
    },
    {
        "name": "hr_checkpoint_name",
        "baseName": "hr_checkpoint_name",
        "type": "string"
    },
    {
        "name": "hr_negative_prompt",
        "baseName": "hr_negative_prompt",
        "type": "string"
    },
    {
        "name": "hr_prompt",
        "baseName": "hr_prompt",
        "type": "string"
    },
    {
        "name": "hr_resize_x",
        "baseName": "hr_resize_x",
        "type": "number"
    },
    {
        "name": "hr_resize_y",
        "baseName": "hr_resize_y",
        "type": "number"
    },
    {
        "name": "hr_sampler_name",
        "baseName": "hr_sampler_name",
        "type": "string"
    },
    {
        "name": "hr_scale",
        "baseName": "hr_scale",
        "type": "number"
    },
    {
        "name": "hr_scheduler",
        "baseName": "hr_scheduler",
        "type": "string"
    },
    {
        "name": "hr_second_pass_steps",
        "baseName": "hr_second_pass_steps",
        "type": "number"
    },
    {
        "name": "hr_upscaler",
        "baseName": "hr_upscaler",
        "type": "string"
    },
    {
        "name": "infotext",
        "baseName": "infotext",
        "type": "string"
    },
    {
        "name": "n_iter",
        "baseName": "n_iter",
        "type": "number"
    },
    {
        "name": "negative_prompt",
        "baseName": "negative_prompt",
        "type": "string"
    },
    {
        "name": "override_settings",
        "baseName": "override_settings",
        "type": "{ [key: string]: string; }"
    },
    {
        "name": "override_settings_restore_afterwards",
        "baseName": "override_settings_restore_afterwards",
        "type": "boolean"
    },
    {
        "name": "prompt",
        "baseName": "prompt",
        "type": "string"
    },
    {
        "name": "refiner_checkpoint",
        "baseName": "refiner_checkpoint",
        "type": "string"
    },
    {
        "name": "refiner_switch_at",
        "baseName": "refiner_switch_at",
        "type": "number"
    },
    {
        "name": "restore_faces",
        "baseName": "restore_faces",
        "type": "boolean"
    },
    {
        "name": "s_churn",
        "baseName": "s_churn",
        "type": "number"
    },
    {
        "name": "s_min_uncond",
        "baseName": "s_min_uncond",
        "type": "number"
    },
    {
        "name": "s_noise",
        "baseName": "s_noise",
        "type": "number"
    },
    {
        "name": "s_tmax",
        "baseName": "s_tmax",
        "type": "number"
    },
    {
        "name": "s_tmin",
        "baseName": "s_tmin",
        "type": "number"
    },
    {
        "name": "sampler_index",
        "baseName": "sampler_index",
        "type": "string"
    },
    {
        "name": "sampler_name",
        "baseName": "sampler_name",
        "type": "string"
    },
    {
        "name": "save_images",
        "baseName": "save_images",
        "type": "boolean"
    },
    {
        "name": "scheduler",
        "baseName": "scheduler",
        "type": "string"
    },
    {
        "name": "script_args",
        "baseName": "script_args",
        "type": "Array<string>"
    },
    {
        "name": "script_name",
        "baseName": "script_name",
        "type": "string"
    },
    {
        "name": "seed",
        "baseName": "seed",
        "type": "number"
    },
    {
        "name": "seed_resize_from_h",
        "baseName": "seed_resize_from_h",
        "type": "number"
    },
    {
        "name": "seed_resize_from_w",
        "baseName": "seed_resize_from_w",
        "type": "number"
    },
    {
        "name": "send_images",
        "baseName": "send_images",
        "type": "boolean"
    },
    {
        "name": "steps",
        "baseName": "steps",
        "type": "number"
    },
    {
        "name": "styles",
        "baseName": "styles",
        "type": "Array<string>"
    },
    {
        "name": "subseed",
        "baseName": "subseed",
        "type": "number"
    },
    {
        "name": "subseed_strength",
        "baseName": "subseed_strength",
        "type": "number"
    },
    {
        "name": "tiling",
        "baseName": "tiling",
        "type": "boolean"
    },
    {
        "name": "width",
        "baseName": "width",
        "type": "number"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
* Due to the nature of JWT tokens, the token must be refreshed after creating an organization, as dynamic organization roles are embedded in it.
*/
class UserSvcAuthToken {
    static getAttributeTypeMap() {
        return UserSvcAuthToken.attributeTypeMap;
    }
}
UserSvcAuthToken.discriminator = undefined;
UserSvcAuthToken.attributeTypeMap = [
    {
        "name": "active",
        "baseName": "active",
        "type": "boolean"
    },
    {
        "name": "app",
        "baseName": "app",
        "type": "string"
    },
    {
        "name": "createdAt",
        "baseName": "createdAt",
        "type": "string"
    },
    {
        "name": "deletedAt",
        "baseName": "deletedAt",
        "type": "string"
    },
    {
        "name": "device",
        "baseName": "device",
        "type": "string"
    },
    {
        "name": "expiresAt",
        "baseName": "expiresAt",
        "type": "string"
    },
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "lastRefreshedAt",
        "baseName": "lastRefreshedAt",
        "type": "string"
    },
    {
        "name": "token",
        "baseName": "token",
        "type": "string"
    },
    {
        "name": "updatedAt",
        "baseName": "updatedAt",
        "type": "string"
    },
    {
        "name": "userId",
        "baseName": "userId",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class UserSvcChangePasswordRequest {
    static getAttributeTypeMap() {
        return UserSvcChangePasswordRequest.attributeTypeMap;
    }
}
UserSvcChangePasswordRequest.discriminator = undefined;
UserSvcChangePasswordRequest.attributeTypeMap = [
    {
        "name": "currentPassword",
        "baseName": "currentPassword",
        "type": "string"
    },
    {
        "name": "newPassword",
        "baseName": "newPassword",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class UserSvcContact {
    static getAttributeTypeMap() {
        return UserSvcContact.attributeTypeMap;
    }
}
UserSvcContact.discriminator = undefined;
UserSvcContact.attributeTypeMap = [
    {
        "name": "createdAt",
        "baseName": "createdAt",
        "type": "string"
    },
    {
        "name": "deletedAt",
        "baseName": "deletedAt",
        "type": "string"
    },
    {
        "name": "handle",
        "baseName": "handle",
        "type": "string"
    },
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "isPrimary",
        "baseName": "isPrimary",
        "type": "boolean"
    },
    {
        "name": "platform",
        "baseName": "platform",
        "type": "string"
    },
    {
        "name": "updatedAt",
        "baseName": "updatedAt",
        "type": "string"
    },
    {
        "name": "userId",
        "baseName": "userId",
        "type": "string"
    },
    {
        "name": "verified",
        "baseName": "verified",
        "type": "boolean"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class UserSvcContactInput {
    static getAttributeTypeMap() {
        return UserSvcContactInput.attributeTypeMap;
    }
}
UserSvcContactInput.discriminator = undefined;
UserSvcContactInput.attributeTypeMap = [
    {
        "name": "handle",
        "baseName": "handle",
        "type": "string"
    },
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "platform",
        "baseName": "platform",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class UserSvcCreateUserRequest {
    static getAttributeTypeMap() {
        return UserSvcCreateUserRequest.attributeTypeMap;
    }
}
UserSvcCreateUserRequest.discriminator = undefined;
UserSvcCreateUserRequest.attributeTypeMap = [
    {
        "name": "app",
        "baseName": "app",
        "type": "string"
    },
    {
        "name": "contacts",
        "baseName": "contacts",
        "type": "Array<UserSvcContact>"
    },
    {
        "name": "password",
        "baseName": "password",
        "type": "string"
    },
    {
        "name": "roleIds",
        "baseName": "roleIds",
        "type": "Array<string>"
    },
    {
        "name": "user",
        "baseName": "user",
        "type": "UserSvcUserInput"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class UserSvcEnroll {
    static getAttributeTypeMap() {
        return UserSvcEnroll.attributeTypeMap;
    }
}
UserSvcEnroll.discriminator = undefined;
UserSvcEnroll.attributeTypeMap = [
    {
        "name": "app",
        "baseName": "app",
        "type": "string"
    },
    {
        "name": "contactId",
        "baseName": "contactId",
        "type": "string"
    },
    {
        "name": "createdAt",
        "baseName": "createdAt",
        "type": "string"
    },
    {
        "name": "createdBy",
        "baseName": "createdBy",
        "type": "string"
    },
    {
        "name": "deletedAt",
        "baseName": "deletedAt",
        "type": "string"
    },
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "role",
        "baseName": "role",
        "type": "string"
    },
    {
        "name": "updatedAt",
        "baseName": "updatedAt",
        "type": "string"
    },
    {
        "name": "userId",
        "baseName": "userId",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class UserSvcEnrollInput {
    static getAttributeTypeMap() {
        return UserSvcEnrollInput.attributeTypeMap;
    }
}
UserSvcEnrollInput.discriminator = undefined;
UserSvcEnrollInput.attributeTypeMap = [
    {
        "name": "app",
        "baseName": "app",
        "type": "string"
    },
    {
        "name": "contactId",
        "baseName": "contactId",
        "type": "string"
    },
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "role",
        "baseName": "role",
        "type": "string"
    },
    {
        "name": "userId",
        "baseName": "userId",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class UserSvcErrorResponse {
    static getAttributeTypeMap() {
        return UserSvcErrorResponse.attributeTypeMap;
    }
}
UserSvcErrorResponse.discriminator = undefined;
UserSvcErrorResponse.attributeTypeMap = [
    {
        "name": "error",
        "baseName": "error",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class UserSvcExchangeTokenRequest {
    static getAttributeTypeMap() {
        return UserSvcExchangeTokenRequest.attributeTypeMap;
    }
}
UserSvcExchangeTokenRequest.discriminator = undefined;
UserSvcExchangeTokenRequest.attributeTypeMap = [
    {
        "name": "newApp",
        "baseName": "newApp",
        "type": "string"
    },
    {
        "name": "newDevice",
        "baseName": "newDevice",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class UserSvcExchangeTokenResponse {
    static getAttributeTypeMap() {
        return UserSvcExchangeTokenResponse.attributeTypeMap;
    }
}
UserSvcExchangeTokenResponse.discriminator = undefined;
UserSvcExchangeTokenResponse.attributeTypeMap = [
    {
        "name": "token",
        "baseName": "token",
        "type": "UserSvcAuthToken"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class UserSvcGetPublicKeyResponse {
    static getAttributeTypeMap() {
        return UserSvcGetPublicKeyResponse.attributeTypeMap;
    }
}
UserSvcGetPublicKeyResponse.discriminator = undefined;
UserSvcGetPublicKeyResponse.attributeTypeMap = [
    {
        "name": "publicKey",
        "baseName": "publicKey",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class UserSvcHasPermissionResponse {
    static getAttributeTypeMap() {
        return UserSvcHasPermissionResponse.attributeTypeMap;
    }
}
UserSvcHasPermissionResponse.discriminator = undefined;
UserSvcHasPermissionResponse.attributeTypeMap = [
    {
        "name": "app",
        "baseName": "app",
        "type": "string"
    },
    {
        "name": "authorized",
        "baseName": "authorized",
        "type": "boolean"
    },
    {
        "name": "until",
        "baseName": "until",
        "type": "string"
    },
    {
        "name": "user",
        "baseName": "user",
        "type": "UserSvcUser"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class UserSvcListEnrollsRequest {
    static getAttributeTypeMap() {
        return UserSvcListEnrollsRequest.attributeTypeMap;
    }
}
UserSvcListEnrollsRequest.discriminator = undefined;
UserSvcListEnrollsRequest.attributeTypeMap = [
    {
        "name": "contactId",
        "baseName": "contactId",
        "type": "string"
    },
    {
        "name": "role",
        "baseName": "role",
        "type": "string"
    },
    {
        "name": "userId",
        "baseName": "userId",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class UserSvcListEnrollsResponse {
    static getAttributeTypeMap() {
        return UserSvcListEnrollsResponse.attributeTypeMap;
    }
}
UserSvcListEnrollsResponse.discriminator = undefined;
UserSvcListEnrollsResponse.attributeTypeMap = [
    {
        "name": "enrolls",
        "baseName": "enrolls",
        "type": "Array<UserSvcEnroll>"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class UserSvcListOrganizationsRequest {
    static getAttributeTypeMap() {
        return UserSvcListOrganizationsRequest.attributeTypeMap;
    }
}
UserSvcListOrganizationsRequest.discriminator = undefined;
UserSvcListOrganizationsRequest.attributeTypeMap = [
    {
        "name": "afterTime",
        "baseName": "afterTime",
        "type": "string"
    },
    {
        "name": "ids",
        "baseName": "ids",
        "type": "Array<string>"
    },
    {
        "name": "limit",
        "baseName": "limit",
        "type": "number"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class UserSvcListOrganizationsResponse {
    static getAttributeTypeMap() {
        return UserSvcListOrganizationsResponse.attributeTypeMap;
    }
}
UserSvcListOrganizationsResponse.discriminator = undefined;
UserSvcListOrganizationsResponse.attributeTypeMap = [
    {
        "name": "organizations",
        "baseName": "organizations",
        "type": "Array<UserSvcOrganization>"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class UserSvcListPermissionsResponse {
    static getAttributeTypeMap() {
        return UserSvcListPermissionsResponse.attributeTypeMap;
    }
}
UserSvcListPermissionsResponse.discriminator = undefined;
UserSvcListPermissionsResponse.attributeTypeMap = [
    {
        "name": "permissions",
        "baseName": "permissions",
        "type": "Array<string>"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class UserSvcListPermitsRequest {
    static getAttributeTypeMap() {
        return UserSvcListPermitsRequest.attributeTypeMap;
    }
}
UserSvcListPermitsRequest.discriminator = undefined;
UserSvcListPermitsRequest.attributeTypeMap = [
    {
        "name": "permission",
        "baseName": "permission",
        "type": "string"
    },
    {
        "name": "slug",
        "baseName": "slug",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class UserSvcListPermitsResponse {
    static getAttributeTypeMap() {
        return UserSvcListPermitsResponse.attributeTypeMap;
    }
}
UserSvcListPermitsResponse.discriminator = undefined;
UserSvcListPermitsResponse.attributeTypeMap = [
    {
        "name": "permits",
        "baseName": "permits",
        "type": "Array<UserSvcPermit>"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class UserSvcListUsersRequest {
    static getAttributeTypeMap() {
        return UserSvcListUsersRequest.attributeTypeMap;
    }
}
UserSvcListUsersRequest.discriminator = undefined;
UserSvcListUsersRequest.attributeTypeMap = [
    {
        "name": "afterTime",
        "baseName": "afterTime",
        "type": "string"
    },
    {
        "name": "contactId",
        "baseName": "contactId",
        "type": "string"
    },
    {
        "name": "count",
        "baseName": "count",
        "type": "boolean"
    },
    {
        "name": "ids",
        "baseName": "ids",
        "type": "Array<string>"
    },
    {
        "name": "limit",
        "baseName": "limit",
        "type": "number"
    },
    {
        "name": "order",
        "baseName": "order",
        "type": "string"
    },
    {
        "name": "orderBy",
        "baseName": "orderBy",
        "type": "string"
    },
    {
        "name": "search",
        "baseName": "search",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class UserSvcListUsersResponse {
    static getAttributeTypeMap() {
        return UserSvcListUsersResponse.attributeTypeMap;
    }
}
UserSvcListUsersResponse.discriminator = undefined;
UserSvcListUsersResponse.attributeTypeMap = [
    {
        "name": "after",
        "baseName": "after",
        "type": "string"
    },
    {
        "name": "count",
        "baseName": "count",
        "type": "number"
    },
    {
        "name": "users",
        "baseName": "users",
        "type": "Array<UserSvcUserRecord>"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class UserSvcLoginRequest {
    static getAttributeTypeMap() {
        return UserSvcLoginRequest.attributeTypeMap;
    }
}
UserSvcLoginRequest.discriminator = undefined;
UserSvcLoginRequest.attributeTypeMap = [
    {
        "name": "app",
        "baseName": "app",
        "type": "string"
    },
    {
        "name": "contact",
        "baseName": "contact",
        "type": "string"
    },
    {
        "name": "device",
        "baseName": "device",
        "type": "string"
    },
    {
        "name": "password",
        "baseName": "password",
        "type": "string"
    },
    {
        "name": "slug",
        "baseName": "slug",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class UserSvcLoginResponse {
    static getAttributeTypeMap() {
        return UserSvcLoginResponse.attributeTypeMap;
    }
}
UserSvcLoginResponse.discriminator = undefined;
UserSvcLoginResponse.attributeTypeMap = [
    {
        "name": "token",
        "baseName": "token",
        "type": "UserSvcAuthToken"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class UserSvcOrganization {
    static getAttributeTypeMap() {
        return UserSvcOrganization.attributeTypeMap;
    }
}
UserSvcOrganization.discriminator = undefined;
UserSvcOrganization.attributeTypeMap = [
    {
        "name": "app",
        "baseName": "app",
        "type": "string"
    },
    {
        "name": "createdAt",
        "baseName": "createdAt",
        "type": "string"
    },
    {
        "name": "deletedAt",
        "baseName": "deletedAt",
        "type": "string"
    },
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "slug",
        "baseName": "slug",
        "type": "string"
    },
    {
        "name": "thumbnailFileId",
        "baseName": "thumbnailFileId",
        "type": "string"
    },
    {
        "name": "updatedAt",
        "baseName": "updatedAt",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class UserSvcPermit {
    static getAttributeTypeMap() {
        return UserSvcPermit.attributeTypeMap;
    }
}
UserSvcPermit.discriminator = undefined;
UserSvcPermit.attributeTypeMap = [
    {
        "name": "app",
        "baseName": "app",
        "type": "string"
    },
    {
        "name": "createdAt",
        "baseName": "createdAt",
        "type": "string"
    },
    {
        "name": "deletedAt",
        "baseName": "deletedAt",
        "type": "string"
    },
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "permission",
        "baseName": "permission",
        "type": "string"
    },
    {
        "name": "roles",
        "baseName": "roles",
        "type": "Array<string>"
    },
    {
        "name": "slugs",
        "baseName": "slugs",
        "type": "Array<string>"
    },
    {
        "name": "updatedAt",
        "baseName": "updatedAt",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class UserSvcPermitInput {
    static getAttributeTypeMap() {
        return UserSvcPermitInput.attributeTypeMap;
    }
}
UserSvcPermitInput.discriminator = undefined;
UserSvcPermitInput.attributeTypeMap = [
    {
        "name": "app",
        "baseName": "app",
        "type": "string"
    },
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "permission",
        "baseName": "permission",
        "type": "string"
    },
    {
        "name": "roles",
        "baseName": "roles",
        "type": "Array<string>"
    },
    {
        "name": "slugs",
        "baseName": "slugs",
        "type": "Array<string>"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class UserSvcReadSelfRequest {
    static getAttributeTypeMap() {
        return UserSvcReadSelfRequest.attributeTypeMap;
    }
}
UserSvcReadSelfRequest.discriminator = undefined;
UserSvcReadSelfRequest.attributeTypeMap = [
    {
        "name": "countTokens",
        "baseName": "countTokens",
        "type": "boolean"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class UserSvcReadSelfResponse {
    static getAttributeTypeMap() {
        return UserSvcReadSelfResponse.attributeTypeMap;
    }
}
UserSvcReadSelfResponse.discriminator = undefined;
UserSvcReadSelfResponse.attributeTypeMap = [
    {
        "name": "activeOrganizationId",
        "baseName": "activeOrganizationId",
        "type": "string"
    },
    {
        "name": "contacts",
        "baseName": "contacts",
        "type": "Array<UserSvcContact>"
    },
    {
        "name": "organizations",
        "baseName": "organizations",
        "type": "Array<UserSvcOrganization>"
    },
    {
        "name": "roles",
        "baseName": "roles",
        "type": "Array<string>"
    },
    {
        "name": "tokenCount",
        "baseName": "tokenCount",
        "type": "number"
    },
    {
        "name": "user",
        "baseName": "user",
        "type": "UserSvcUser"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class UserSvcRefreshTokenResponse {
    static getAttributeTypeMap() {
        return UserSvcRefreshTokenResponse.attributeTypeMap;
    }
}
UserSvcRefreshTokenResponse.discriminator = undefined;
UserSvcRefreshTokenResponse.attributeTypeMap = [
    {
        "name": "token",
        "baseName": "token",
        "type": "UserSvcAuthToken"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class UserSvcRegisterRequest {
    static getAttributeTypeMap() {
        return UserSvcRegisterRequest.attributeTypeMap;
    }
}
UserSvcRegisterRequest.discriminator = undefined;
UserSvcRegisterRequest.attributeTypeMap = [
    {
        "name": "app",
        "baseName": "app",
        "type": "string"
    },
    {
        "name": "contact",
        "baseName": "contact",
        "type": "UserSvcContactInput"
    },
    {
        "name": "device",
        "baseName": "device",
        "type": "string"
    },
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "password",
        "baseName": "password",
        "type": "string"
    },
    {
        "name": "slug",
        "baseName": "slug",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class UserSvcRegisterResponse {
    static getAttributeTypeMap() {
        return UserSvcRegisterResponse.attributeTypeMap;
    }
}
UserSvcRegisterResponse.discriminator = undefined;
UserSvcRegisterResponse.attributeTypeMap = [
    {
        "name": "token",
        "baseName": "token",
        "type": "UserSvcAuthToken"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class UserSvcResetPasswordRequest {
    static getAttributeTypeMap() {
        return UserSvcResetPasswordRequest.attributeTypeMap;
    }
}
UserSvcResetPasswordRequest.discriminator = undefined;
UserSvcResetPasswordRequest.attributeTypeMap = [
    {
        "name": "newPassword",
        "baseName": "newPassword",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class UserSvcRevokeTokensRequest {
    static getAttributeTypeMap() {
        return UserSvcRevokeTokensRequest.attributeTypeMap;
    }
}
UserSvcRevokeTokensRequest.discriminator = undefined;
UserSvcRevokeTokensRequest.attributeTypeMap = [
    {
        "name": "allTokens",
        "baseName": "allTokens",
        "type": "boolean"
    },
    {
        "name": "device",
        "baseName": "device",
        "type": "string"
    },
    {
        "name": "userId",
        "baseName": "userId",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class UserSvcSaveEnrollsRequest {
    static getAttributeTypeMap() {
        return UserSvcSaveEnrollsRequest.attributeTypeMap;
    }
}
UserSvcSaveEnrollsRequest.discriminator = undefined;
UserSvcSaveEnrollsRequest.attributeTypeMap = [
    {
        "name": "enrolls",
        "baseName": "enrolls",
        "type": "Array<UserSvcEnrollInput>"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class UserSvcSaveEnrollsResponse {
    static getAttributeTypeMap() {
        return UserSvcSaveEnrollsResponse.attributeTypeMap;
    }
}
UserSvcSaveEnrollsResponse.discriminator = undefined;
UserSvcSaveEnrollsResponse.attributeTypeMap = [
    {
        "name": "enrolls",
        "baseName": "enrolls",
        "type": "Array<UserSvcEnroll>"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class UserSvcSaveOrganizationRequest {
    static getAttributeTypeMap() {
        return UserSvcSaveOrganizationRequest.attributeTypeMap;
    }
}
UserSvcSaveOrganizationRequest.discriminator = undefined;
UserSvcSaveOrganizationRequest.attributeTypeMap = [
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "slug",
        "baseName": "slug",
        "type": "string"
    },
    {
        "name": "thumbnailFileId",
        "baseName": "thumbnailFileId",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class UserSvcSaveOrganizationResponse {
    static getAttributeTypeMap() {
        return UserSvcSaveOrganizationResponse.attributeTypeMap;
    }
}
UserSvcSaveOrganizationResponse.discriminator = undefined;
UserSvcSaveOrganizationResponse.attributeTypeMap = [
    {
        "name": "organization",
        "baseName": "organization",
        "type": "UserSvcOrganization"
    },
    {
        "name": "token",
        "baseName": "token",
        "type": "UserSvcAuthToken"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class UserSvcSavePermitsRequest {
    static getAttributeTypeMap() {
        return UserSvcSavePermitsRequest.attributeTypeMap;
    }
}
UserSvcSavePermitsRequest.discriminator = undefined;
UserSvcSavePermitsRequest.attributeTypeMap = [
    {
        "name": "permits",
        "baseName": "permits",
        "type": "Array<UserSvcPermitInput>"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class UserSvcSaveSelfRequest {
    static getAttributeTypeMap() {
        return UserSvcSaveSelfRequest.attributeTypeMap;
    }
}
UserSvcSaveSelfRequest.discriminator = undefined;
UserSvcSaveSelfRequest.attributeTypeMap = [
    {
        "name": "labels",
        "baseName": "labels",
        "type": "{ [key: string]: string; }"
    },
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "thumbnailFileId",
        "baseName": "thumbnailFileId",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class UserSvcSaveUserRequest {
    static getAttributeTypeMap() {
        return UserSvcSaveUserRequest.attributeTypeMap;
    }
}
UserSvcSaveUserRequest.discriminator = undefined;
UserSvcSaveUserRequest.attributeTypeMap = [
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "thumbnailFileId",
        "baseName": "thumbnailFileId",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
* The user who made the request.
*/
class UserSvcUser {
    static getAttributeTypeMap() {
        return UserSvcUser.attributeTypeMap;
    }
}
UserSvcUser.discriminator = undefined;
UserSvcUser.attributeTypeMap = [
    {
        "name": "createdAt",
        "baseName": "createdAt",
        "type": "string"
    },
    {
        "name": "deletedAt",
        "baseName": "deletedAt",
        "type": "string"
    },
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "labels",
        "baseName": "labels",
        "type": "{ [key: string]: string; }"
    },
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "slug",
        "baseName": "slug",
        "type": "string"
    },
    {
        "name": "thumbnailFileId",
        "baseName": "thumbnailFileId",
        "type": "string"
    },
    {
        "name": "updatedAt",
        "baseName": "updatedAt",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class UserSvcUserInput {
    static getAttributeTypeMap() {
        return UserSvcUserInput.attributeTypeMap;
    }
}
UserSvcUserInput.discriminator = undefined;
UserSvcUserInput.attributeTypeMap = [
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "labels",
        "baseName": "labels",
        "type": "{ [key: string]: string; }"
    },
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "slug",
        "baseName": "slug",
        "type": "string"
    },
    {
        "name": "thumbnailFileId",
        "baseName": "thumbnailFileId",
        "type": "string"
    }
];

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class UserSvcUserRecord {
    static getAttributeTypeMap() {
        return UserSvcUserRecord.attributeTypeMap;
    }
}
UserSvcUserRecord.discriminator = undefined;
UserSvcUserRecord.attributeTypeMap = [
    {
        "name": "contactIds",
        "baseName": "contactIds",
        "type": "Array<string>"
    },
    {
        "name": "createdAt",
        "baseName": "createdAt",
        "type": "string"
    },
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "roles",
        "baseName": "roles",
        "type": "Array<string>"
    },
    {
        "name": "slug",
        "baseName": "slug",
        "type": "string"
    },
    {
        "name": "updatedAt",
        "baseName": "updatedAt",
        "type": "string"
    }
];

/* tslint:disable:no-unused-variable */
let primitives = [
    "string",
    "boolean",
    "double",
    "integer",
    "long",
    "float",
    "number",
    "any"
];
let enumsMap = {};
let typeMap = {
    "ChatSvcEventMessageAdded": ChatSvcEventMessageAdded,
    "ChatSvcEventThreadAdded": ChatSvcEventThreadAdded,
    "ChatSvcEventThreadUpdate": ChatSvcEventThreadUpdate,
    "ChatSvcListMessagesRequest": ChatSvcListMessagesRequest,
    "ChatSvcListMessagesResponse": ChatSvcListMessagesResponse,
    "ChatSvcListThreadsRequest": ChatSvcListThreadsRequest,
    "ChatSvcListThreadsResponse": ChatSvcListThreadsResponse,
    "ChatSvcMessage": ChatSvcMessage,
    "ChatSvcSaveMessageRequest": ChatSvcSaveMessageRequest,
    "ChatSvcSaveThreadRequest": ChatSvcSaveThreadRequest,
    "ChatSvcSaveThreadResponse": ChatSvcSaveThreadResponse,
    "ChatSvcThread": ChatSvcThread,
    "ConfigSvcConfig": ConfigSvcConfig,
    "ConfigSvcListConfigsRequest": ConfigSvcListConfigsRequest,
    "ConfigSvcListConfigsResponse": ConfigSvcListConfigsResponse,
    "ConfigSvcSaveConfigRequest": ConfigSvcSaveConfigRequest,
    "ContainerSvcAsset": ContainerSvcAsset,
    "ContainerSvcBuildImageRequest": ContainerSvcBuildImageRequest,
    "ContainerSvcCapabilities": ContainerSvcCapabilities,
    "ContainerSvcContainer": ContainerSvcContainer,
    "ContainerSvcContainerIsRunningResponse": ContainerSvcContainerIsRunningResponse,
    "ContainerSvcDaemonInfoResponse": ContainerSvcDaemonInfoResponse,
    "ContainerSvcEnvVar": ContainerSvcEnvVar,
    "ContainerSvcErrorResponse": ContainerSvcErrorResponse,
    "ContainerSvcGetContainerSummaryResponse": ContainerSvcGetContainerSummaryResponse,
    "ContainerSvcGetHostResponse": ContainerSvcGetHostResponse,
    "ContainerSvcImagePullableResponse": ContainerSvcImagePullableResponse,
    "ContainerSvcKeep": ContainerSvcKeep,
    "ContainerSvcLabel": ContainerSvcLabel,
    "ContainerSvcListContainersRequest": ContainerSvcListContainersRequest,
    "ContainerSvcListContainersResponse": ContainerSvcListContainersResponse,
    "ContainerSvcListLogsRequest": ContainerSvcListLogsRequest,
    "ContainerSvcListLogsResponse": ContainerSvcListLogsResponse,
    "ContainerSvcLog": ContainerSvcLog,
    "ContainerSvcNetwork": ContainerSvcNetwork,
    "ContainerSvcPortMapping": ContainerSvcPortMapping,
    "ContainerSvcResources": ContainerSvcResources,
    "ContainerSvcRunContainerRequest": ContainerSvcRunContainerRequest,
    "ContainerSvcRunContainerResponse": ContainerSvcRunContainerResponse,
    "ContainerSvcStopContainerRequest": ContainerSvcStopContainerRequest,
    "ContainerSvcVolume": ContainerSvcVolume,
    "DataSvcCreateObjectFields": DataSvcCreateObjectFields,
    "DataSvcCreateObjectRequest": DataSvcCreateObjectRequest,
    "DataSvcCreateObjectResponse": DataSvcCreateObjectResponse,
    "DataSvcDeleteObjectRequest": DataSvcDeleteObjectRequest,
    "DataSvcErrorResponse": DataSvcErrorResponse,
    "DataSvcObject": DataSvcObject,
    "DataSvcQueryRequest": DataSvcQueryRequest,
    "DataSvcQueryResponse": DataSvcQueryResponse,
    "DataSvcUpdateObjectsRequest": DataSvcUpdateObjectsRequest,
    "DataSvcUpsertObjectRequest": DataSvcUpsertObjectRequest,
    "DataSvcUpsertObjectResponse": DataSvcUpsertObjectResponse,
    "DatastoreFilter": DatastoreFilter,
    "DatastoreOrderBy": DatastoreOrderBy,
    "DatastoreQuery": DatastoreQuery,
    "DeploySvcAutoScalingConfig": DeploySvcAutoScalingConfig,
    "DeploySvcDeleteDeploymentRequest": DeploySvcDeleteDeploymentRequest,
    "DeploySvcDeployment": DeploySvcDeployment,
    "DeploySvcDeploymentStrategy": DeploySvcDeploymentStrategy,
    "DeploySvcErrorResponse": DeploySvcErrorResponse,
    "DeploySvcListDeploymentsResponse": DeploySvcListDeploymentsResponse,
    "DeploySvcResourceLimits": DeploySvcResourceLimits,
    "DeploySvcSaveDeploymentRequest": DeploySvcSaveDeploymentRequest,
    "DeploySvcTargetRegion": DeploySvcTargetRegion,
    "EmailSvcAttachment": EmailSvcAttachment,
    "EmailSvcErrorResponse": EmailSvcErrorResponse,
    "EmailSvcSendEmailRequest": EmailSvcSendEmailRequest,
    "EmailSvcSendEmailResponse": EmailSvcSendEmailResponse,
    "Events200Response": Events200Response,
    "FileSvcDownload": FileSvcDownload,
    "FileSvcDownloadFileRequest": FileSvcDownloadFileRequest,
    "FileSvcDownloadsResponse": FileSvcDownloadsResponse,
    "FileSvcErrorResponse": FileSvcErrorResponse,
    "FileSvcGetDownloadResponse": FileSvcGetDownloadResponse,
    "FileSvcListUploadsRequest": FileSvcListUploadsRequest,
    "FileSvcListUploadsResponse": FileSvcListUploadsResponse,
    "FileSvcUpload": FileSvcUpload,
    "FileSvcUploadFileResponse": FileSvcUploadFileResponse,
    "FirehoseSvcErrorResponse": FirehoseSvcErrorResponse,
    "FirehoseSvcEvent": FirehoseSvcEvent,
    "FirehoseSvcEventPublishRequest": FirehoseSvcEventPublishRequest,
    "ImageSvcErrorResponse": ImageSvcErrorResponse,
    "ModelSvcArchitectures": ModelSvcArchitectures,
    "ModelSvcAsset": ModelSvcAsset,
    "ModelSvcContainer": ModelSvcContainer,
    "ModelSvcCudaParameters": ModelSvcCudaParameters,
    "ModelSvcDefaultParameters": ModelSvcDefaultParameters,
    "ModelSvcEnvVar": ModelSvcEnvVar,
    "ModelSvcErrorResponse": ModelSvcErrorResponse,
    "ModelSvcGetModelResponse": ModelSvcGetModelResponse,
    "ModelSvcKeep": ModelSvcKeep,
    "ModelSvcListModelsResponse": ModelSvcListModelsResponse,
    "ModelSvcListPlatformsResponse": ModelSvcListPlatformsResponse,
    "ModelSvcModel": ModelSvcModel,
    "ModelSvcModelStatus": ModelSvcModelStatus,
    "ModelSvcPlatform": ModelSvcPlatform,
    "ModelSvcStatusResponse": ModelSvcStatusResponse,
    "PolicySvcBlocklistParameters": PolicySvcBlocklistParameters,
    "PolicySvcCheckRequest": PolicySvcCheckRequest,
    "PolicySvcCheckResponse": PolicySvcCheckResponse,
    "PolicySvcErrorResponse": PolicySvcErrorResponse,
    "PolicySvcInstance": PolicySvcInstance,
    "PolicySvcParameters": PolicySvcParameters,
    "PolicySvcRateLimitParameters": PolicySvcRateLimitParameters,
    "PolicySvcUpsertInstanceRequest": PolicySvcUpsertInstanceRequest,
    "PromptSvcEngineParameters": PromptSvcEngineParameters,
    "PromptSvcErrorResponse": PromptSvcErrorResponse,
    "PromptSvcListPromptsRequest": PromptSvcListPromptsRequest,
    "PromptSvcListPromptsResponse": PromptSvcListPromptsResponse,
    "PromptSvcLlamaCppParameters": PromptSvcLlamaCppParameters,
    "PromptSvcParameters": PromptSvcParameters,
    "PromptSvcPrompt": PromptSvcPrompt,
    "PromptSvcPromptRequest": PromptSvcPromptRequest,
    "PromptSvcPromptResponse": PromptSvcPromptResponse,
    "PromptSvcRemovePromptRequest": PromptSvcRemovePromptRequest,
    "PromptSvcStableDiffusionParameters": PromptSvcStableDiffusionParameters,
    "PromptSvcStreamChunk": PromptSvcStreamChunk,
    "PromptSvcTextToImageParameters": PromptSvcTextToImageParameters,
    "PromptSvcTextToTextParameters": PromptSvcTextToTextParameters,
    "PromptSvcTypesResponse": PromptSvcTypesResponse,
    "ProxySvcCert": ProxySvcCert,
    "ProxySvcCertInput": ProxySvcCertInput,
    "ProxySvcErrorResponse": ProxySvcErrorResponse,
    "ProxySvcListCertsRequest": ProxySvcListCertsRequest,
    "ProxySvcListCertsResponse": ProxySvcListCertsResponse,
    "ProxySvcListRoutesRequest": ProxySvcListRoutesRequest,
    "ProxySvcListRoutesResponse": ProxySvcListRoutesResponse,
    "ProxySvcRoute": ProxySvcRoute,
    "ProxySvcRouteInput": ProxySvcRouteInput,
    "ProxySvcSaveCertsRequest": ProxySvcSaveCertsRequest,
    "ProxySvcSaveRoutesRequest": ProxySvcSaveRoutesRequest,
    "ProxySvcSaveRoutesResponse": ProxySvcSaveRoutesResponse,
    "RegistrySvcAPISpec": RegistrySvcAPISpec,
    "RegistrySvcClient": RegistrySvcClient,
    "RegistrySvcDefinition": RegistrySvcDefinition,
    "RegistrySvcEnvVar": RegistrySvcEnvVar,
    "RegistrySvcErrorResponse": RegistrySvcErrorResponse,
    "RegistrySvcGPU": RegistrySvcGPU,
    "RegistrySvcImageSpec": RegistrySvcImageSpec,
    "RegistrySvcInstance": RegistrySvcInstance,
    "RegistrySvcListDefinitionsResponse": RegistrySvcListDefinitionsResponse,
    "RegistrySvcListInstancesResponse": RegistrySvcListInstancesResponse,
    "RegistrySvcListNodesRequest": RegistrySvcListNodesRequest,
    "RegistrySvcListNodesResponse": RegistrySvcListNodesResponse,
    "RegistrySvcNode": RegistrySvcNode,
    "RegistrySvcNodeSelfResponse": RegistrySvcNodeSelfResponse,
    "RegistrySvcPortMapping": RegistrySvcPortMapping,
    "RegistrySvcProcess": RegistrySvcProcess,
    "RegistrySvcRegisterInstanceRequest": RegistrySvcRegisterInstanceRequest,
    "RegistrySvcRepositorySpec": RegistrySvcRepositorySpec,
    "RegistrySvcResourceUsage": RegistrySvcResourceUsage,
    "RegistrySvcSaveDefinitionRequest": RegistrySvcSaveDefinitionRequest,
    "RegistrySvcUsage": RegistrySvcUsage,
    "SecretSvcDecryptValueRequest": SecretSvcDecryptValueRequest,
    "SecretSvcDecryptValueResponse": SecretSvcDecryptValueResponse,
    "SecretSvcEncryptValueRequest": SecretSvcEncryptValueRequest,
    "SecretSvcEncryptValueResponse": SecretSvcEncryptValueResponse,
    "SecretSvcIsSecureResponse": SecretSvcIsSecureResponse,
    "SecretSvcListSecretsRequest": SecretSvcListSecretsRequest,
    "SecretSvcListSecretsResponse": SecretSvcListSecretsResponse,
    "SecretSvcRemoveSecretsRequest": SecretSvcRemoveSecretsRequest,
    "SecretSvcSaveSecretsRequest": SecretSvcSaveSecretsRequest,
    "SecretSvcSecret": SecretSvcSecret,
    "SourceSvcCheckoutRepoRequest": SourceSvcCheckoutRepoRequest,
    "SourceSvcCheckoutRepoResponse": SourceSvcCheckoutRepoResponse,
    "SourceSvcErrorResponse": SourceSvcErrorResponse,
    "StableDiffusionTxt2ImgRequest": StableDiffusionTxt2ImgRequest,
    "UserSvcAuthToken": UserSvcAuthToken,
    "UserSvcChangePasswordRequest": UserSvcChangePasswordRequest,
    "UserSvcContact": UserSvcContact,
    "UserSvcContactInput": UserSvcContactInput,
    "UserSvcCreateUserRequest": UserSvcCreateUserRequest,
    "UserSvcEnroll": UserSvcEnroll,
    "UserSvcEnrollInput": UserSvcEnrollInput,
    "UserSvcErrorResponse": UserSvcErrorResponse,
    "UserSvcExchangeTokenRequest": UserSvcExchangeTokenRequest,
    "UserSvcExchangeTokenResponse": UserSvcExchangeTokenResponse,
    "UserSvcGetPublicKeyResponse": UserSvcGetPublicKeyResponse,
    "UserSvcHasPermissionResponse": UserSvcHasPermissionResponse,
    "UserSvcListEnrollsRequest": UserSvcListEnrollsRequest,
    "UserSvcListEnrollsResponse": UserSvcListEnrollsResponse,
    "UserSvcListOrganizationsRequest": UserSvcListOrganizationsRequest,
    "UserSvcListOrganizationsResponse": UserSvcListOrganizationsResponse,
    "UserSvcListPermissionsResponse": UserSvcListPermissionsResponse,
    "UserSvcListPermitsRequest": UserSvcListPermitsRequest,
    "UserSvcListPermitsResponse": UserSvcListPermitsResponse,
    "UserSvcListUsersRequest": UserSvcListUsersRequest,
    "UserSvcListUsersResponse": UserSvcListUsersResponse,
    "UserSvcLoginRequest": UserSvcLoginRequest,
    "UserSvcLoginResponse": UserSvcLoginResponse,
    "UserSvcOrganization": UserSvcOrganization,
    "UserSvcPermit": UserSvcPermit,
    "UserSvcPermitInput": UserSvcPermitInput,
    "UserSvcReadSelfRequest": UserSvcReadSelfRequest,
    "UserSvcReadSelfResponse": UserSvcReadSelfResponse,
    "UserSvcRefreshTokenResponse": UserSvcRefreshTokenResponse,
    "UserSvcRegisterRequest": UserSvcRegisterRequest,
    "UserSvcRegisterResponse": UserSvcRegisterResponse,
    "UserSvcResetPasswordRequest": UserSvcResetPasswordRequest,
    "UserSvcRevokeTokensRequest": UserSvcRevokeTokensRequest,
    "UserSvcSaveEnrollsRequest": UserSvcSaveEnrollsRequest,
    "UserSvcSaveEnrollsResponse": UserSvcSaveEnrollsResponse,
    "UserSvcSaveOrganizationRequest": UserSvcSaveOrganizationRequest,
    "UserSvcSaveOrganizationResponse": UserSvcSaveOrganizationResponse,
    "UserSvcSavePermitsRequest": UserSvcSavePermitsRequest,
    "UserSvcSaveSelfRequest": UserSvcSaveSelfRequest,
    "UserSvcSaveUserRequest": UserSvcSaveUserRequest,
    "UserSvcUser": UserSvcUser,
    "UserSvcUserInput": UserSvcUserInput,
    "UserSvcUserRecord": UserSvcUserRecord,
};
// Check if a string starts with another string without using es6 features
function startsWith(str, match) {
    return str.substring(0, match.length) === match;
}
// Check if a string ends with another string without using es6 features
function endsWith(str, match) {
    return str.length >= match.length && str.substring(str.length - match.length) === match;
}
const nullableSuffix = " | null";
const optionalSuffix = " | undefined";
const arrayPrefix = "Array<";
const arraySuffix = ">";
const mapPrefix = "{ [key: string]: ";
const mapSuffix = "; }";
class ObjectSerializer {
    static findCorrectType(data, expectedType) {
        if (data == undefined) {
            return expectedType;
        }
        else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        }
        else if (expectedType === "Date") {
            return expectedType;
        }
        else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }
            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }
            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            }
            else {
                if (data[discriminatorProperty]) {
                    var discriminatorType = data[discriminatorProperty];
                    if (typeMap[discriminatorType]) {
                        return discriminatorType; // use the type given in the discriminator
                    }
                    else {
                        return expectedType; // discriminator did not map to a type
                    }
                }
                else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }
    static serialize(data, type) {
        if (data == undefined) {
            return data;
        }
        else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        }
        else if (endsWith(type, nullableSuffix)) {
            let subType = type.slice(0, -nullableSuffix.length); // Type | null => Type
            return ObjectSerializer.serialize(data, subType);
        }
        else if (endsWith(type, optionalSuffix)) {
            let subType = type.slice(0, -optionalSuffix.length); // Type | undefined => Type
            return ObjectSerializer.serialize(data, subType);
        }
        else if (startsWith(type, arrayPrefix)) {
            let subType = type.slice(arrayPrefix.length, -arraySuffix.length); // Array<Type> => Type
            let transformedData = [];
            for (let index = 0; index < data.length; index++) {
                let datum = data[index];
                transformedData.push(ObjectSerializer.serialize(datum, subType));
            }
            return transformedData;
        }
        else if (startsWith(type, mapPrefix)) {
            let subType = type.slice(mapPrefix.length, -mapSuffix.length); // { [key: string]: Type; } => Type
            let transformedData = {};
            for (let key in data) {
                transformedData[key] = ObjectSerializer.serialize(data[key], subType);
            }
            return transformedData;
        }
        else if (type === "Date") {
            return data.toISOString();
        }
        else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }
            // Get the actual type of this object
            type = this.findCorrectType(data, type);
            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance = {};
            for (let index = 0; index < attributeTypes.length; index++) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }
    static deserialize(data, type) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        }
        else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        }
        else if (endsWith(type, nullableSuffix)) {
            let subType = type.slice(0, -nullableSuffix.length); // Type | null => Type
            return ObjectSerializer.deserialize(data, subType);
        }
        else if (endsWith(type, optionalSuffix)) {
            let subType = type.slice(0, -optionalSuffix.length); // Type | undefined => Type
            return ObjectSerializer.deserialize(data, subType);
        }
        else if (startsWith(type, arrayPrefix)) {
            let subType = type.slice(arrayPrefix.length, -arraySuffix.length); // Array<Type> => Type
            let transformedData = [];
            for (let index = 0; index < data.length; index++) {
                let datum = data[index];
                transformedData.push(ObjectSerializer.deserialize(datum, subType));
            }
            return transformedData;
        }
        else if (startsWith(type, mapPrefix)) {
            let subType = type.slice(mapPrefix.length, -mapSuffix.length); // { [key: string]: Type; } => Type
            let transformedData = {};
            for (let key in data) {
                transformedData[key] = ObjectSerializer.deserialize(data[key], subType);
            }
            return transformedData;
        }
        else if (type === "Date") {
            return new Date(data);
        }
        else {
            if (enumsMap[type]) { // is Enum
                return data;
            }
            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index = 0; index < attributeTypes.length; index++) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}
class HttpBasicAuth {
    constructor() {
        this.username = '';
        this.password = '';
    }
    applyToRequest(requestOptions) {
        requestOptions.auth = {
            username: this.username, password: this.password
        };
    }
}
class HttpBearerAuth {
    constructor() {
        this.accessToken = '';
    }
    applyToRequest(requestOptions) {
        if (requestOptions && requestOptions.headers) {
            const accessToken = typeof this.accessToken === 'function'
                ? this.accessToken()
                : this.accessToken;
            requestOptions.headers["Authorization"] = "Bearer " + accessToken;
        }
    }
}
class ApiKeyAuth {
    constructor(location, paramName) {
        this.location = location;
        this.paramName = paramName;
        this.apiKey = '';
    }
    applyToRequest(requestOptions) {
        if (this.location == "query") {
            requestOptions.qs[this.paramName] = this.apiKey;
        }
        else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
        else if (this.location == 'cookie' && requestOptions && requestOptions.headers) {
            if (requestOptions.headers['Cookie']) {
                requestOptions.headers['Cookie'] += '; ' + this.paramName + '=' + encodeURIComponent(this.apiKey);
            }
            else {
                requestOptions.headers['Cookie'] = this.paramName + '=' + encodeURIComponent(this.apiKey);
            }
        }
    }
}
class OAuth {
    constructor() {
        this.accessToken = '';
    }
    applyToRequest(requestOptions) {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}
class VoidAuth {
    constructor() {
        this.username = '';
        this.password = '';
    }
    applyToRequest(_) {
        // Do nothing
    }
}

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
let defaultBasePath$g = 'http://localhost:11337';
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
var ChatSvcApiApiKeys;
(function (ChatSvcApiApiKeys) {
    ChatSvcApiApiKeys[ChatSvcApiApiKeys["BearerAuth"] = 0] = "BearerAuth";
})(ChatSvcApiApiKeys || (ChatSvcApiApiKeys = {}));
class ChatSvcApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath$g;
        this._defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerAuth': new ApiKeyAuth('header', 'Authorization'),
        };
        this.interceptors = [];
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    set defaultHeaders(defaultHeaders) {
        this._defaultHeaders = defaultHeaders;
    }
    get defaultHeaders() {
        return this._defaultHeaders;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[ChatSvcApiApiKeys[key]].apiKey = value;
    }
    addInterceptor(interceptor) {
        this.interceptors.push(interceptor);
    }
    /**
     * Delete a specific message from a chat thread by its ID
     * @summary Delete a Message
     * @param messageId Message ID
     * @param body
     */
    deleteMessage(messageId_1, body_1) {
        return __awaiter(this, arguments, void 0, function* (messageId, body, options = { headers: {} }) {
            const localVarPath = this.basePath + '/chat-svc/message/{messageId}'
                .replace('{' + 'messageId' + '}', encodeURIComponent(String(messageId)));
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'messageId' is not null or undefined
            if (messageId === null || messageId === undefined) {
                throw new Error('Required parameter messageId was null or undefined when calling deleteMessage.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'DELETE',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(body, "object")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "{ [key: string]: any; }");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Delete a specific chat thread by its ID
     * @summary Delete a Thread
     * @param threadId Thread ID
     * @param body
     */
    deleteThread(threadId_1, body_1) {
        return __awaiter(this, arguments, void 0, function* (threadId, body, options = { headers: {} }) {
            const localVarPath = this.basePath + '/chat-svc/thread/{threadId}'
                .replace('{' + 'threadId' + '}', encodeURIComponent(String(threadId)));
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'threadId' is not null or undefined
            if (threadId === null || threadId === undefined) {
                throw new Error('Required parameter threadId was null or undefined when calling deleteThread.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'DELETE',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(body, "object")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "{ [key: string]: any; }");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Events is a dummy endpoint to display documentation about the events that this service emits.
     * @summary Events
     * @param body
     */
    events(body_1) {
        return __awaiter(this, arguments, void 0, function* (body, options = { headers: {} }) {
            const localVarPath = this.basePath + '/chat-svc/events';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'GET',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(body, "object")
            };
            let authenticationPromise = Promise.resolve();
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "Events200Response");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Fetch messages (and associated assets) for a specific chat thread.
     * @summary List Messages
     * @param chatSvcListMessagesRequest List Messages Request
     */
    listMessages(chatSvcListMessagesRequest_1) {
        return __awaiter(this, arguments, void 0, function* (chatSvcListMessagesRequest, options = { headers: {} }) {
            const localVarPath = this.basePath + '/chat-svc/messages';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'chatSvcListMessagesRequest' is not null or undefined
            if (chatSvcListMessagesRequest === null || chatSvcListMessagesRequest === undefined) {
                throw new Error('Required parameter chatSvcListMessagesRequest was null or undefined when calling listMessages.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'POST',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(chatSvcListMessagesRequest, "ChatSvcListMessagesRequest")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "ChatSvcListMessagesResponse");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Fetch all chat threads associated with a specific user
     * @summary List Threads
     * @param chatSvcListThreadsRequest List Threads Request
     */
    listThreads(chatSvcListThreadsRequest_1) {
        return __awaiter(this, arguments, void 0, function* (chatSvcListThreadsRequest, options = { headers: {} }) {
            const localVarPath = this.basePath + '/chat-svc/threads';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'chatSvcListThreadsRequest' is not null or undefined
            if (chatSvcListThreadsRequest === null || chatSvcListThreadsRequest === undefined) {
                throw new Error('Required parameter chatSvcListThreadsRequest was null or undefined when calling listThreads.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'POST',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(chatSvcListThreadsRequest, "ChatSvcListThreadsRequest")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "ChatSvcListThreadsResponse");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Save a new message to a specific thread.
     * @summary Save Message
     * @param threadId Thread ID
     * @param chatSvcSaveMessageRequest Save Message Request
     */
    saveMessage(threadId_1, chatSvcSaveMessageRequest_1) {
        return __awaiter(this, arguments, void 0, function* (threadId, chatSvcSaveMessageRequest, options = { headers: {} }) {
            const localVarPath = this.basePath + '/chat-svc/thread/{threadId}/message'
                .replace('{' + 'threadId' + '}', encodeURIComponent(String(threadId)));
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'threadId' is not null or undefined
            if (threadId === null || threadId === undefined) {
                throw new Error('Required parameter threadId was null or undefined when calling saveMessage.');
            }
            // verify required parameter 'chatSvcSaveMessageRequest' is not null or undefined
            if (chatSvcSaveMessageRequest === null || chatSvcSaveMessageRequest === undefined) {
                throw new Error('Required parameter chatSvcSaveMessageRequest was null or undefined when calling saveMessage.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'POST',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(chatSvcSaveMessageRequest, "ChatSvcSaveMessageRequest")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "{ [key: string]: any; }");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Create or update a chat thread. Requires the `chat-svc:thread:edit` permission.
     * @summary Save Thread
     * @param chatSvcSaveThreadRequest Save Thread Request
     */
    saveThread(chatSvcSaveThreadRequest_1) {
        return __awaiter(this, arguments, void 0, function* (chatSvcSaveThreadRequest, options = { headers: {} }) {
            const localVarPath = this.basePath + '/chat-svc/thread';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'chatSvcSaveThreadRequest' is not null or undefined
            if (chatSvcSaveThreadRequest === null || chatSvcSaveThreadRequest === undefined) {
                throw new Error('Required parameter chatSvcSaveThreadRequest was null or undefined when calling saveThread.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'POST',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(chatSvcSaveThreadRequest, "ChatSvcSaveThreadRequest")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "ChatSvcSaveThreadResponse");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
}

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
let defaultBasePath$f = 'http://localhost:11337';
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
var ConfigSvcApiApiKeys;
(function (ConfigSvcApiApiKeys) {
    ConfigSvcApiApiKeys[ConfigSvcApiApiKeys["BearerAuth"] = 0] = "BearerAuth";
})(ConfigSvcApiApiKeys || (ConfigSvcApiApiKeys = {}));
class ConfigSvcApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath$f;
        this._defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerAuth': new ApiKeyAuth('header', 'Authorization'),
        };
        this.interceptors = [];
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    set defaultHeaders(defaultHeaders) {
        this._defaultHeaders = defaultHeaders;
    }
    get defaultHeaders() {
        return this._defaultHeaders;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[ConfigSvcApiApiKeys[key]].apiKey = value;
    }
    addInterceptor(interceptor) {
        this.interceptors.push(interceptor);
    }
    /**
     * Retrieves the current configurations for a specified app. Since any user can save configurations, it is strongly advised that you supply a list of owners to filter on. If no app is specified, the default \"unnamed\" app is used. This is a public endpoint and does not require authentication. Configuration data is non-sensitive. For sensitive data, refer to the Secret Service.  Configurations are used to control frontend behavior, A/B testing, feature flags, and other non-sensitive settings.
     * @summary List Configs
     * @param configSvcListConfigsRequest List Configs Request
     */
    listConfigs(configSvcListConfigsRequest_1) {
        return __awaiter(this, arguments, void 0, function* (configSvcListConfigsRequest, options = { headers: {} }) {
            const localVarPath = this.basePath + '/config-svc/configs';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'POST',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(configSvcListConfigsRequest, "ConfigSvcListConfigsRequest")
            };
            let authenticationPromise = Promise.resolve();
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "ConfigSvcListConfigsResponse");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Save the provided configuration to the server. The app from the caller\'s token is used to determine which app the config belongs to. The caller\'s camelCased slug (e.g., \"test-user-slug\" becomes \"testUserSlug\") is used as the config key automatically, except for users who have the \"config-svc:config:edit-on-behalf\" permission (admins), who can specify any key they want. Admins (users with the \"config-svc:config:edit-on-behalf\" permission) can also provide an \"app\" field in the request body to specify which app the config belongs to, while non-admin users cannot specify the \"app\" field, the app associated with their token will be used.  The save performs a deep merge, that is: - Nested objects are recursively merged rather than replaced. - If a field exists in both the existing and the incoming config and both values are objects, their contents are merged. - If a field exists in both but one or both values are not objects (e.g., string, number, array), the incoming value replaces the existing one. - Fields present only in the incoming config are added. - Fields present only in the existing config are preserved. - Top-level and nested merges follow the same rules.
     * @summary Save Config
     * @param configSvcSaveConfigRequest Save Config Request
     */
    saveConfig(configSvcSaveConfigRequest_1) {
        return __awaiter(this, arguments, void 0, function* (configSvcSaveConfigRequest, options = { headers: {} }) {
            const localVarPath = this.basePath + '/config-svc/config';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'configSvcSaveConfigRequest' is not null or undefined
            if (configSvcSaveConfigRequest === null || configSvcSaveConfigRequest === undefined) {
                throw new Error('Required parameter configSvcSaveConfigRequest was null or undefined when calling saveConfig.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'PUT',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(configSvcSaveConfigRequest, "ConfigSvcSaveConfigRequest")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "object");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
}

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
let defaultBasePath$e = 'http://localhost:11337';
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
var ContainerSvcApiApiKeys;
(function (ContainerSvcApiApiKeys) {
    ContainerSvcApiApiKeys[ContainerSvcApiApiKeys["BearerAuth"] = 0] = "BearerAuth";
})(ContainerSvcApiApiKeys || (ContainerSvcApiApiKeys = {}));
class ContainerSvcApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath$e;
        this._defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerAuth': new ApiKeyAuth('header', 'Authorization'),
        };
        this.interceptors = [];
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    set defaultHeaders(defaultHeaders) {
        this._defaultHeaders = defaultHeaders;
    }
    get defaultHeaders() {
        return this._defaultHeaders;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[ContainerSvcApiApiKeys[key]].apiKey = value;
    }
    addInterceptor(interceptor) {
        this.interceptors.push(interceptor);
    }
    /**
     * Builds a Docker image with the specified parameters.  Requires the `container-svc:image:build` permission.
     * @summary Build an Image
     * @param containerSvcBuildImageRequest Build Image Request
     */
    buildImage(containerSvcBuildImageRequest_1) {
        return __awaiter(this, arguments, void 0, function* (containerSvcBuildImageRequest, options = { headers: {} }) {
            const localVarPath = this.basePath + '/container-svc/image';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'containerSvcBuildImageRequest' is not null or undefined
            if (containerSvcBuildImageRequest === null || containerSvcBuildImageRequest === undefined) {
                throw new Error('Required parameter containerSvcBuildImageRequest was null or undefined when calling buildImage.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'PUT',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(containerSvcBuildImageRequest, "ContainerSvcBuildImageRequest")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "object");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Retrieve detailed information about the availability and status of container daemons on the node.
     * @summary Get Container Daemon Information
     * @param body
     */
    containerDaemonInfo(body_1) {
        return __awaiter(this, arguments, void 0, function* (body, options = { headers: {} }) {
            const localVarPath = this.basePath + '/container-svc/daemon/info';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'GET',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(body, "object")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "ContainerSvcDaemonInfoResponse");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Check if a Docker container is running, identified by hash or name.
     * @summary Check If a Container Is Running
     * @param hash Container Hash
     * @param name Container Name
     * @param body
     */
    containerIsRunning(hash_1, name_1, body_1) {
        return __awaiter(this, arguments, void 0, function* (hash, name, body, options = { headers: {} }) {
            const localVarPath = this.basePath + '/container-svc/container/is-running';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            if (hash !== undefined) {
                localVarQueryParameters['hash'] = ObjectSerializer.serialize(hash, "string");
            }
            if (name !== undefined) {
                localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "string");
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'GET',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(body, "object")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "ContainerSvcContainerIsRunningResponse");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Get a summary of the Docker container identified by hash or name, limited to a specified number of lines.
     * @summary Get Container Summary
     * @param hash Container Hash
     * @param name Container Name
     * @param lines Number of Lines
     * @param body
     */
    containerSummary(hash_1, name_1, lines_1, body_1) {
        return __awaiter(this, arguments, void 0, function* (hash, name, lines, body, options = { headers: {} }) {
            const localVarPath = this.basePath + '/container-svc/container/summary';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            if (hash !== undefined) {
                localVarQueryParameters['hash'] = ObjectSerializer.serialize(hash, "string");
            }
            if (name !== undefined) {
                localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "string");
            }
            if (lines !== undefined) {
                localVarQueryParameters['lines'] = ObjectSerializer.serialize(lines, "number");
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'GET',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(body, "object")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "ContainerSvcGetContainerSummaryResponse");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Retrieve information about the Container host
     * @summary Get Container Host
     * @param body
     */
    getHost(body_1) {
        return __awaiter(this, arguments, void 0, function* (body, options = { headers: {} }) {
            const localVarPath = this.basePath + '/container-svc/host';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'GET',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(body, "object")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "ContainerSvcGetHostResponse");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Check if an image exists on in the container registry and is pullable.
     * @summary Check if Container Image is Pullable
     * @param imageName Image name
     * @param body
     */
    imagePullable(imageName_1, body_1) {
        return __awaiter(this, arguments, void 0, function* (imageName, body, options = { headers: {} }) {
            const localVarPath = this.basePath + '/container-svc/image/{imageName}/pullable'
                .replace('{' + 'imageName' + '}', encodeURIComponent(String(imageName)));
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'imageName' is not null or undefined
            if (imageName === null || imageName === undefined) {
                throw new Error('Required parameter imageName was null or undefined when calling imagePullable.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'GET',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(body, "object")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "ContainerSvcImagePullableResponse");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * List Container logs.  Requires the `container-svc:log:view` permission.
     * @summary List Logs
     * @param containerSvcListLogsRequest List Logs Request
     */
    listContainerLogs(containerSvcListLogsRequest_1) {
        return __awaiter(this, arguments, void 0, function* (containerSvcListLogsRequest, options = { headers: {} }) {
            const localVarPath = this.basePath + '/container-svc/logs';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'containerSvcListLogsRequest' is not null or undefined
            if (containerSvcListLogsRequest === null || containerSvcListLogsRequest === undefined) {
                throw new Error('Required parameter containerSvcListLogsRequest was null or undefined when calling listContainerLogs.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'POST',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(containerSvcListLogsRequest, "ContainerSvcListLogsRequest")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "ContainerSvcListLogsResponse");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * List containers.  Requires the `container-svc:container:view` permission.
     * @summary List Containers
     * @param containerSvcListContainersRequest List Containers Request
     */
    listContainers(containerSvcListContainersRequest_1) {
        return __awaiter(this, arguments, void 0, function* (containerSvcListContainersRequest, options = { headers: {} }) {
            const localVarPath = this.basePath + '/container-svc/containers';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'containerSvcListContainersRequest' is not null or undefined
            if (containerSvcListContainersRequest === null || containerSvcListContainersRequest === undefined) {
                throw new Error('Required parameter containerSvcListContainersRequest was null or undefined when calling listContainers.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'POST',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(containerSvcListContainersRequest, "ContainerSvcListContainersRequest")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "ContainerSvcListContainersResponse");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Runs a Docker container with the specified parameters.  Requires the `container-svc:container:run` permission.
     * @summary Run a Container
     * @param containerSvcRunContainerRequest Run Container Request
     */
    runContainer(containerSvcRunContainerRequest_1) {
        return __awaiter(this, arguments, void 0, function* (containerSvcRunContainerRequest, options = { headers: {} }) {
            const localVarPath = this.basePath + '/container-svc/container';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'containerSvcRunContainerRequest' is not null or undefined
            if (containerSvcRunContainerRequest === null || containerSvcRunContainerRequest === undefined) {
                throw new Error('Required parameter containerSvcRunContainerRequest was null or undefined when calling runContainer.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'PUT',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(containerSvcRunContainerRequest, "ContainerSvcRunContainerRequest")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "ContainerSvcRunContainerResponse");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Stops a Docker container with the specified parameters.  Requires the `container-svc:container:stop` permission.
     * @summary Stop a Container
     * @param containerSvcStopContainerRequest Stop Container Request
     */
    stopContainer(containerSvcStopContainerRequest_1) {
        return __awaiter(this, arguments, void 0, function* (containerSvcStopContainerRequest, options = { headers: {} }) {
            const localVarPath = this.basePath + '/container-svc/container/stop';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'containerSvcStopContainerRequest' is not null or undefined
            if (containerSvcStopContainerRequest === null || containerSvcStopContainerRequest === undefined) {
                throw new Error('Required parameter containerSvcStopContainerRequest was null or undefined when calling stopContainer.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'PUT',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(containerSvcStopContainerRequest, "ContainerSvcStopContainerRequest")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "object");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
}

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
let defaultBasePath$d = 'http://localhost:11337';
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
var DataSvcApiApiKeys;
(function (DataSvcApiApiKeys) {
    DataSvcApiApiKeys[DataSvcApiApiKeys["BearerAuth"] = 0] = "BearerAuth";
})(DataSvcApiApiKeys || (DataSvcApiApiKeys = {}));
class DataSvcApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath$d;
        this._defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerAuth': new ApiKeyAuth('header', 'Authorization'),
        };
        this.interceptors = [];
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    set defaultHeaders(defaultHeaders) {
        this._defaultHeaders = defaultHeaders;
    }
    get defaultHeaders() {
        return this._defaultHeaders;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[DataSvcApiApiKeys[key]].apiKey = value;
    }
    addInterceptor(interceptor) {
        this.interceptors.push(interceptor);
    }
    /**
     * Creates a new object with the provided details. Requires authorization and user authentication.
     * @summary Create a Generic Object
     * @param dataSvcCreateObjectRequest Create request payload
     */
    createObject(dataSvcCreateObjectRequest_1) {
        return __awaiter(this, arguments, void 0, function* (dataSvcCreateObjectRequest, options = { headers: {} }) {
            const localVarPath = this.basePath + '/data-svc/object';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'dataSvcCreateObjectRequest' is not null or undefined
            if (dataSvcCreateObjectRequest === null || dataSvcCreateObjectRequest === undefined) {
                throw new Error('Required parameter dataSvcCreateObjectRequest was null or undefined when calling createObject.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'POST',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(dataSvcCreateObjectRequest, "DataSvcCreateObjectRequest")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "DataSvcCreateObjectResponse");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Deletes all objects matchin the provided filters.
     * @summary Delete Objects
     * @param dataSvcDeleteObjectRequest Delete request payload
     */
    deleteObjects(dataSvcDeleteObjectRequest_1) {
        return __awaiter(this, arguments, void 0, function* (dataSvcDeleteObjectRequest, options = { headers: {} }) {
            const localVarPath = this.basePath + '/data-svc/objects/delete';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'dataSvcDeleteObjectRequest' is not null or undefined
            if (dataSvcDeleteObjectRequest === null || dataSvcDeleteObjectRequest === undefined) {
                throw new Error('Required parameter dataSvcDeleteObjectRequest was null or undefined when calling deleteObjects.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'POST',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(dataSvcDeleteObjectRequest, "DataSvcDeleteObjectRequest")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "object");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Retrieves objects from a specified table based on search criteria. Requires authorization and user authentication.   Use helper functions in your respective client library such as condition constructors (`equal`, `contains`, `startsWith`) and field selectors (`field`, `fields`, `id`) for easier access.
     * @summary Query Objects
     * @param dataSvcQueryRequest Query Request
     */
    queryObjects(dataSvcQueryRequest_1) {
        return __awaiter(this, arguments, void 0, function* (dataSvcQueryRequest, options = { headers: {} }) {
            const localVarPath = this.basePath + '/data-svc/objects';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'POST',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(dataSvcQueryRequest, "DataSvcQueryRequest")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "DataSvcQueryResponse");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Update fields of objects that match the given filters using the provided object. Any fields not included in the incoming object will remain unchanged.
     * @summary Update Objects
     * @param dataSvcUpdateObjectsRequest Update request payload
     */
    updateObjects(dataSvcUpdateObjectsRequest_1) {
        return __awaiter(this, arguments, void 0, function* (dataSvcUpdateObjectsRequest, options = { headers: {} }) {
            const localVarPath = this.basePath + '/data-svc/objects/update';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'dataSvcUpdateObjectsRequest' is not null or undefined
            if (dataSvcUpdateObjectsRequest === null || dataSvcUpdateObjectsRequest === undefined) {
                throw new Error('Required parameter dataSvcUpdateObjectsRequest was null or undefined when calling updateObjects.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'POST',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(dataSvcUpdateObjectsRequest, "DataSvcUpdateObjectsRequest")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "object");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Creates a new dynamic object or updates an existing one based on the provided data. Requires authorization and user authentication.
     * @summary Upsert a Generic Object
     * @param objectId Object ID
     * @param dataSvcUpsertObjectRequest Upsert request payload
     */
    upsertObject(objectId_1, dataSvcUpsertObjectRequest_1) {
        return __awaiter(this, arguments, void 0, function* (objectId, dataSvcUpsertObjectRequest, options = { headers: {} }) {
            const localVarPath = this.basePath + '/data-svc/object/{objectId}'
                .replace('{' + 'objectId' + '}', encodeURIComponent(String(objectId)));
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'objectId' is not null or undefined
            if (objectId === null || objectId === undefined) {
                throw new Error('Required parameter objectId was null or undefined when calling upsertObject.');
            }
            // verify required parameter 'dataSvcUpsertObjectRequest' is not null or undefined
            if (dataSvcUpsertObjectRequest === null || dataSvcUpsertObjectRequest === undefined) {
                throw new Error('Required parameter dataSvcUpsertObjectRequest was null or undefined when calling upsertObject.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'PUT',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(dataSvcUpsertObjectRequest, "DataSvcUpsertObjectRequest")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "DataSvcUpsertObjectResponse");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Upserts objects by ids.
     * @summary Upsert Objects
     * @param dataSvcUpsertObjectRequest Upsert request payload
     */
    upsertObjects(dataSvcUpsertObjectRequest_1) {
        return __awaiter(this, arguments, void 0, function* (dataSvcUpsertObjectRequest, options = { headers: {} }) {
            const localVarPath = this.basePath + '/data-svc/objects/upsert';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'dataSvcUpsertObjectRequest' is not null or undefined
            if (dataSvcUpsertObjectRequest === null || dataSvcUpsertObjectRequest === undefined) {
                throw new Error('Required parameter dataSvcUpsertObjectRequest was null or undefined when calling upsertObjects.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'PUT',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(dataSvcUpsertObjectRequest, "DataSvcUpsertObjectRequest")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "DataSvcUpsertObjectResponse");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
}

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
let defaultBasePath$c = 'http://localhost:11337';
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
var DeploySvcApiApiKeys;
(function (DeploySvcApiApiKeys) {
    DeploySvcApiApiKeys[DeploySvcApiApiKeys["BearerAuth"] = 0] = "BearerAuth";
})(DeploySvcApiApiKeys || (DeploySvcApiApiKeys = {}));
class DeploySvcApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath$c;
        this._defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerAuth': new ApiKeyAuth('header', 'Authorization'),
        };
        this.interceptors = [];
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    set defaultHeaders(defaultHeaders) {
        this._defaultHeaders = defaultHeaders;
    }
    get defaultHeaders() {
        return this._defaultHeaders;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[DeploySvcApiApiKeys[key]].apiKey = value;
    }
    addInterceptor(interceptor) {
        this.interceptors.push(interceptor);
    }
    /**
     * Delete a deployment.
     * @summary Delete Deployment
     * @param deploySvcDeleteDeploymentRequest Delete Deploys Request
     */
    deleteDeployment(deploySvcDeleteDeploymentRequest_1) {
        return __awaiter(this, arguments, void 0, function* (deploySvcDeleteDeploymentRequest, options = { headers: {} }) {
            const localVarPath = this.basePath + '/deploy-svc/deployment';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'DELETE',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(deploySvcDeleteDeploymentRequest, "DeploySvcDeleteDeploymentRequest")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "object");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Retrieve a list of deployments.
     * @summary List Deployments
     * @param body List Deploys Request
     */
    listDeployments(body_1) {
        return __awaiter(this, arguments, void 0, function* (body, options = { headers: {} }) {
            const localVarPath = this.basePath + '/deploy-svc/deployments';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'POST',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(body, "object")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "DeploySvcListDeploymentsResponse");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Save a deployment.
     * @summary Save Deployment
     * @param deploySvcSaveDeploymentRequest Save Deploys Request
     */
    saveDeployment(deploySvcSaveDeploymentRequest_1) {
        return __awaiter(this, arguments, void 0, function* (deploySvcSaveDeploymentRequest, options = { headers: {} }) {
            const localVarPath = this.basePath + '/deploy-svc/deployment';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'PUT',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(deploySvcSaveDeploymentRequest, "DeploySvcSaveDeploymentRequest")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "object");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
}

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
let defaultBasePath$b = 'http://localhost:11337';
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
var EmailSvcApiApiKeys;
(function (EmailSvcApiApiKeys) {
    EmailSvcApiApiKeys[EmailSvcApiApiKeys["BearerAuth"] = 0] = "BearerAuth";
})(EmailSvcApiApiKeys || (EmailSvcApiApiKeys = {}));
class EmailSvcApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath$b;
        this._defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerAuth': new ApiKeyAuth('header', 'Authorization'),
        };
        this.interceptors = [];
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    set defaultHeaders(defaultHeaders) {
        this._defaultHeaders = defaultHeaders;
    }
    get defaultHeaders() {
        return this._defaultHeaders;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[EmailSvcApiApiKeys[key]].apiKey = value;
    }
    addInterceptor(interceptor) {
        this.interceptors.push(interceptor);
    }
    /**
     * Sends an email with optional attachments via a supported email provider.  Currently, only SendGrid is supported. Additional providers may be added in the future.  Required secrets from the Secret Svc for SendGrid: - `sender-email`: Sender\'s email address. - `sender-name`: Sender\'s display name. - `sendgrid-api-key`: API key for SendGrid.
     * @summary Send an Email
     * @param emailSvcSendEmailRequest Send Email Request
     */
    sendEmail(emailSvcSendEmailRequest_1) {
        return __awaiter(this, arguments, void 0, function* (emailSvcSendEmailRequest, options = { headers: {} }) {
            const localVarPath = this.basePath + '/email-svc/email';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'emailSvcSendEmailRequest' is not null or undefined
            if (emailSvcSendEmailRequest === null || emailSvcSendEmailRequest === undefined) {
                throw new Error('Required parameter emailSvcSendEmailRequest was null or undefined when calling sendEmail.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'POST',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(emailSvcSendEmailRequest, "EmailSvcSendEmailRequest")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "EmailSvcSendEmailResponse");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
}

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
let defaultBasePath$a = 'http://localhost:11337';
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
var FileSvcApiApiKeys;
(function (FileSvcApiApiKeys) {
    FileSvcApiApiKeys[FileSvcApiApiKeys["BearerAuth"] = 0] = "BearerAuth";
})(FileSvcApiApiKeys || (FileSvcApiApiKeys = {}));
class FileSvcApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath$a;
        this._defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerAuth': new ApiKeyAuth('header', 'Authorization'),
        };
        this.interceptors = [];
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    set defaultHeaders(defaultHeaders) {
        this._defaultHeaders = defaultHeaders;
    }
    get defaultHeaders() {
        return this._defaultHeaders;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[FileSvcApiApiKeys[key]].apiKey = value;
    }
    addInterceptor(interceptor) {
        this.interceptors.push(interceptor);
    }
    /**
     * Start or resume the download for a specified URL.  Requires the `file-svc:download:create` permission.
     * @summary Download a File
     * @param fileSvcDownloadFileRequest Download Request
     */
    downloadFile(fileSvcDownloadFileRequest_1) {
        return __awaiter(this, arguments, void 0, function* (fileSvcDownloadFileRequest, options = { headers: {} }) {
            const localVarPath = this.basePath + '/file-svc/download';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'fileSvcDownloadFileRequest' is not null or undefined
            if (fileSvcDownloadFileRequest === null || fileSvcDownloadFileRequest === undefined) {
                throw new Error('Required parameter fileSvcDownloadFileRequest was null or undefined when calling downloadFile.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'PUT',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(fileSvcDownloadFileRequest, "FileSvcDownloadFileRequest")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "{ [key: string]: any; }");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Get a download by URL.  Requires the `file-svc:download:view` permission.
     * @summary Get a Download
     * @param url url
     * @param body
     */
    getDownload(url_1, body_1) {
        return __awaiter(this, arguments, void 0, function* (url, body, options = { headers: {} }) {
            const localVarPath = this.basePath + '/file-svc/download/{url}'
                .replace('{' + 'url' + '}', encodeURIComponent(String(url)));
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'url' is not null or undefined
            if (url === null || url === undefined) {
                throw new Error('Required parameter url was null or undefined when calling getDownload.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'GET',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(body, "object")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "FileSvcGetDownloadResponse");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * List download details.  Requires the `file-svc:download:view` permission.
     * @summary List Downloads
     * @param body
     */
    listDownloads(body_1) {
        return __awaiter(this, arguments, void 0, function* (body, options = { headers: {} }) {
            const localVarPath = this.basePath + '/file-svc/downloads';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'POST',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(body, "object")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "FileSvcDownloadsResponse");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Lists uploaded files, returning only metadata about each upload. To retrieve file content, use the `Serve an Uploaded File` endpoint, which serves a single file per request. Note: Retrieving the contents of multiple files in a single request is not supported currently.  Requires the `file-svc:upload:view` permission.
     * @summary List Uploads
     * @param fileSvcListUploadsRequest List Uploads Request
     */
    listUploads(fileSvcListUploadsRequest_1) {
        return __awaiter(this, arguments, void 0, function* (fileSvcListUploadsRequest, options = { headers: {} }) {
            const localVarPath = this.basePath + '/file-svc/uploads';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'POST',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(fileSvcListUploadsRequest, "FileSvcListUploadsRequest")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "FileSvcListUploadsResponse");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Pause a download that is currently in progress.  Requires the `file-svc:download:edit` permission.
     * @summary Pause a Download
     * @param url Download URL
     * @param body
     */
    pauseDownload(url_1, body_1) {
        return __awaiter(this, arguments, void 0, function* (url, body, options = { headers: {} }) {
            const localVarPath = this.basePath + '/file-svc/download/{url}/pause'
                .replace('{' + 'url' + '}', encodeURIComponent(String(url)));
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'url' is not null or undefined
            if (url === null || url === undefined) {
                throw new Error('Required parameter url was null or undefined when calling pauseDownload.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'PUT',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(body, "object")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "{ [key: string]: any; }");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Serves a previously downloaded file based on its URL.
     * @summary Serve a Downloaded file
     * @param url URL of the file. Even after downloading, the file is still referenced by its original internet URL.
     */
    serveDownload(url_1) {
        return __awaiter(this, arguments, void 0, function* (url, options = { headers: {} }) {
            const localVarPath = this.basePath + '/file-svc/serve/download/{url}'
                .replace('{' + 'url' + '}', encodeURIComponent(String(url)));
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json', 'application/octet-stream'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'url' is not null or undefined
            if (url === null || url === undefined) {
                throw new Error('Required parameter url was null or undefined when calling serveDownload.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'GET',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
            };
            let authenticationPromise = Promise.resolve();
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "RequestFile");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Retrieves and serves a previously uploaded file using its File ID. Note: The `ID` and `FileID` fields of an upload are different. - `FileID` is a unique identifier for the file itself. - `ID` is a unique identifier for a specific replica of the file. Since 1Backend is a distributed system, files can be replicated across multiple nodes. This means each uploaded file may have multiple records with the same `FileID` but different `ID`s.
     * @summary Serve an Uploaded File
     * @param fileId FileID uniquely identifies the file itself (not an ID, which represents a specific replica)
     * @param body
     */
    serveUpload(fileId_1, body_1) {
        return __awaiter(this, arguments, void 0, function* (fileId, body, options = { headers: {} }) {
            const localVarPath = this.basePath + '/file-svc/serve/upload/{fileId}'
                .replace('{' + 'fileId' + '}', encodeURIComponent(String(fileId)));
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json', 'application/octet-stream'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'fileId' is not null or undefined
            if (fileId === null || fileId === undefined) {
                throw new Error('Required parameter fileId was null or undefined when calling serveUpload.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'GET',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(body, "object")
            };
            let authenticationPromise = Promise.resolve();
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "RequestFile");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Uploads a file to the server. Currently if using the clients only one file can be uploaded at a time due to this bug https://github.com/OpenAPITools/openapi-generator/issues/11341 Once that is fixed we should have an `PUT /file-svc/uploads`/uploadFiles (note the plural) endpoints. In reality the endpoint \"unofficially\" supports multiple files. YMMV.  Requires the `file-svc:upload:create` permission.
     * @summary Upload a File
     */
    uploadFile() {
        return __awaiter(this, arguments, void 0, function* (options = { headers: {} }) {
            const localVarPath = this.basePath + '/file-svc/upload';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'PUT',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "FileSvcUploadFileResponse");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
}

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
let defaultBasePath$9 = 'http://localhost:11337';
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
var FirehoseSvcApiApiKeys;
(function (FirehoseSvcApiApiKeys) {
    FirehoseSvcApiApiKeys[FirehoseSvcApiApiKeys["BearerAuth"] = 0] = "BearerAuth";
})(FirehoseSvcApiApiKeys || (FirehoseSvcApiApiKeys = {}));
class FirehoseSvcApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath$9;
        this._defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerAuth': new ApiKeyAuth('header', 'Authorization'),
        };
        this.interceptors = [];
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    set defaultHeaders(defaultHeaders) {
        this._defaultHeaders = defaultHeaders;
    }
    get defaultHeaders() {
        return this._defaultHeaders;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[FirehoseSvcApiApiKeys[key]].apiKey = value;
    }
    addInterceptor(interceptor) {
        this.interceptors.push(interceptor);
    }
    /**
     * Publishes an event to the firehose service after authorization check
     * @summary Publish an Event
     * @param firehoseSvcEventPublishRequest Event to publish
     */
    publishEvent(firehoseSvcEventPublishRequest_1) {
        return __awaiter(this, arguments, void 0, function* (firehoseSvcEventPublishRequest, options = { headers: {} }) {
            const localVarPath = this.basePath + '/firehose-svc/event';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'firehoseSvcEventPublishRequest' is not null or undefined
            if (firehoseSvcEventPublishRequest === null || firehoseSvcEventPublishRequest === undefined) {
                throw new Error('Required parameter firehoseSvcEventPublishRequest was null or undefined when calling publishEvent.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'POST',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(firehoseSvcEventPublishRequest, "FirehoseSvcEventPublishRequest")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Establish a subscription to the firehose events and accept a real time stream of them.
     * @summary Subscribe to the Event Stream
     * @param body
     */
    subscribeToEvents(body_1) {
        return __awaiter(this, arguments, void 0, function* (body, options = { headers: {} }) {
            const localVarPath = this.basePath + '/firehose-svc/events/subscribe';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json', 'text/event-stream'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'GET',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(body, "object")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "string");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
}

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
let defaultBasePath$8 = 'http://localhost:11337';
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
var ImageSvcApiApiKeys;
(function (ImageSvcApiApiKeys) {
    ImageSvcApiApiKeys[ImageSvcApiApiKeys["BearerAuth"] = 0] = "BearerAuth";
})(ImageSvcApiApiKeys || (ImageSvcApiApiKeys = {}));
class ImageSvcApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath$8;
        this._defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerAuth': new ApiKeyAuth('header', 'Authorization'),
        };
        this.interceptors = [];
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    set defaultHeaders(defaultHeaders) {
        this._defaultHeaders = defaultHeaders;
    }
    get defaultHeaders() {
        return this._defaultHeaders;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[ImageSvcApiApiKeys[key]].apiKey = value;
    }
    addInterceptor(interceptor) {
        this.interceptors.push(interceptor);
    }
    /**
     * Retrieves and serves a previously uploaded image file using its File ID.
     * @summary Serve Uploaded Image
     * @param fileId FileID uniquely identifies the file itself (not an ID, which represents a specific replica)
     * @param width Optional width to resize the image to
     * @param height Optional height to resize the image to
     * @param body
     */
    serveUploadedImage(fileId_1, width_1, height_1, body_1) {
        return __awaiter(this, arguments, void 0, function* (fileId, width, height, body, options = { headers: {} }) {
            const localVarPath = this.basePath + '/image-svc/serve/upload/{fileId}'
                .replace('{' + 'fileId' + '}', encodeURIComponent(String(fileId)));
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json', 'application/octet-stream'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'fileId' is not null or undefined
            if (fileId === null || fileId === undefined) {
                throw new Error('Required parameter fileId was null or undefined when calling serveUploadedImage.');
            }
            if (width !== undefined) {
                localVarQueryParameters['width'] = ObjectSerializer.serialize(width, "number");
            }
            if (height !== undefined) {
                localVarQueryParameters['height'] = ObjectSerializer.serialize(height, "number");
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'GET',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(body, "object")
            };
            let authenticationPromise = Promise.resolve();
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "RequestFile");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
}

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
let defaultBasePath$7 = 'http://localhost:11337';
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
var ModelSvcApiApiKeys;
(function (ModelSvcApiApiKeys) {
    ModelSvcApiApiKeys[ModelSvcApiApiKeys["BearerAuth"] = 0] = "BearerAuth";
})(ModelSvcApiApiKeys || (ModelSvcApiApiKeys = {}));
class ModelSvcApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath$7;
        this._defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerAuth': new ApiKeyAuth('header', 'Authorization'),
        };
        this.interceptors = [];
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    set defaultHeaders(defaultHeaders) {
        this._defaultHeaders = defaultHeaders;
    }
    get defaultHeaders() {
        return this._defaultHeaders;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[ModelSvcApiApiKeys[key]].apiKey = value;
    }
    addInterceptor(interceptor) {
        this.interceptors.push(interceptor);
    }
    /**
     * Retrieves the status of the default model.  Requires the `model-svc:model:view` permission.
     * @summary Get Default Model Status
     * @param body
     */
    getDefaultModelStatus(body_1) {
        return __awaiter(this, arguments, void 0, function* (body, options = { headers: {} }) {
            const localVarPath = this.basePath + '/model-svc/default-model/status';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'GET',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(body, "object")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "ModelSvcStatusResponse");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Retrieves the details of a model by its ID.  the Requires `model.view` permission.
     * @summary Get a Model
     * @param modelId Model ID
     * @param body
     */
    getModel(modelId_1, body_1) {
        return __awaiter(this, arguments, void 0, function* (modelId, body, options = { headers: {} }) {
            const localVarPath = this.basePath + '/model-svc/model/{modelId}'
                .replace('{' + 'modelId' + '}', encodeURIComponent(String(modelId)));
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'modelId' is not null or undefined
            if (modelId === null || modelId === undefined) {
                throw new Error('Required parameter modelId was null or undefined when calling getModel.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'GET',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(body, "object")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "ModelSvcGetModelResponse");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Retrieves the status of a model by ID.  Requires the `model-svc:model:view` permission.
     * @summary Get Model Status
     * @param modelId Model ID
     * @param body
     */
    getModelStatus(modelId_1, body_1) {
        return __awaiter(this, arguments, void 0, function* (modelId, body, options = { headers: {} }) {
            const localVarPath = this.basePath + '/model-svc/model/{modelId}/status'
                .replace('{' + 'modelId' + '}', encodeURIComponent(String(modelId)));
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'modelId' is not null or undefined
            if (modelId === null || modelId === undefined) {
                throw new Error('Required parameter modelId was null or undefined when calling getModelStatus.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'GET',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(body, "object")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "ModelSvcStatusResponse");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Retrieves a list of models.  Requires `model-svc:model:view` permission.
     * @summary List Models
     * @param body
     */
    listModels(body_1) {
        return __awaiter(this, arguments, void 0, function* (body, options = { headers: {} }) {
            const localVarPath = this.basePath + '/model-svc/models';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'POST',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(body, "object")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "ModelSvcListModelsResponse");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Retrieves a list of AI platforms. Eg. LlamaCpp, StableDiffusion etc.  Requires `model-svc:platform:view` permission.
     * @summary List Platforms
     * @param body
     */
    listPlatforms(body_1) {
        return __awaiter(this, arguments, void 0, function* (body, options = { headers: {} }) {
            const localVarPath = this.basePath + '/model-svc/platforms';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'POST',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(body, "object")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "ModelSvcListPlatformsResponse");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Sets a model as the default model — when prompts are sent without a Model ID, the default model is used.
     * @summary Make a Model Default
     * @param modelId Model ID
     * @param body
     */
    makeDefault(modelId_1, body_1) {
        return __awaiter(this, arguments, void 0, function* (modelId, body, options = { headers: {} }) {
            const localVarPath = this.basePath + '/model-svc/model/{modelId}/make-default'
                .replace('{' + 'modelId' + '}', encodeURIComponent(String(modelId)));
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'modelId' is not null or undefined
            if (modelId === null || modelId === undefined) {
                throw new Error('Required parameter modelId was null or undefined when calling makeDefault.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'PUT',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(body, "object")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "object");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Starts The Default Model.  Requires the `model-svc:model:create` permission.
     * @summary Start the Default Model
     * @param body
     */
    startDefaultModel(body_1) {
        return __awaiter(this, arguments, void 0, function* (body, options = { headers: {} }) {
            const localVarPath = this.basePath + '/model-svc/default-model/start';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'PUT',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(body, "object")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "object");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Starts a model by ID
     * @summary Start a Model
     * @param modelId Model ID
     * @param body
     */
    startModel(modelId_1, body_1) {
        return __awaiter(this, arguments, void 0, function* (modelId, body, options = { headers: {} }) {
            const localVarPath = this.basePath + '/model-svc/model/{modelId}/start'
                .replace('{' + 'modelId' + '}', encodeURIComponent(String(modelId)));
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'modelId' is not null or undefined
            if (modelId === null || modelId === undefined) {
                throw new Error('Required parameter modelId was null or undefined when calling startModel.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'PUT',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(body, "object")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "object");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
}

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
let defaultBasePath$6 = 'http://localhost:11337';
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
var PolicySvcApiApiKeys;
(function (PolicySvcApiApiKeys) {
    PolicySvcApiApiKeys[PolicySvcApiApiKeys["BearerAuth"] = 0] = "BearerAuth";
})(PolicySvcApiApiKeys || (PolicySvcApiApiKeys = {}));
class PolicySvcApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath$6;
        this._defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerAuth': new ApiKeyAuth('header', 'Authorization'),
        };
        this.interceptors = [];
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    set defaultHeaders(defaultHeaders) {
        this._defaultHeaders = defaultHeaders;
    }
    get defaultHeaders() {
        return this._defaultHeaders;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[PolicySvcApiApiKeys[key]].apiKey = value;
    }
    addInterceptor(interceptor) {
        this.interceptors.push(interceptor);
    }
    /**
     * Check records a resource access and returns if the access is allowed.
     * @summary Check
     * @param policySvcCheckRequest Check Request
     */
    check(policySvcCheckRequest_1) {
        return __awaiter(this, arguments, void 0, function* (policySvcCheckRequest, options = { headers: {} }) {
            const localVarPath = this.basePath + '/policy-svc/check';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'policySvcCheckRequest' is not null or undefined
            if (policySvcCheckRequest === null || policySvcCheckRequest === undefined) {
                throw new Error('Required parameter policySvcCheckRequest was null or undefined when calling check.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'POST',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(policySvcCheckRequest, "PolicySvcCheckRequest")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "PolicySvcCheckResponse");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Allows user to upsert a new policy instance based on a template.
     * @summary Upsert an Instance
     * @param instanceId Instance ID
     * @param policySvcUpsertInstanceRequest Upsert Instance Request
     */
    upsertInstance(instanceId_1, policySvcUpsertInstanceRequest_1) {
        return __awaiter(this, arguments, void 0, function* (instanceId, policySvcUpsertInstanceRequest, options = { headers: {} }) {
            const localVarPath = this.basePath + '/policy-svc/instance/{instanceId}'
                .replace('{' + 'instanceId' + '}', encodeURIComponent(String(instanceId)));
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new Error('Required parameter instanceId was null or undefined when calling upsertInstance.');
            }
            // verify required parameter 'policySvcUpsertInstanceRequest' is not null or undefined
            if (policySvcUpsertInstanceRequest === null || policySvcUpsertInstanceRequest === undefined) {
                throw new Error('Required parameter policySvcUpsertInstanceRequest was null or undefined when calling upsertInstance.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'PUT',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(policySvcUpsertInstanceRequest, "PolicySvcUpsertInstanceRequest")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "object");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
}

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
let defaultBasePath$5 = 'http://localhost:11337';
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
var PromptSvcApiApiKeys;
(function (PromptSvcApiApiKeys) {
    PromptSvcApiApiKeys[PromptSvcApiApiKeys["BearerAuth"] = 0] = "BearerAuth";
})(PromptSvcApiApiKeys || (PromptSvcApiApiKeys = {}));
class PromptSvcApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath$5;
        this._defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerAuth': new ApiKeyAuth('header', 'Authorization'),
        };
        this.interceptors = [];
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    set defaultHeaders(defaultHeaders) {
        this._defaultHeaders = defaultHeaders;
    }
    get defaultHeaders() {
        return this._defaultHeaders;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[PromptSvcApiApiKeys[key]].apiKey = value;
    }
    addInterceptor(interceptor) {
        this.interceptors.push(interceptor);
    }
    /**
     * List prompts that satisfy a query.
     * @summary List Prompts
     * @param promptSvcListPromptsRequest List Prompts Request
     */
    listPrompts(promptSvcListPromptsRequest_1) {
        return __awaiter(this, arguments, void 0, function* (promptSvcListPromptsRequest, options = { headers: {} }) {
            const localVarPath = this.basePath + '/prompt-svc/prompts';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'POST',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(promptSvcListPromptsRequest, "PromptSvcListPromptsRequest")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "PromptSvcListPromptsResponse");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Sends a prompt and waits for a response if sync is true. If sync is false, adds the prompt to the queue and returns immediately.  Prompts can be used for `text-to-text`, `text-to-image`, `image-to-image`, and other types of generation. If no model ID is specified, the default model will be used (see `Model Svc` for details). The default model may or may not support the requested generation type.  **Prompting Modes** - **High-Level Parameters**: Uses predefined parameters relevant to `text-to-image`, `image-to-image`, etc. This mode abstracts away the underlying engine (e.g., LLaMA, Stable Diffusion) and focuses on functionality. - **Engine-Specific Parameters**: Uses `engineParameters` to directly specify an AI engine, exposing all available parameters for fine-tuned control.  **Permissions Required:** `prompt-svc:prompt:create`
     * @summary Prompt an AI
     * @param promptSvcPromptRequest Add Prompt Request
     */
    prompt(promptSvcPromptRequest_1) {
        return __awaiter(this, arguments, void 0, function* (promptSvcPromptRequest, options = { headers: {} }) {
            const localVarPath = this.basePath + '/prompt-svc/prompt';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'promptSvcPromptRequest' is not null or undefined
            if (promptSvcPromptRequest === null || promptSvcPromptRequest === undefined) {
                throw new Error('Required parameter promptSvcPromptRequest was null or undefined when calling prompt.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'POST',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(promptSvcPromptRequest, "PromptSvcPromptRequest")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "PromptSvcPromptResponse");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * The only purpose of this \"endpoint\" is to export types otherwise not appearing in the API docs. This endpoint otherwise does nothing. Do not depend on this endpoint, only its types.
     * @summary Prompt Types
     * @param body Types Request
     */
    promptTypes(body_1) {
        return __awaiter(this, arguments, void 0, function* (body, options = { headers: {} }) {
            const localVarPath = this.basePath + '/prompt-svc/types';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new Error('Required parameter body was null or undefined when calling promptTypes.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'POST',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(body, "object")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "PromptSvcTypesResponse");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Remove a prompt by ID.
     * @summary Remove Prompt
     * @param promptSvcRemovePromptRequest Remove Prompt Request
     */
    removePrompt(promptSvcRemovePromptRequest_1) {
        return __awaiter(this, arguments, void 0, function* (promptSvcRemovePromptRequest, options = { headers: {} }) {
            const localVarPath = this.basePath + '/prompt-svc/remove';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'promptSvcRemovePromptRequest' is not null or undefined
            if (promptSvcRemovePromptRequest === null || promptSvcRemovePromptRequest === undefined) {
                throw new Error('Required parameter promptSvcRemovePromptRequest was null or undefined when calling removePrompt.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'POST',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(promptSvcRemovePromptRequest, "PromptSvcRemovePromptRequest")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "object");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Subscribe to prompt responses by thread via Server-Sent Events (SSE). You can subscribe to threads before they are created. The streamed strings are of type `StreamChunk`, see the PromptTypes endpoint for more details.
     * @summary Subscribe to Prompt Responses by Thread
     * @param threadId Thread ID
     */
    subscribeToPromptResponses(threadId_1) {
        return __awaiter(this, arguments, void 0, function* (threadId, options = { headers: {} }) {
            const localVarPath = this.basePath + '/prompt-svc/prompts/{threadId}/responses/subscribe'
                .replace('{' + 'threadId' + '}', encodeURIComponent(String(threadId)));
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'threadId' is not null or undefined
            if (threadId === null || threadId === undefined) {
                throw new Error('Required parameter threadId was null or undefined when calling subscribeToPromptResponses.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'GET',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "string");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
}

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
let defaultBasePath$4 = 'http://localhost:11337';
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
var ProxySvcApiApiKeys;
(function (ProxySvcApiApiKeys) {
    ProxySvcApiApiKeys[ProxySvcApiApiKeys["BearerAuth"] = 0] = "BearerAuth";
})(ProxySvcApiApiKeys || (ProxySvcApiApiKeys = {}));
class ProxySvcApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath$4;
        this._defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerAuth': new ApiKeyAuth('header', 'Authorization'),
        };
        this.interceptors = [];
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    set defaultHeaders(defaultHeaders) {
        this._defaultHeaders = defaultHeaders;
    }
    get defaultHeaders() {
        return this._defaultHeaders;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[ProxySvcApiApiKeys[key]].apiKey = value;
    }
    addInterceptor(interceptor) {
        this.interceptors.push(interceptor);
    }
    /**
     * List certs that the edge proxy will use to cert requests.
     * @summary List Certs
     * @param proxySvcListCertsRequest List Certs Request
     */
    listCerts(proxySvcListCertsRequest_1) {
        return __awaiter(this, arguments, void 0, function* (proxySvcListCertsRequest, options = { headers: {} }) {
            const localVarPath = this.basePath + '/proxy-svc/certs';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'POST',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(proxySvcListCertsRequest, "ProxySvcListCertsRequest")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "ProxySvcListCertsResponse");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * List routes that the edge proxy will use to route requests.
     * @summary List Routes
     * @param proxySvcListRoutesRequest List Routes Request
     */
    listRoutes(proxySvcListRoutesRequest_1) {
        return __awaiter(this, arguments, void 0, function* (proxySvcListRoutesRequest, options = { headers: {} }) {
            const localVarPath = this.basePath + '/proxy-svc/routes';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'POST',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(proxySvcListRoutesRequest, "ProxySvcListRoutesRequest")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "ProxySvcListRoutesResponse");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * This endpoint only exist for testing purposes. Only callable by admins Certs should be saved by the Proxy Svc and its edge proxying functionality internally, not through this endpoint.
     * @summary Save Certs
     * @param proxySvcSaveCertsRequest Save Certs Request
     */
    saveCerts(proxySvcSaveCertsRequest_1) {
        return __awaiter(this, arguments, void 0, function* (proxySvcSaveCertsRequest, options = { headers: {} }) {
            const localVarPath = this.basePath + '/proxy-svc/certs';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'proxySvcSaveCertsRequest' is not null or undefined
            if (proxySvcSaveCertsRequest === null || proxySvcSaveCertsRequest === undefined) {
                throw new Error('Required parameter proxySvcSaveCertsRequest was null or undefined when calling saveCerts.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'PUT',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(proxySvcSaveCertsRequest, "ProxySvcSaveCertsRequest")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "object");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Save routes that the edge proxy will use to route requests.
     * @summary Save Routes
     * @param proxySvcSaveRoutesRequest Save Routes Request
     */
    saveRoutes(proxySvcSaveRoutesRequest_1) {
        return __awaiter(this, arguments, void 0, function* (proxySvcSaveRoutesRequest, options = { headers: {} }) {
            const localVarPath = this.basePath + '/proxy-svc/routes';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'proxySvcSaveRoutesRequest' is not null or undefined
            if (proxySvcSaveRoutesRequest === null || proxySvcSaveRoutesRequest === undefined) {
                throw new Error('Required parameter proxySvcSaveRoutesRequest was null or undefined when calling saveRoutes.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'PUT',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(proxySvcSaveRoutesRequest, "ProxySvcSaveRoutesRequest")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "ProxySvcSaveRoutesResponse");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
}

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
let defaultBasePath$3 = 'http://localhost:11337';
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
var RegistrySvcApiApiKeys;
(function (RegistrySvcApiApiKeys) {
    RegistrySvcApiApiKeys[RegistrySvcApiApiKeys["BearerAuth"] = 0] = "BearerAuth";
})(RegistrySvcApiApiKeys || (RegistrySvcApiApiKeys = {}));
class RegistrySvcApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath$3;
        this._defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerAuth': new ApiKeyAuth('header', 'Authorization'),
        };
        this.interceptors = [];
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    set defaultHeaders(defaultHeaders) {
        this._defaultHeaders = defaultHeaders;
    }
    get defaultHeaders() {
        return this._defaultHeaders;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[RegistrySvcApiApiKeys[key]].apiKey = value;
    }
    addInterceptor(interceptor) {
        this.interceptors.push(interceptor);
    }
    /**
     * Deletes a registered definition by ID.
     * @summary Delete Definition
     * @param id Definition ID
     * @param body
     */
    deleteDefinition(id_1, body_1) {
        return __awaiter(this, arguments, void 0, function* (id, body, options = { headers: {} }) {
            const localVarPath = this.basePath + '/registry-svc/definition/{id}'
                .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new Error('Required parameter id was null or undefined when calling deleteDefinition.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'DELETE',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(body, "object")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Deletes a registered node by node URL. This endpoint is useful when a node is no longer available but it\'s still present in the database.
     * @summary Delete Node
     * @param url Node URL
     * @param body
     */
    deleteNode(url_1, body_1) {
        return __awaiter(this, arguments, void 0, function* (url, body, options = { headers: {} }) {
            const localVarPath = this.basePath + '/registry-svc/node/{url}'
                .replace('{' + 'url' + '}', encodeURIComponent(String(url)));
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'url' is not null or undefined
            if (url === null || url === undefined) {
                throw new Error('Required parameter url was null or undefined when calling deleteNode.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'DELETE',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(body, "object")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * This endpoint is used to test the server\'s response to a GET request. It echoes back the query parameters as a JSON object.
     * @summary Echo the query parameters in the response body.
     */
    echoGet() {
        return __awaiter(this, arguments, void 0, function* (options = { headers: {} }) {
            const localVarPath = this.basePath + '/registry-svc/echo';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'GET',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "{ [key: string]: any; }");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * This endpoint is used to test the server\'s response to a request. It simply echoes back the request body as a JSON response.
     * @summary Echo the request body in the response body.
     * @param body
     */
    echoPost(body_1) {
        return __awaiter(this, arguments, void 0, function* (body, options = { headers: {} }) {
            const localVarPath = this.basePath + '/registry-svc/echo';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'POST',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(body, "object")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "{ [key: string]: any; }");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * This endpoint is used to test the server\'s response to a request. It simply echoes back the request body as a JSON response.
     * @summary Echo the request body in the response body.
     * @param body
     */
    echoPut(body_1) {
        return __awaiter(this, arguments, void 0, function* (body, options = { headers: {} }) {
            const localVarPath = this.basePath + '/registry-svc/echo';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'PUT',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(body, "object")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "{ [key: string]: any; }");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Retrieves a list of all definitions or filters them by specific criteria.
     * @summary List Definitions
     * @param body
     */
    listDefinitions(body_1) {
        return __awaiter(this, arguments, void 0, function* (body, options = { headers: {} }) {
            const localVarPath = this.basePath + '/registry-svc/definitions';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'GET',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(body, "object")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "RegistrySvcListDefinitionsResponse");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Retrieves a list of all instances or filters them by specific criteria (e.g., host, IP).
     * @summary List Service Instances
     * @param scheme Scheme to filter by
     * @param ip IP to filter by
     * @param deploymentId Deployment ID to filter by
     * @param host Host to filter by
     * @param id Id to filter by
     * @param slug Slug to filter by
     * @param body
     */
    listInstances(scheme_1, ip_1, deploymentId_1, host_1, id_1, slug_1, body_1) {
        return __awaiter(this, arguments, void 0, function* (scheme, ip, deploymentId, host, id, slug, body, options = { headers: {} }) {
            const localVarPath = this.basePath + '/registry-svc/instances';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            if (scheme !== undefined) {
                localVarQueryParameters['scheme'] = ObjectSerializer.serialize(scheme, "string");
            }
            if (ip !== undefined) {
                localVarQueryParameters['ip'] = ObjectSerializer.serialize(ip, "string");
            }
            if (deploymentId !== undefined) {
                localVarQueryParameters['deploymentId'] = ObjectSerializer.serialize(deploymentId, "string");
            }
            if (host !== undefined) {
                localVarQueryParameters['host'] = ObjectSerializer.serialize(host, "string");
            }
            if (id !== undefined) {
                localVarQueryParameters['id'] = ObjectSerializer.serialize(id, "string");
            }
            if (slug !== undefined) {
                localVarQueryParameters['slug'] = ObjectSerializer.serialize(slug, "string");
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'GET',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(body, "object")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "RegistrySvcListInstancesResponse");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Retrieve a list of nodes.
     * @summary List Nodes
     * @param registrySvcListNodesRequest List Nodes Request
     */
    listNodes(registrySvcListNodesRequest_1) {
        return __awaiter(this, arguments, void 0, function* (registrySvcListNodesRequest, options = { headers: {} }) {
            const localVarPath = this.basePath + '/registry-svc/nodes';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'POST',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(registrySvcListNodesRequest, "RegistrySvcListNodesRequest")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "RegistrySvcListNodesResponse");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Registers an instance. Idempotent.
     * @summary Register Instance
     * @param registrySvcRegisterInstanceRequest Register Instance Request
     */
    registerInstance(registrySvcRegisterInstanceRequest_1) {
        return __awaiter(this, arguments, void 0, function* (registrySvcRegisterInstanceRequest, options = { headers: {} }) {
            const localVarPath = this.basePath + '/registry-svc/instance';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'registrySvcRegisterInstanceRequest' is not null or undefined
            if (registrySvcRegisterInstanceRequest === null || registrySvcRegisterInstanceRequest === undefined) {
                throw new Error('Required parameter registrySvcRegisterInstanceRequest was null or undefined when calling registerInstance.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'PUT',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(registrySvcRegisterInstanceRequest, "RegistrySvcRegisterInstanceRequest")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "object");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Removes a registered instance by ID.
     * @summary Remove Instance
     * @param id Instance ID
     * @param body
     */
    removeInstance(id_1, body_1) {
        return __awaiter(this, arguments, void 0, function* (id, body, options = { headers: {} }) {
            const localVarPath = this.basePath + '/registry-svc/instance/{id}'
                .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new Error('Required parameter id was null or undefined when calling removeInstance.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'DELETE',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(body, "object")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Registers a new definition, associating an definition address with a slug acquired from the bearer token.
     * @summary Register a Definition
     * @param registrySvcSaveDefinitionRequest Register Service Definition Request
     */
    saveDefinition(registrySvcSaveDefinitionRequest_1) {
        return __awaiter(this, arguments, void 0, function* (registrySvcSaveDefinitionRequest, options = { headers: {} }) {
            const localVarPath = this.basePath + '/registry-svc/definition';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'registrySvcSaveDefinitionRequest' is not null or undefined
            if (registrySvcSaveDefinitionRequest === null || registrySvcSaveDefinitionRequest === undefined) {
                throw new Error('Required parameter registrySvcSaveDefinitionRequest was null or undefined when calling saveDefinition.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'PUT',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(registrySvcSaveDefinitionRequest, "RegistrySvcSaveDefinitionRequest")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "object");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Show the local node.
     * @summary View Self Node
     * @param body List Registrys Request
     */
    selfNode(body_1) {
        return __awaiter(this, arguments, void 0, function* (body, options = { headers: {} }) {
            const localVarPath = this.basePath + '/registry-svc/node/self';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'GET',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(body, "object")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "RegistrySvcNodeSelfResponse");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
}

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
let defaultBasePath$2 = 'http://localhost:11337';
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
var SecretSvcApiApiKeys;
(function (SecretSvcApiApiKeys) {
    SecretSvcApiApiKeys[SecretSvcApiApiKeys["BearerAuth"] = 0] = "BearerAuth";
})(SecretSvcApiApiKeys || (SecretSvcApiApiKeys = {}));
class SecretSvcApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath$2;
        this._defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerAuth': new ApiKeyAuth('header', 'Authorization'),
        };
        this.interceptors = [];
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    set defaultHeaders(defaultHeaders) {
        this._defaultHeaders = defaultHeaders;
    }
    get defaultHeaders() {
        return this._defaultHeaders;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[SecretSvcApiApiKeys[key]].apiKey = value;
    }
    addInterceptor(interceptor) {
        this.interceptors.push(interceptor);
    }
    /**
     * Decrypt a value and return the encrypted result
     * @summary Decrypt a Value
     * @param secretSvcDecryptValueRequest Decrypt Value Request
     */
    decryptValue(secretSvcDecryptValueRequest_1) {
        return __awaiter(this, arguments, void 0, function* (secretSvcDecryptValueRequest, options = { headers: {} }) {
            const localVarPath = this.basePath + '/secret-svc/decrypt';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'secretSvcDecryptValueRequest' is not null or undefined
            if (secretSvcDecryptValueRequest === null || secretSvcDecryptValueRequest === undefined) {
                throw new Error('Required parameter secretSvcDecryptValueRequest was null or undefined when calling decryptValue.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'POST',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(secretSvcDecryptValueRequest, "SecretSvcDecryptValueRequest")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "SecretSvcDecryptValueResponse");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Encrypt a value and return the encrypted result
     * @summary Encrypt a Value
     * @param secretSvcEncryptValueRequest Encrypt Value Request
     */
    encryptValue(secretSvcEncryptValueRequest_1) {
        return __awaiter(this, arguments, void 0, function* (secretSvcEncryptValueRequest, options = { headers: {} }) {
            const localVarPath = this.basePath + '/secret-svc/encrypt';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'secretSvcEncryptValueRequest' is not null or undefined
            if (secretSvcEncryptValueRequest === null || secretSvcEncryptValueRequest === undefined) {
                throw new Error('Required parameter secretSvcEncryptValueRequest was null or undefined when calling encryptValue.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'POST',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(secretSvcEncryptValueRequest, "SecretSvcEncryptValueRequest")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "SecretSvcEncryptValueResponse");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Returns true if the encryption key is sufficiently secure.
     * @summary Check Security Status
     * @param body
     */
    isSecure(body_1) {
        return __awaiter(this, arguments, void 0, function* (body, options = { headers: {} }) {
            const localVarPath = this.basePath + '/secret-svc/is-secure';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'GET',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(body, "object")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "SecretSvcIsSecureResponse");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * List secrets by key(s) if authorized.
     * @summary List Secrets
     * @param secretSvcListSecretsRequest List Secret Request
     */
    listSecrets(secretSvcListSecretsRequest_1) {
        return __awaiter(this, arguments, void 0, function* (secretSvcListSecretsRequest, options = { headers: {} }) {
            const localVarPath = this.basePath + '/secret-svc/secrets';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'POST',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(secretSvcListSecretsRequest, "SecretSvcListSecretsRequest")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "SecretSvcListSecretsResponse");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Remove secrets if authorized to do so
     * @summary Remove Secrets
     * @param secretSvcRemoveSecretsRequest Remove Secret Request
     */
    removeSecrets(secretSvcRemoveSecretsRequest_1) {
        return __awaiter(this, arguments, void 0, function* (secretSvcRemoveSecretsRequest, options = { headers: {} }) {
            const localVarPath = this.basePath + '/secret-svc/secrets';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'secretSvcRemoveSecretsRequest' is not null or undefined
            if (secretSvcRemoveSecretsRequest === null || secretSvcRemoveSecretsRequest === undefined) {
                throw new Error('Required parameter secretSvcRemoveSecretsRequest was null or undefined when calling removeSecrets.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'DELETE',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(secretSvcRemoveSecretsRequest, "SecretSvcRemoveSecretsRequest")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "object");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Save secrets if authorized to do so. Requires the `secret-svc:secret:save` permission. Users can only save secrets prefixed with their user slug unless they also have the `secret-svc:secret:save-unprefixed` permission, which allows them to save a secret without a slug prefix.
     * @summary Save Secrets
     * @param secretSvcSaveSecretsRequest Save Secret Request
     */
    saveSecrets(secretSvcSaveSecretsRequest_1) {
        return __awaiter(this, arguments, void 0, function* (secretSvcSaveSecretsRequest, options = { headers: {} }) {
            const localVarPath = this.basePath + '/secret-svc/secrets';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'secretSvcSaveSecretsRequest' is not null or undefined
            if (secretSvcSaveSecretsRequest === null || secretSvcSaveSecretsRequest === undefined) {
                throw new Error('Required parameter secretSvcSaveSecretsRequest was null or undefined when calling saveSecrets.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'PUT',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(secretSvcSaveSecretsRequest, "SecretSvcSaveSecretsRequest")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "object");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
}

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
let defaultBasePath$1 = 'http://localhost:11337';
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
var SourceSvcApiApiKeys;
(function (SourceSvcApiApiKeys) {
    SourceSvcApiApiKeys[SourceSvcApiApiKeys["BearerAuth"] = 0] = "BearerAuth";
})(SourceSvcApiApiKeys || (SourceSvcApiApiKeys = {}));
class SourceSvcApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath$1;
        this._defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerAuth': new ApiKeyAuth('header', 'Authorization'),
        };
        this.interceptors = [];
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    set defaultHeaders(defaultHeaders) {
        this._defaultHeaders = defaultHeaders;
    }
    get defaultHeaders() {
        return this._defaultHeaders;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[SourceSvcApiApiKeys[key]].apiKey = value;
    }
    addInterceptor(interceptor) {
        this.interceptors.push(interceptor);
    }
    /**
     * Checkout a git repository over https or ssh at a specific version into a temporary directory. Performs a shallow clone with minimal history for faster checkout.
     * @summary Checkout a git repository
     * @param sourceSvcCheckoutRepoRequest Checkout Repo Request
     */
    checkoutRepo(sourceSvcCheckoutRepoRequest_1) {
        return __awaiter(this, arguments, void 0, function* (sourceSvcCheckoutRepoRequest, options = { headers: {} }) {
            const localVarPath = this.basePath + '/source-svc/repo/checkout';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'sourceSvcCheckoutRepoRequest' is not null or undefined
            if (sourceSvcCheckoutRepoRequest === null || sourceSvcCheckoutRepoRequest === undefined) {
                throw new Error('Required parameter sourceSvcCheckoutRepoRequest was null or undefined when calling checkoutRepo.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'POST',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(sourceSvcCheckoutRepoRequest, "SourceSvcCheckoutRepoRequest")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "SourceSvcCheckoutRepoResponse");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
}

/**
 * 1Backend
 * AI-native microservices platform.
 *
 * The version of the OpenAPI document: 0.8.0-rc2
 * Contact: sales@singulatron.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
let defaultBasePath = 'http://localhost:11337';
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
var UserSvcApiApiKeys;
(function (UserSvcApiApiKeys) {
    UserSvcApiApiKeys[UserSvcApiApiKeys["BearerAuth"] = 0] = "BearerAuth";
})(UserSvcApiApiKeys || (UserSvcApiApiKeys = {}));
class UserSvcApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this._defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerAuth': new ApiKeyAuth('header', 'Authorization'),
        };
        this.interceptors = [];
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    set defaultHeaders(defaultHeaders) {
        this._defaultHeaders = defaultHeaders;
    }
    get defaultHeaders() {
        return this._defaultHeaders;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[UserSvcApiApiKeys[key]].apiKey = value;
    }
    addInterceptor(interceptor) {
        this.interceptors.push(interceptor);
    }
    /**
     * Allows an authenticated user to change their own password.
     * @summary Change Password
     * @param userSvcChangePasswordRequest Change Password Request
     */
    changePassword(userSvcChangePasswordRequest_1) {
        return __awaiter(this, arguments, void 0, function* (userSvcChangePasswordRequest, options = { headers: {} }) {
            const localVarPath = this.basePath + '/user-svc/change-password';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'userSvcChangePasswordRequest' is not null or undefined
            if (userSvcChangePasswordRequest === null || userSvcChangePasswordRequest === undefined) {
                throw new Error('Required parameter userSvcChangePasswordRequest was null or undefined when calling changePassword.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'POST',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(userSvcChangePasswordRequest, "UserSvcChangePasswordRequest")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "object");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Allows an authenticated administrator to create a new user with specified details.
     * @summary Create a New User
     * @param userSvcCreateUserRequest Create User Request
     */
    createUser(userSvcCreateUserRequest_1) {
        return __awaiter(this, arguments, void 0, function* (userSvcCreateUserRequest, options = { headers: {} }) {
            const localVarPath = this.basePath + '/user-svc/user';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'userSvcCreateUserRequest' is not null or undefined
            if (userSvcCreateUserRequest === null || userSvcCreateUserRequest === undefined) {
                throw new Error('Required parameter userSvcCreateUserRequest was null or undefined when calling createUser.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'POST',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(userSvcCreateUserRequest, "UserSvcCreateUserRequest")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "object");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Allows an organization admin to remove a user from an organization.
     * @summary Delete Membership
     * @param organizationId Organization ID
     * @param userId User ID
     * @param body Remove User From Organization Request
     */
    deleteMembership(organizationId_1, userId_1, body_1) {
        return __awaiter(this, arguments, void 0, function* (organizationId, userId, body, options = { headers: {} }) {
            const localVarPath = this.basePath + '/user-svc/organization/{organizationId}/user/{userId}'
                .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)))
                .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)));
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new Error('Required parameter organizationId was null or undefined when calling deleteMembership.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new Error('Required parameter userId was null or undefined when calling deleteMembership.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'DELETE',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(body, "object")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "object");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Delete a user based on the user ID.
     * @summary Delete a User
     * @param userId User ID
     * @param body
     */
    deleteUser(userId_1, body_1) {
        return __awaiter(this, arguments, void 0, function* (userId, body, options = { headers: {} }) {
            const localVarPath = this.basePath + '/user-svc/user/{userId}'
                .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)));
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new Error('Required parameter userId was null or undefined when calling deleteUser.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'DELETE',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(body, "object")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "object");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Exchange an existing token for a new token scoped to a different app (namespace). The new token represents the same user but contains roles specific to the target app.  The original token remains valid. The minted token is not stored and cannot be refreshed (and will have the same expiration duration as normal tokens), unlike tokens acquired via login.  For now, token exchange is designed to be in situ — the User Svc must be contacted at exchange time. This introduces a stateful dependency on the User Svc, but simplifies things until broader use cases emerge.
     * @summary Exchange Token
     * @param userSvcExchangeTokenRequest ExchangeToken Request
     */
    exchangeToken(userSvcExchangeTokenRequest_1) {
        return __awaiter(this, arguments, void 0, function* (userSvcExchangeTokenRequest, options = { headers: {} }) {
            const localVarPath = this.basePath + '/user-svc/token/exchange';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'userSvcExchangeTokenRequest' is not null or undefined
            if (userSvcExchangeTokenRequest === null || userSvcExchangeTokenRequest === undefined) {
                throw new Error('Required parameter userSvcExchangeTokenRequest was null or undefined when calling exchangeToken.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'PUT',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(userSvcExchangeTokenRequest, "UserSvcExchangeTokenRequest")
            };
            let authenticationPromise = Promise.resolve();
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "UserSvcExchangeTokenResponse");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Exchange an existing token for a new token scoped to a different app (namespace). The new token represents the same user but contains roles specific to the target app.  The original token remains valid. The minted token is not stored and cannot be refreshed (and will have the same expiration duration as normal tokens), unlike tokens acquired via login.  For now, token exchange is designed to be in situ — the User Svc must be contacted at exchange time. This introduces a stateful dependency on the User Svc, but simplifies things until broader use cases emerge.
     * @summary Exchange Token
     * @param userSvcExchangeTokenRequest ExchangeToken Request
     */
    exchangeToken_1(userSvcExchangeTokenRequest_1) {
        return __awaiter(this, arguments, void 0, function* (userSvcExchangeTokenRequest, options = { headers: {} }) {
            const localVarPath = this.basePath + '/user-svc/token/exchange';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'userSvcExchangeTokenRequest' is not null or undefined
            if (userSvcExchangeTokenRequest === null || userSvcExchangeTokenRequest === undefined) {
                throw new Error('Required parameter userSvcExchangeTokenRequest was null or undefined when calling exchangeToken_1.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'PUT',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(userSvcExchangeTokenRequest, "UserSvcExchangeTokenRequest")
            };
            let authenticationPromise = Promise.resolve();
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "UserSvcExchangeTokenResponse");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Get the public key to verify the JWT signature.
     * @summary Get Public Key
     * @param body
     */
    getPublicKey(body_1) {
        return __awaiter(this, arguments, void 0, function* (body, options = { headers: {} }) {
            const localVarPath = this.basePath + '/user-svc/public-key';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'GET',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(body, "object")
            };
            let authenticationPromise = Promise.resolve();
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "UserSvcGetPublicKeyResponse");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Checks whether the caller has a specific permission. Optimized for caching — only the caller and the permission are required. To assign a permission to a user or role, use the `Save Permits` endpoint.  This endpoint does not return 401 Unauthorized if access is denied. Instead, it always returns 200 OK with `Authorized: false` if the permission is missing. The response will still include the caller’s user information if not authorized.
     * @summary Has Permission
     * @param permission Permission
     * @param body
     */
    hasPermission(permission_1, body_1) {
        return __awaiter(this, arguments, void 0, function* (permission, body, options = { headers: {} }) {
            const localVarPath = this.basePath + '/user-svc/self/has/{permission}'
                .replace('{' + 'permission' + '}', encodeURIComponent(String(permission)));
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'permission' is not null or undefined
            if (permission === null || permission === undefined) {
                throw new Error('Required parameter permission was null or undefined when calling hasPermission.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'POST',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(body, "object")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "UserSvcHasPermissionResponse");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * List enrolls. Role, user ID or contact ID must be specified.  Requires the `user-svc:enroll:view` permission, which by default all users have. Caller can only list enrolls of roles they own (unless they are an admin).
     * @summary List Enrolls
     * @param userSvcListEnrollsRequest List Enrolls Request
     */
    listEnrolls(userSvcListEnrollsRequest_1) {
        return __awaiter(this, arguments, void 0, function* (userSvcListEnrollsRequest, options = { headers: {} }) {
            const localVarPath = this.basePath + '/user-svc/enrolls';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'userSvcListEnrollsRequest' is not null or undefined
            if (userSvcListEnrollsRequest === null || userSvcListEnrollsRequest === undefined) {
                throw new Error('Required parameter userSvcListEnrollsRequest was null or undefined when calling listEnrolls.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'POST',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(userSvcListEnrollsRequest, "UserSvcListEnrollsRequest")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "UserSvcListEnrollsResponse");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Requires the `user-svc:organization:view` permission, that only admins have by default.
     * @summary List Organizations
     * @param userSvcListOrganizationsRequest List Organizations Request
     */
    listOrganizations(userSvcListOrganizationsRequest_1) {
        return __awaiter(this, arguments, void 0, function* (userSvcListOrganizationsRequest, options = { headers: {} }) {
            const localVarPath = this.basePath + '/user-svc/organizations';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'userSvcListOrganizationsRequest' is not null or undefined
            if (userSvcListOrganizationsRequest === null || userSvcListOrganizationsRequest === undefined) {
                throw new Error('Required parameter userSvcListOrganizationsRequest was null or undefined when calling listOrganizations.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'POST',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(userSvcListOrganizationsRequest, "UserSvcListOrganizationsRequest")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "UserSvcListOrganizationsResponse");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * List permissions by roles. Caller can only list permissions for roles they have.
     * @summary List Permissions
     * @param roleId Role ID
     * @param body
     */
    listPermissions(roleId_1, body_1) {
        return __awaiter(this, arguments, void 0, function* (roleId, body, options = { headers: {} }) {
            const localVarPath = this.basePath + '/user-svc/permissions'
                .replace('{' + 'roleId' + '}', encodeURIComponent(String(roleId)));
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'roleId' is not null or undefined
            if (roleId === null || roleId === undefined) {
                throw new Error('Required parameter roleId was null or undefined when calling listPermissions.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'POST',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(body, "object")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "UserSvcListPermissionsResponse");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * List permits. Requires the `user-svc:permit:view` permission, which only admins have by default. &todo Users should be able to list permits referring to them.
     * @summary List Permits
     * @param userSvcListPermitsRequest List Permits Request
     */
    listPermits(userSvcListPermitsRequest_1) {
        return __awaiter(this, arguments, void 0, function* (userSvcListPermitsRequest, options = { headers: {} }) {
            const localVarPath = this.basePath + '/user-svc/permits';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'userSvcListPermitsRequest' is not null or undefined
            if (userSvcListPermitsRequest === null || userSvcListPermitsRequest === undefined) {
                throw new Error('Required parameter userSvcListPermitsRequest was null or undefined when calling listPermits.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'POST',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(userSvcListPermitsRequest, "UserSvcListPermitsRequest")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "UserSvcListPermitsResponse");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Fetches a list of users with optional query filters and pagination. Requires the `user-svc:user:view` permission that only admins have by default.
     * @summary List Users
     * @param userSvcListUsersRequest List Users Request
     */
    listUsers(userSvcListUsersRequest_1) {
        return __awaiter(this, arguments, void 0, function* (userSvcListUsersRequest, options = { headers: {} }) {
            const localVarPath = this.basePath + '/user-svc/users';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'POST',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(userSvcListUsersRequest, "UserSvcListUsersRequest")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "UserSvcListUsersResponse");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Authenticates a user and returns a token.
     * @summary Login
     * @param userSvcLoginRequest Login Request
     */
    login(userSvcLoginRequest_1) {
        return __awaiter(this, arguments, void 0, function* (userSvcLoginRequest, options = { headers: {} }) {
            const localVarPath = this.basePath + '/user-svc/login';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'userSvcLoginRequest' is not null or undefined
            if (userSvcLoginRequest === null || userSvcLoginRequest === undefined) {
                throw new Error('Required parameter userSvcLoginRequest was null or undefined when calling login.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'POST',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(userSvcLoginRequest, "UserSvcLoginRequest")
            };
            let authenticationPromise = Promise.resolve();
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "UserSvcLoginResponse");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Retrieves user information based on the authentication token in the request header. Typically called by single-page applications during the initial page load. While some details (such as roles, slug, user ID, and active organization ID) can be extracted from the JWT, this endpoint returns additional data, including the full user object and associated organizations.  ReadSelf intentionally still works after token revocation until the token expires. This is to ensure that the user is not notified of token revocation (though some information is leaked by the count token functionality @todo).
     * @summary Read Self
     * @param userSvcReadSelfRequest Read Self Request
     */
    readSelf(userSvcReadSelfRequest_1) {
        return __awaiter(this, arguments, void 0, function* (userSvcReadSelfRequest, options = { headers: {} }) {
            const localVarPath = this.basePath + '/user-svc/self';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'POST',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(userSvcReadSelfRequest, "UserSvcReadSelfRequest")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "UserSvcReadSelfResponse");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Refreshes an existing token, including inactive ones. The old token becomes inactive (if not already inactive), and a new, active token is issued. This allows continued verification of user roles without requiring a new login. Inactive tokens are refreshable unless explicitly revoked (no mechanism for this yet). Leaked tokens should be handled separately, via a revocation flag or deletion.
     * @summary Refresh Token
     * @param body
     */
    refreshToken(body_1) {
        return __awaiter(this, arguments, void 0, function* (body, options = { headers: {} }) {
            const localVarPath = this.basePath + '/user-svc/refresh-token';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'POST',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(body, "object")
            };
            let authenticationPromise = Promise.resolve();
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "UserSvcRefreshTokenResponse");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Register a new user with a name, email, and password.
     * @summary Register
     * @param userSvcRegisterRequest Register Request
     */
    register(userSvcRegisterRequest_1) {
        return __awaiter(this, arguments, void 0, function* (userSvcRegisterRequest, options = { headers: {} }) {
            const localVarPath = this.basePath + '/user-svc/register';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'userSvcRegisterRequest' is not null or undefined
            if (userSvcRegisterRequest === null || userSvcRegisterRequest === undefined) {
                throw new Error('Required parameter userSvcRegisterRequest was null or undefined when calling register.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'POST',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(userSvcRegisterRequest, "UserSvcRegisterRequest")
            };
            let authenticationPromise = Promise.resolve();
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "UserSvcRegisterResponse");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Allows an administrator to change a user\'s password.
     * @summary Reset Password
     * @param userId User ID
     * @param userSvcResetPasswordRequest Change Password Request
     */
    resetPassword(userId_1, userSvcResetPasswordRequest_1) {
        return __awaiter(this, arguments, void 0, function* (userId, userSvcResetPasswordRequest, options = { headers: {} }) {
            const localVarPath = this.basePath + '/user-svc/{userId}/reset-password'
                .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)));
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new Error('Required parameter userId was null or undefined when calling resetPassword.');
            }
            // verify required parameter 'userSvcResetPasswordRequest' is not null or undefined
            if (userSvcResetPasswordRequest === null || userSvcResetPasswordRequest === undefined) {
                throw new Error('Required parameter userSvcResetPasswordRequest was null or undefined when calling resetPassword.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'POST',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(userSvcResetPasswordRequest, "UserSvcResetPasswordRequest")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "object");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Revoke tokens in one of the following scenarios: - For the current user. - For another user (see `userId` field), if permitted (`user-svc:token:revoke` permission, typically by admins).
     * @summary Revoke Tokens
     * @param userSvcRevokeTokensRequest Revoke Tokens Request
     */
    revokeTokens(userSvcRevokeTokensRequest_1) {
        return __awaiter(this, arguments, void 0, function* (userSvcRevokeTokensRequest, options = { headers: {} }) {
            const localVarPath = this.basePath + '/user-svc/tokens';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'DELETE',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(userSvcRevokeTokensRequest, "UserSvcRevokeTokensRequest")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "object");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Enroll a list of users by contact or user Id to acquire a role. Works on future or current users.  Requires the `user-svc:enroll:edit` permission, which by default all users have. A user can only enroll an other user to a role if the user \"owns\" that role.  A user \"owns\" a role in the following cases: - A static role where the role ID is prefixed with the caller\'s slug. - Any dynamic or static role where the caller is an admin (has `*:admin` postfix of that role).  Examples: - A user with the slug `joe-doe` owns roles like `joe-doe:*` such as `joe-doe:any-custom-role`. - A user with any slug who has the role `my-service:admin` owns `my-service:*` roles such as `my-service:user`. - A user with any slug who has the role `user-svc:org:{%orgId}:admin` owns `user-svc:org:{%orgId}:*` such as `user-svc:org:{%orgId}:user`.
     * @summary Save Enrolls
     * @param userSvcSaveEnrollsRequest Save Enrolls Request
     */
    saveEnrolls(userSvcSaveEnrollsRequest_1) {
        return __awaiter(this, arguments, void 0, function* (userSvcSaveEnrollsRequest, options = { headers: {} }) {
            const localVarPath = this.basePath + '/user-svc/enrolls';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'userSvcSaveEnrollsRequest' is not null or undefined
            if (userSvcSaveEnrollsRequest === null || userSvcSaveEnrollsRequest === undefined) {
                throw new Error('Required parameter userSvcSaveEnrollsRequest was null or undefined when calling saveEnrolls.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'PUT',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(userSvcSaveEnrollsRequest, "UserSvcSaveEnrollsRequest")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "UserSvcSaveEnrollsResponse");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Allows an organization admin to add a user to the organization.
     * @summary Save Membership
     * @param organizationId Organization ID
     * @param userId User ID
     * @param body Add User to Organization Request
     */
    saveMembership(organizationId_1, userId_1, body_1) {
        return __awaiter(this, arguments, void 0, function* (organizationId, userId, body, options = { headers: {} }) {
            const localVarPath = this.basePath + '/user-svc/organization/{organizationId}/user/{userId}'
                .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)))
                .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)));
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new Error('Required parameter organizationId was null or undefined when calling saveMembership.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new Error('Required parameter userId was null or undefined when calling saveMembership.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'PUT',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(body, "object")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "object");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Allows a logged-in user to save an organization. The user initiating the request will be assigned the role of admin for that organization. The initiating user will receive a dynamic role in the format `user-svc:org:{organizationId}:admin`, where `{organizationId}` is a unique identifier for the saved organization. Dynamic roles are generated based on specific user-resource associations (in this case the resource being the organization), offering more flexible permission management compared to static roles.
     * @summary Save an Organization
     * @param userSvcSaveOrganizationRequest Save User Request
     */
    saveOrganization(userSvcSaveOrganizationRequest_1) {
        return __awaiter(this, arguments, void 0, function* (userSvcSaveOrganizationRequest, options = { headers: {} }) {
            const localVarPath = this.basePath + '/user-svc/organization';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'userSvcSaveOrganizationRequest' is not null or undefined
            if (userSvcSaveOrganizationRequest === null || userSvcSaveOrganizationRequest === undefined) {
                throw new Error('Required parameter userSvcSaveOrganizationRequest was null or undefined when calling saveOrganization.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'PUT',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(userSvcSaveOrganizationRequest, "UserSvcSaveOrganizationRequest")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "UserSvcSaveOrganizationResponse");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Save permits. Permits give access to users with certain slugs and roles to permissions.
     * @summary Save Permits
     * @param userSvcSavePermitsRequest Save Permits Request
     */
    savePermits(userSvcSavePermitsRequest_1) {
        return __awaiter(this, arguments, void 0, function* (userSvcSavePermitsRequest, options = { headers: {} }) {
            const localVarPath = this.basePath + '/user-svc/permits';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'userSvcSavePermitsRequest' is not null or undefined
            if (userSvcSavePermitsRequest === null || userSvcSavePermitsRequest === undefined) {
                throw new Error('Required parameter userSvcSavePermitsRequest was null or undefined when calling savePermits.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'PUT',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(userSvcSavePermitsRequest, "UserSvcSavePermitsRequest")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "object");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Save user\'s own profile information.
     * @summary Save User Profile
     * @param userSvcSaveSelfRequest Save Profile Request
     */
    saveSelf(userSvcSaveSelfRequest_1) {
        return __awaiter(this, arguments, void 0, function* (userSvcSaveSelfRequest, options = { headers: {} }) {
            const localVarPath = this.basePath + '/user-svc/self';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'userSvcSaveSelfRequest' is not null or undefined
            if (userSvcSaveSelfRequest === null || userSvcSaveSelfRequest === undefined) {
                throw new Error('Required parameter userSvcSaveSelfRequest was null or undefined when calling saveSelf.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'PUT',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(userSvcSaveSelfRequest, "UserSvcSaveSelfRequest")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "object");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Save user information based on the provided user ID. Intended for admins. Requires the `user-svc:user:edit` permission. For a user to edit their own profile, see `saveSelf`.
     * @summary Save User
     * @param userId User ID
     * @param userSvcSaveUserRequest Save Profile Request
     */
    saveUser(userId_1, userSvcSaveUserRequest_1) {
        return __awaiter(this, arguments, void 0, function* (userId, userSvcSaveUserRequest, options = { headers: {} }) {
            const localVarPath = this.basePath + '/user-svc/user/{userId}'
                .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)));
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new Error('Required parameter userId was null or undefined when calling saveUser.');
            }
            // verify required parameter 'userSvcSaveUserRequest' is not null or undefined
            if (userSvcSaveUserRequest === null || userSvcSaveUserRequest === undefined) {
                throw new Error('Required parameter userSvcSaveUserRequest was null or undefined when calling saveUser.');
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarRequestOptions = {
                method: 'PUT',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: ObjectSerializer.serialize(userSvcSaveUserRequest, "UserSvcSaveUserRequest")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.BearerAuth.apiKey) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.BearerAuth.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    localVarRequest(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = ObjectSerializer.deserialize(body, "object");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
}

class HttpError extends Error {
    constructor(response, body, statusCode) {
        super('HTTP request failed');
        this.response = response;
        this.body = body;
        this.statusCode = statusCode;
        this.name = 'HttpError';
    }
}
const APIS = [ChatSvcApi, ConfigSvcApi, ContainerSvcApi, DataSvcApi, DeploySvcApi, EmailSvcApi, FileSvcApi, FirehoseSvcApi, ImageSvcApi, ModelSvcApi, PolicySvcApi, PromptSvcApi, ProxySvcApi, RegistrySvcApi, SecretSvcApi, SourceSvcApi, UserSvcApi];

export { APIS, ApiKeyAuth, ChatSvcApi, ChatSvcApiApiKeys, ChatSvcEventMessageAdded, ChatSvcEventThreadAdded, ChatSvcEventThreadUpdate, ChatSvcListMessagesRequest, ChatSvcListMessagesResponse, ChatSvcListThreadsRequest, ChatSvcListThreadsResponse, ChatSvcMessage, ChatSvcSaveMessageRequest, ChatSvcSaveThreadRequest, ChatSvcSaveThreadResponse, ChatSvcThread, ConfigSvcApi, ConfigSvcApiApiKeys, ConfigSvcConfig, ConfigSvcListConfigsRequest, ConfigSvcListConfigsResponse, ConfigSvcSaveConfigRequest, ContainerSvcApi, ContainerSvcApiApiKeys, ContainerSvcAsset, ContainerSvcBuildImageRequest, ContainerSvcCapabilities, ContainerSvcContainer, ContainerSvcContainerIsRunningResponse, ContainerSvcDaemonInfoResponse, ContainerSvcEnvVar, ContainerSvcErrorResponse, ContainerSvcGetContainerSummaryResponse, ContainerSvcGetHostResponse, ContainerSvcImagePullableResponse, ContainerSvcKeep, ContainerSvcLabel, ContainerSvcListContainersRequest, ContainerSvcListContainersResponse, ContainerSvcListLogsRequest, ContainerSvcListLogsResponse, ContainerSvcLog, ContainerSvcNetwork, ContainerSvcPortMapping, ContainerSvcResources, ContainerSvcRunContainerRequest, ContainerSvcRunContainerResponse, ContainerSvcStopContainerRequest, ContainerSvcVolume, DataSvcApi, DataSvcApiApiKeys, DataSvcCreateObjectFields, DataSvcCreateObjectRequest, DataSvcCreateObjectResponse, DataSvcDeleteObjectRequest, DataSvcErrorResponse, DataSvcObject, DataSvcQueryRequest, DataSvcQueryResponse, DataSvcUpdateObjectsRequest, DataSvcUpsertObjectRequest, DataSvcUpsertObjectResponse, DatastoreFilter, DatastoreOrderBy, DatastoreQuery, DeploySvcApi, DeploySvcApiApiKeys, DeploySvcAutoScalingConfig, DeploySvcDeleteDeploymentRequest, DeploySvcDeployment, DeploySvcDeploymentStrategy, DeploySvcErrorResponse, DeploySvcListDeploymentsResponse, DeploySvcResourceLimits, DeploySvcSaveDeploymentRequest, DeploySvcTargetRegion, EmailSvcApi, EmailSvcApiApiKeys, EmailSvcAttachment, EmailSvcErrorResponse, EmailSvcSendEmailRequest, EmailSvcSendEmailResponse, Events200Response, FileSvcApi, FileSvcApiApiKeys, FileSvcDownload, FileSvcDownloadFileRequest, FileSvcDownloadsResponse, FileSvcErrorResponse, FileSvcGetDownloadResponse, FileSvcListUploadsRequest, FileSvcListUploadsResponse, FileSvcUpload, FileSvcUploadFileResponse, FirehoseSvcApi, FirehoseSvcApiApiKeys, FirehoseSvcErrorResponse, FirehoseSvcEvent, FirehoseSvcEventPublishRequest, HttpBasicAuth, HttpBearerAuth, HttpError, ImageSvcApi, ImageSvcApiApiKeys, ImageSvcErrorResponse, ModelSvcApi, ModelSvcApiApiKeys, ModelSvcArchitectures, ModelSvcAsset, ModelSvcContainer, ModelSvcCudaParameters, ModelSvcDefaultParameters, ModelSvcEnvVar, ModelSvcErrorResponse, ModelSvcGetModelResponse, ModelSvcKeep, ModelSvcListModelsResponse, ModelSvcListPlatformsResponse, ModelSvcModel, ModelSvcModelStatus, ModelSvcPlatform, ModelSvcStatusResponse, OAuth, ObjectSerializer, PolicySvcApi, PolicySvcApiApiKeys, PolicySvcBlocklistParameters, PolicySvcCheckRequest, PolicySvcCheckResponse, PolicySvcErrorResponse, PolicySvcInstance, PolicySvcParameters, PolicySvcRateLimitParameters, PolicySvcUpsertInstanceRequest, PromptSvcApi, PromptSvcApiApiKeys, PromptSvcEngineParameters, PromptSvcErrorResponse, PromptSvcListPromptsRequest, PromptSvcListPromptsResponse, PromptSvcLlamaCppParameters, PromptSvcParameters, PromptSvcPrompt, PromptSvcPromptRequest, PromptSvcPromptResponse, PromptSvcRemovePromptRequest, PromptSvcStableDiffusionParameters, PromptSvcStreamChunk, PromptSvcTextToImageParameters, PromptSvcTextToTextParameters, PromptSvcTypesResponse, ProxySvcApi, ProxySvcApiApiKeys, ProxySvcCert, ProxySvcCertInput, ProxySvcErrorResponse, ProxySvcListCertsRequest, ProxySvcListCertsResponse, ProxySvcListRoutesRequest, ProxySvcListRoutesResponse, ProxySvcRoute, ProxySvcRouteInput, ProxySvcSaveCertsRequest, ProxySvcSaveRoutesRequest, ProxySvcSaveRoutesResponse, RegistrySvcAPISpec, RegistrySvcApi, RegistrySvcApiApiKeys, RegistrySvcClient, RegistrySvcDefinition, RegistrySvcEnvVar, RegistrySvcErrorResponse, RegistrySvcGPU, RegistrySvcImageSpec, RegistrySvcInstance, RegistrySvcListDefinitionsResponse, RegistrySvcListInstancesResponse, RegistrySvcListNodesRequest, RegistrySvcListNodesResponse, RegistrySvcNode, RegistrySvcNodeSelfResponse, RegistrySvcPortMapping, RegistrySvcProcess, RegistrySvcRegisterInstanceRequest, RegistrySvcRepositorySpec, RegistrySvcResourceUsage, RegistrySvcSaveDefinitionRequest, RegistrySvcUsage, SecretSvcApi, SecretSvcApiApiKeys, SecretSvcDecryptValueRequest, SecretSvcDecryptValueResponse, SecretSvcEncryptValueRequest, SecretSvcEncryptValueResponse, SecretSvcIsSecureResponse, SecretSvcListSecretsRequest, SecretSvcListSecretsResponse, SecretSvcRemoveSecretsRequest, SecretSvcSaveSecretsRequest, SecretSvcSecret, SourceSvcApi, SourceSvcApiApiKeys, SourceSvcCheckoutRepoRequest, SourceSvcCheckoutRepoResponse, SourceSvcErrorResponse, StableDiffusionTxt2ImgRequest, UserSvcApi, UserSvcApiApiKeys, UserSvcAuthToken, UserSvcChangePasswordRequest, UserSvcContact, UserSvcContactInput, UserSvcCreateUserRequest, UserSvcEnroll, UserSvcEnrollInput, UserSvcErrorResponse, UserSvcExchangeTokenRequest, UserSvcExchangeTokenResponse, UserSvcGetPublicKeyResponse, UserSvcHasPermissionResponse, UserSvcListEnrollsRequest, UserSvcListEnrollsResponse, UserSvcListOrganizationsRequest, UserSvcListOrganizationsResponse, UserSvcListPermissionsResponse, UserSvcListPermitsRequest, UserSvcListPermitsResponse, UserSvcListUsersRequest, UserSvcListUsersResponse, UserSvcLoginRequest, UserSvcLoginResponse, UserSvcOrganization, UserSvcPermit, UserSvcPermitInput, UserSvcReadSelfRequest, UserSvcReadSelfResponse, UserSvcRefreshTokenResponse, UserSvcRegisterRequest, UserSvcRegisterResponse, UserSvcResetPasswordRequest, UserSvcRevokeTokensRequest, UserSvcSaveEnrollsRequest, UserSvcSaveEnrollsResponse, UserSvcSaveOrganizationRequest, UserSvcSaveOrganizationResponse, UserSvcSavePermitsRequest, UserSvcSaveSelfRequest, UserSvcSaveUserRequest, UserSvcUser, UserSvcUserInput, UserSvcUserRecord, VoidAuth };
