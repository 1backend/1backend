/*
1Backend

AI-native microservices platform.

API version: 0.8.0-rc1
Contact: sales@singulatron.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"encoding/json"
	"bytes"
	"fmt"
)

// checks if the RegistrySvcInstance type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &RegistrySvcInstance{}

// RegistrySvcInstance struct for RegistrySvcInstance
type RegistrySvcInstance struct {
	// The ID of the deployment that this instance is an instance of. Only instances deployed by 1Backend have a DeploymentId. Services can be deployed through other means (Docker Compose, K8s, anything), in that case they self-register and will not have a DeploymentId.
	DeploymentId *string `json:"deploymentId,omitempty"`
	// Details
	Details *string `json:"details,omitempty"`
	// Host of the instance address. Required if URL is not provided
	Host *string `json:"host,omitempty"`
	// Required: ID of the instance
	Id string `json:"id"`
	// IP of the instance address. Optional: to register by IP instead of host
	Ip *string `json:"ip,omitempty"`
	// Last time the instance gave a sign of life
	LastHeartbeat *string `json:"lastHeartbeat,omitempty"`
	// NodeURL is the URL of the 1Backend server the instance is running on. To have a NodeURL the instance must either: - Be deployed by 1Backend - Declare the 1Backend server URL when registering its instance
	NodeUrl *string `json:"nodeUrl,omitempty"`
	// Path of the instance address. Optional (e.g., \"/api\")
	Path *string `json:"path,omitempty"`
	// Port of the instance address. Required if URL is not provided
	Port *int32 `json:"port,omitempty"`
	// Scheme of the instance address. Required if URL is not provided.
	Scheme *string `json:"scheme,omitempty"`
	// Slug of the account that owns this instance Services that want to be proxied by their slug are advised to self register their instance at startup. Keep in mind, instances might be deployed by 1Backend yet they still won't be 1Backend services and they won't have slugs. Think NGINX, MySQL, etc.
	Slug *string `json:"slug,omitempty"`
	// Status
	Status RegistrySvcInstanceStatus `json:"status"`
	// Tags are used to filter instances
	Tags []string `json:"tags,omitempty"`
	// Full address URL of the instance.
	Url string `json:"url"`
}

type _RegistrySvcInstance RegistrySvcInstance

// NewRegistrySvcInstance instantiates a new RegistrySvcInstance object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewRegistrySvcInstance(id string, status RegistrySvcInstanceStatus, url string) *RegistrySvcInstance {
	this := RegistrySvcInstance{}
	this.Id = id
	this.Status = status
	this.Url = url
	return &this
}

// NewRegistrySvcInstanceWithDefaults instantiates a new RegistrySvcInstance object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewRegistrySvcInstanceWithDefaults() *RegistrySvcInstance {
	this := RegistrySvcInstance{}
	return &this
}



// HasDeploymentId returns a boolean if a field has been set.
func (o *RegistrySvcInstance) HasDeploymentId() bool {
	if o != nil && !IsNil(o.DeploymentId) {
		return true
	}

	return false
}




// HasDetails returns a boolean if a field has been set.
func (o *RegistrySvcInstance) HasDetails() bool {
	if o != nil && !IsNil(o.Details) {
		return true
	}

	return false
}




// HasHost returns a boolean if a field has been set.
func (o *RegistrySvcInstance) HasHost() bool {
	if o != nil && !IsNil(o.Host) {
		return true
	}

	return false
}







// HasIp returns a boolean if a field has been set.
func (o *RegistrySvcInstance) HasIp() bool {
	if o != nil && !IsNil(o.Ip) {
		return true
	}

	return false
}




// HasLastHeartbeat returns a boolean if a field has been set.
func (o *RegistrySvcInstance) HasLastHeartbeat() bool {
	if o != nil && !IsNil(o.LastHeartbeat) {
		return true
	}

	return false
}




// HasNodeUrl returns a boolean if a field has been set.
func (o *RegistrySvcInstance) HasNodeUrl() bool {
	if o != nil && !IsNil(o.NodeUrl) {
		return true
	}

	return false
}




// HasPath returns a boolean if a field has been set.
func (o *RegistrySvcInstance) HasPath() bool {
	if o != nil && !IsNil(o.Path) {
		return true
	}

	return false
}




// HasPort returns a boolean if a field has been set.
func (o *RegistrySvcInstance) HasPort() bool {
	if o != nil && !IsNil(o.Port) {
		return true
	}

	return false
}




// HasScheme returns a boolean if a field has been set.
func (o *RegistrySvcInstance) HasScheme() bool {
	if o != nil && !IsNil(o.Scheme) {
		return true
	}

	return false
}




// HasSlug returns a boolean if a field has been set.
func (o *RegistrySvcInstance) HasSlug() bool {
	if o != nil && !IsNil(o.Slug) {
		return true
	}

	return false
}







// HasTags returns a boolean if a field has been set.
func (o *RegistrySvcInstance) HasTags() bool {
	if o != nil && !IsNil(o.Tags) {
		return true
	}

	return false
}





func (o RegistrySvcInstance) MarshalJSON() ([]byte, error) {
	toSerialize,err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o RegistrySvcInstance) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	if !IsNil(o.DeploymentId) {
		toSerialize["deploymentId"] = o.DeploymentId
	}
	if !IsNil(o.Details) {
		toSerialize["details"] = o.Details
	}
	if !IsNil(o.Host) {
		toSerialize["host"] = o.Host
	}
	toSerialize["id"] = o.Id
	if !IsNil(o.Ip) {
		toSerialize["ip"] = o.Ip
	}
	if !IsNil(o.LastHeartbeat) {
		toSerialize["lastHeartbeat"] = o.LastHeartbeat
	}
	if !IsNil(o.NodeUrl) {
		toSerialize["nodeUrl"] = o.NodeUrl
	}
	if !IsNil(o.Path) {
		toSerialize["path"] = o.Path
	}
	if !IsNil(o.Port) {
		toSerialize["port"] = o.Port
	}
	if !IsNil(o.Scheme) {
		toSerialize["scheme"] = o.Scheme
	}
	if !IsNil(o.Slug) {
		toSerialize["slug"] = o.Slug
	}
	toSerialize["status"] = o.Status
	if !IsNil(o.Tags) {
		toSerialize["tags"] = o.Tags
	}
	toSerialize["url"] = o.Url
	return toSerialize, nil
}

func (o *RegistrySvcInstance) UnmarshalJSON(data []byte) (err error) {
	// This validates that all required properties are included in the JSON object
	// by unmarshalling the object into a generic map with string keys and checking
	// that every required field exists as a key in the generic map.
	requiredProperties := []string{
		"id",
		"status",
		"url",
	}

	allProperties := make(map[string]interface{})

	err = json.Unmarshal(data, &allProperties)

	if err != nil {
		return err;
	}

	for _, requiredProperty := range(requiredProperties) {
		if _, exists := allProperties[requiredProperty]; !exists {
			return fmt.Errorf("no value given for required property %v", requiredProperty)
		}
	}

	varRegistrySvcInstance := _RegistrySvcInstance{}

	decoder := json.NewDecoder(bytes.NewReader(data))
	decoder.DisallowUnknownFields()
	err = decoder.Decode(&varRegistrySvcInstance)

	if err != nil {
		return err
	}

	*o = RegistrySvcInstance(varRegistrySvcInstance)

	return err
}

type NullableRegistrySvcInstance struct {
	value *RegistrySvcInstance
	isSet bool
}

func (v NullableRegistrySvcInstance) Get() *RegistrySvcInstance {
	return v.value
}

func (v *NullableRegistrySvcInstance) Set(val *RegistrySvcInstance) {
	v.value = val
	v.isSet = true
}

func (v NullableRegistrySvcInstance) IsSet() bool {
	return v.isSet
}

func (v *NullableRegistrySvcInstance) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableRegistrySvcInstance(val *RegistrySvcInstance) *NullableRegistrySvcInstance {
	return &NullableRegistrySvcInstance{value: val, isSet: true}
}

func (v NullableRegistrySvcInstance) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableRegistrySvcInstance) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


