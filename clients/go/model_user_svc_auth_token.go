/*
1Backend

AI-native microservices platform.

API version: 0.8.0-rc1
Contact: sales@singulatron.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"encoding/json"
	"bytes"
	"fmt"
)

// checks if the UserSvcAuthToken type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &UserSvcAuthToken{}

// UserSvcAuthToken struct for UserSvcAuthToken
type UserSvcAuthToken struct {
	// Active tokens contain the most up-to-date information. When a user's role changes—due to role assignment, organization creation/assignment, etc.—all existing tokens are marked inactive. Active tokens are reused during login, while inactive tokens that have been recently refreshed (being used still) are kept for further refreshing (unless `OB_TOKEN_AUTO_REFRESH_OFF` is set to true, old tokens can be refreshed indefinitely.)  Active tokens contain the most up-to-date information. When a user's role changes—due to role assignment, organization creation/assignment, etc.—all existing tokens are marked inactive. Active tokens are reused during login, while inactive tokens that have been recently refreshed (see `lastRefreshedAt` field) and are still in use are retained for further refreshing. (Unless `OB_TOKEN_AUTO_REFRESH_OFF` is set to true, in which case old tokens can be refreshed indefinitely.)
	Active *bool `json:"active,omitempty"`
	App *string `json:"app,omitempty"`
	CreatedAt string `json:"createdAt"`
	DeletedAt *string `json:"deletedAt,omitempty"`
	// The device the token is associated with. This in combination with LastRefreshedAt can be used to determine if the token is still in use, and lets us prune unused tokens.
	Device string `json:"device"`
	ExpiresAt string `json:"expiresAt"`
	Id string `json:"id"`
	// The last time the token was refreshed. This is used to determine if the token is still in use.
	LastRefreshedAt *string `json:"lastRefreshedAt,omitempty"`
	// Token is a signed JWT used to authenticate the user without querying the User Svc. You can verify it using the public key at `/user-svc/public-key`.  The token is just a JSON object with fields like: - \"oui\": the user ID (e.g., \"usr_dC4K75Cbp6\") - \"olu\": the user slug (e.g., \"test-user-slug-0\") - \"oro\": a list of roles, such as:   - \"user-svc:user\"   - \"user-svc:org:{org_dC4K7NNDCG}:user\"
	Token string `json:"token"`
	UpdatedAt string `json:"updatedAt"`
	UserId string `json:"userId"`
}

type _UserSvcAuthToken UserSvcAuthToken

// NewUserSvcAuthToken instantiates a new UserSvcAuthToken object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewUserSvcAuthToken(createdAt string, device string, expiresAt string, id string, token string, updatedAt string, userId string) *UserSvcAuthToken {
	this := UserSvcAuthToken{}
	this.CreatedAt = createdAt
	this.Device = device
	this.ExpiresAt = expiresAt
	this.Id = id
	this.Token = token
	this.UpdatedAt = updatedAt
	this.UserId = userId
	return &this
}

// NewUserSvcAuthTokenWithDefaults instantiates a new UserSvcAuthToken object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewUserSvcAuthTokenWithDefaults() *UserSvcAuthToken {
	this := UserSvcAuthToken{}
	return &this
}



// HasActive returns a boolean if a field has been set.
func (o *UserSvcAuthToken) HasActive() bool {
	if o != nil && !IsNil(o.Active) {
		return true
	}

	return false
}




// HasApp returns a boolean if a field has been set.
func (o *UserSvcAuthToken) HasApp() bool {
	if o != nil && !IsNil(o.App) {
		return true
	}

	return false
}







// HasDeletedAt returns a boolean if a field has been set.
func (o *UserSvcAuthToken) HasDeletedAt() bool {
	if o != nil && !IsNil(o.DeletedAt) {
		return true
	}

	return false
}













// HasLastRefreshedAt returns a boolean if a field has been set.
func (o *UserSvcAuthToken) HasLastRefreshedAt() bool {
	if o != nil && !IsNil(o.LastRefreshedAt) {
		return true
	}

	return false
}











func (o UserSvcAuthToken) MarshalJSON() ([]byte, error) {
	toSerialize,err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o UserSvcAuthToken) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	if !IsNil(o.Active) {
		toSerialize["active"] = o.Active
	}
	if !IsNil(o.App) {
		toSerialize["app"] = o.App
	}
	toSerialize["createdAt"] = o.CreatedAt
	if !IsNil(o.DeletedAt) {
		toSerialize["deletedAt"] = o.DeletedAt
	}
	toSerialize["device"] = o.Device
	toSerialize["expiresAt"] = o.ExpiresAt
	toSerialize["id"] = o.Id
	if !IsNil(o.LastRefreshedAt) {
		toSerialize["lastRefreshedAt"] = o.LastRefreshedAt
	}
	toSerialize["token"] = o.Token
	toSerialize["updatedAt"] = o.UpdatedAt
	toSerialize["userId"] = o.UserId
	return toSerialize, nil
}

func (o *UserSvcAuthToken) UnmarshalJSON(data []byte) (err error) {
	// This validates that all required properties are included in the JSON object
	// by unmarshalling the object into a generic map with string keys and checking
	// that every required field exists as a key in the generic map.
	requiredProperties := []string{
		"createdAt",
		"device",
		"expiresAt",
		"id",
		"token",
		"updatedAt",
		"userId",
	}

	allProperties := make(map[string]interface{})

	err = json.Unmarshal(data, &allProperties)

	if err != nil {
		return err;
	}

	for _, requiredProperty := range(requiredProperties) {
		if _, exists := allProperties[requiredProperty]; !exists {
			return fmt.Errorf("no value given for required property %v", requiredProperty)
		}
	}

	varUserSvcAuthToken := _UserSvcAuthToken{}

	decoder := json.NewDecoder(bytes.NewReader(data))
	decoder.DisallowUnknownFields()
	err = decoder.Decode(&varUserSvcAuthToken)

	if err != nil {
		return err
	}

	*o = UserSvcAuthToken(varUserSvcAuthToken)

	return err
}

type NullableUserSvcAuthToken struct {
	value *UserSvcAuthToken
	isSet bool
}

func (v NullableUserSvcAuthToken) Get() *UserSvcAuthToken {
	return v.value
}

func (v *NullableUserSvcAuthToken) Set(val *UserSvcAuthToken) {
	v.value = val
	v.isSet = true
}

func (v NullableUserSvcAuthToken) IsSet() bool {
	return v.isSet
}

func (v *NullableUserSvcAuthToken) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableUserSvcAuthToken(val *UserSvcAuthToken) *NullableUserSvcAuthToken {
	return &NullableUserSvcAuthToken{value: val, isSet: true}
}

func (v NullableUserSvcAuthToken) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableUserSvcAuthToken) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


