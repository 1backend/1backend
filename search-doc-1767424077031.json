{"searchDocs":[{"title":"Long Blog Post","type":0,"sectionRef":"#","url":"/blog/long-blog-post","content":"This is the summary of a very long blog post, Use a &lt;!-- truncate --&gt; comment to limit blog post size in the list view. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":null},{"title":"MDX Blog Post","type":0,"sectionRef":"#","url":"/blog/mdx-blog-post","content":"Blog posts support Docusaurus Markdown features, such as MDX. tip Use the power of React to create interactive blog posts. &lt;button onClick={() =&gt; alert('button clicked!')}&gt;Click me!&lt;/button&gt; Click me!","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":null},{"title":"First Blog Post","type":0,"sectionRef":"#","url":"/blog/first-blog-post","content":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":null},{"title":"Welcome","type":0,"sectionRef":"#","url":"/blog/welcome","content":"Docusaurus blogging features are powered by the blog plugin. Simply add Markdown files (or folders) to the blog directory. Regular blog authors can be added to authors.yml. The blog post date can be extracted from filenames, such as: 2019-05-30-welcome.md2019-05-30-welcome/index.md A blog post folder can be convenient to co-locate blog post images: The blog supports tags as well! And if you don't want a blog: just delete this directory, and use blog: false in your Docusaurus config.","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":null},{"title":"1Backend","type":0,"sectionRef":"#","url":"/docs/1backend-api/1-backend","content":"Version: 0.9.4 Export OpenAPI Spec 1Backend AI-native microservices platform. Authentication​ API Key: BearerAuth Type &quot;Bearer&quot; followed by a space and token acquired from the User Svc Login endpoint. Security Scheme Type: apiKey Header parameter name: Authorization Contact API Support: sales@singulatron.com URL: http://1backend.com/ Terms of Service http://swagger.io/terms/ License AGPL v3.0","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Build an Image","type":0,"sectionRef":"#","url":"/docs/1backend-api/build-image","content":"Build an Image PUT /container-svc/image Builds a Docker image with the specified parameters. Requires the container-svc:image:build permission. Request​ Responses​ 200400401500 OK","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Check","type":0,"sectionRef":"#","url":"/docs/1backend-api/check","content":"Check POST /policy-svc/check Check records a resource access and returns if the access is allowed. Request​ Responses​ 200400401500 Checked successfully","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Change Password","type":0,"sectionRef":"#","url":"/docs/1backend-api/change-password","content":"Change Password POST /user-svc/change-password Allows an authenticated user to change their own password. Request​ Responses​ 200400401500 Password changed successfully","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Checkout a git repository","type":0,"sectionRef":"#","url":"/docs/1backend-api/checkout-repo","content":"Checkout a git repository POST /source-svc/repo/checkout Checkout a git repository over https or ssh at a specific version into a temporary directory. Performs a shallow clone with minimal history for faster checkout. Request​ Responses​ 200400401500 Successfully checked out the repository","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Get Container Daemon Information","type":0,"sectionRef":"#","url":"/docs/1backend-api/container-daemon-info","content":"Get Container Daemon Information GET /container-svc/daemon/info Retrieve detailed information about the availability and status of container daemons on the node. Responses​ 200401500 Service Information","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Check If a Container Is Running","type":0,"sectionRef":"#","url":"/docs/1backend-api/container-is-running","content":"Check If a Container Is Running GET /container-svc/container/is-running Check if a Docker container is running, identified by hash or name. Request​ Responses​ 200400401500 OK","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Get Container Summary","type":0,"sectionRef":"#","url":"/docs/1backend-api/container-summary","content":"Get Container Summary GET /container-svc/container/summary Get a summary of the Docker container identified by hash or name, limited to a specified number of lines. Request​ Responses​ 200400401500 OK","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Create a Generic Object","type":0,"sectionRef":"#","url":"/docs/1backend-api/create-object","content":"Create a Generic Object POST /data-svc/object Creates a new object with the provided details. Requires authorization and user authentication. Request​ Responses​ 200400401500 Success","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Decrypt a Value","type":0,"sectionRef":"#","url":"/docs/1backend-api/decrypt-value","content":"Decrypt a Value POST /secret-svc/decrypt Decrypt a value and return the encrypted result Request​ Responses​ 200400401500 Decrypt Value Response","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Create a New User","type":0,"sectionRef":"#","url":"/docs/1backend-api/create-user","content":"Create a New User POST /user-svc/user Allows an authenticated administrator to create a new user with specified details. Request​ Responses​ 200400401500 User created successfully","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Delete Definition","type":0,"sectionRef":"#","url":"/docs/1backend-api/delete-definition","content":"Delete Definition DELETE /registry-svc/definition/:id Deletes a registered definition by ID. Request​ Responses​ 204400401404500 No Content","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Delete Membership","type":0,"sectionRef":"#","url":"/docs/1backend-api/delete-membership","content":"Delete Membership DELETE /user-svc/organization/:organizationId/user/:userId Allows an organization admin to remove a user from an organization. Request​ Responses​ 200400401403404500 User added successfully","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Delete a Message","type":0,"sectionRef":"#","url":"/docs/1backend-api/delete-message","content":"Delete a Message DELETE /chat-svc/message/:messageId Delete a specific message from a chat thread by its ID Request​ Responses​ 200400401500 Message successfully deleted","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Delete a User","type":0,"sectionRef":"#","url":"/docs/1backend-api/delete-user","content":"Delete a User DELETE /user-svc/user/:userId Delete a user based on the user ID. Request​ Responses​ 200401500 OK","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Delete Node","type":0,"sectionRef":"#","url":"/docs/1backend-api/delete-node","content":"Delete Node DELETE /registry-svc/node/:url Deletes a registered node by node URL. This endpoint is useful when a node is no longer available but it's still present in the database. Request​ Responses​ 204400401404500 No Content","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Delete Objects","type":0,"sectionRef":"#","url":"/docs/1backend-api/delete-objects","content":"Delete Objects POST /data-svc/objects/delete Deletes all objects matchin the provided filters. Request​ Responses​ 200400401500 Successful deletion of object","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Delete a Thread","type":0,"sectionRef":"#","url":"/docs/1backend-api/delete-thread","content":"Delete a Thread DELETE /chat-svc/thread/:threadId Delete a specific chat thread by its ID Request​ Responses​ 200400401500 Thread successfully deleted","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Download a File","type":0,"sectionRef":"#","url":"/docs/1backend-api/download-file","content":"Download a File PUT /file-svc/download Start or resume the download for a specified URL. Requires the file-svc:download:create permission. Request​ Responses​ 200400401500 Download initiated successfully","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Echo the query parameters in the response body.","type":0,"sectionRef":"#","url":"/docs/1backend-api/echo-get","content":"Echo the query parameters in the response body. GET /registry-svc/echo This endpoint is used to test the server's response to a GET request. It echoes back the query parameters as a JSON object. Responses​ 200 Echoed query parameters","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Echo the request body in the response body.","type":0,"sectionRef":"#","url":"/docs/1backend-api/echo-put","content":"Echo the request body in the response body. PUT /registry-svc/echo This endpoint is used to test the server's response to a request. It simply echoes back the request body as a JSON response. Responses​ 200400 Echoed response","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Events","type":0,"sectionRef":"#","url":"/docs/1backend-api/events","content":"Events GET /chat-svc/events Events is a dummy endpoint to display documentation about the events that this service emits. Responses​ 200 OK","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Encrypt a Value","type":0,"sectionRef":"#","url":"/docs/1backend-api/encrypt-value","content":"Encrypt a Value POST /secret-svc/encrypt Encrypt a value and return the encrypted result Request​ Responses​ 200400401500 Encrypt Value Response","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Exchange Token","type":0,"sectionRef":"#","url":"/docs/1backend-api/exchange-token","content":"Exchange Token PUT /user-svc/token/exchange Exchange an existing token for a new token scoped to a different app (namespace). The new token represents the same user but contains roles specific to the target app. The original token remains valid. The minted token is not stored and cannot be refreshed (and will have the same expiration duration as normal tokens), unlike tokens acquired via login. For now, token exchange is designed to be in situ — the User Svc must be contacted at exchange time. This introduces a stateful dependency on the User Svc, but simplifies things until broader use cases emerge. Request​ Responses​ 200400404500 ExchangeToken successful","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Get Default Model Status","type":0,"sectionRef":"#","url":"/docs/1backend-api/get-default-model-status","content":"Get Default Model Status GET /model-svc/default-model/status Retrieves the status of the default model. Requires the model-svc:model:view permission. Responses​ 200401500 Model status retrieved successfully","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Get Container Host","type":0,"sectionRef":"#","url":"/docs/1backend-api/get-host","content":"Get Container Host GET /container-svc/host Retrieve information about the Container host Responses​ 200401500 OK","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Get a Download","type":0,"sectionRef":"#","url":"/docs/1backend-api/get-download","content":"Get a Download GET /file-svc/download/:url Get a download by URL. Requires the file-svc:download:view permission. Request​ Responses​ 200400401500 OK","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Echo the request body in the response body.","type":0,"sectionRef":"#","url":"/docs/1backend-api/echo-post","content":"Echo the request body in the response body. POST /registry-svc/echo This endpoint is used to test the server's response to a request. It simply echoes back the request body as a JSON response. Responses​ 200400 Echoed response","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Get a Model","type":0,"sectionRef":"#","url":"/docs/1backend-api/get-model","content":"Get a Model GET /model-svc/model/:modelId Retrieves the details of a model by its ID. the Requires model.view permission. Request​ Responses​ 200400401404500 OK","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Get Model Status","type":0,"sectionRef":"#","url":"/docs/1backend-api/get-model-status","content":"Get Model Status GET /model-svc/model/:modelId/status Retrieves the status of a model by ID. Requires the model-svc:model:view permission. Request​ Responses​ 200401500 Model status retrieved successfully","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Has Permission","type":0,"sectionRef":"#","url":"/docs/1backend-api/has-permission","content":"Has Permission POST /user-svc/self/has/:permission Checks whether the caller has a specific permission. Optimized for caching — only the caller and the permission are required. To assign a permission to a user or role, use the Save Permits endpoint. This endpoint does not return 401 Unauthorized if access is denied. Instead, it always returns 200 OK with Authorized: false if the permission is missing. The response will still include the caller’s user information if not authorized. Request​ Responses​ 200400422 OK","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Get Public Key","type":0,"sectionRef":"#","url":"/docs/1backend-api/get-public-key","content":"Get Public Key GET /user-svc/public-key Get the public key to verify the JWT signature. Responses​ 200400401 OK","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Check if Container Image is Pullable","type":0,"sectionRef":"#","url":"/docs/1backend-api/image-pullable","content":"Check if Container Image is Pullable GET /container-svc/image/:imageName/pullable Check if an image exists on in the container registry and is pullable. Request​ Responses​ 200400401500 OK","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Check Security Status","type":0,"sectionRef":"#","url":"/docs/1backend-api/is-secure","content":"Check Security Status GET /secret-svc/is-secure Returns true if the encryption key is sufficiently secure. Responses​ 200400401500 Encrypt Value Response","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"List Apps","type":0,"sectionRef":"#","url":"/docs/1backend-api/list-apps","content":"List Apps POST /user-svc/apps List apps. Role, user ID or contact ID must be specified. Requires the user-svc:app:view permission, which by default all users have. Caller can only list apps of roles they own (unless they are an admin). Request​ Responses​ 200401500 Apps listed successfully","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"List Versions","type":0,"sectionRef":"#","url":"/docs/1backend-api/list-config-versions","content":"List Versions POST /config-svc/versions Returns the historical versions of a configuration for a given app. Intended for retrieving the version history of a single configuration ID. Supplying multiple IDs is supported but not recommended, since results from different IDs will interleave in the same time-ordered list, making chronological paging ambiguous. Request​ Responses​ 200401500 Current configuration","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"List Configs","type":0,"sectionRef":"#","url":"/docs/1backend-api/list-configs","content":"List Configs POST /config-svc/configs Retrieves the current configurations for a specified app. Since any user can save configurations, it is strongly advised that you supply a list of owners to filter on. If no app is specified, the default &quot;unnamed&quot; app is used. This is a public endpoint and does not require authentication. Configuration data is non-sensitive. For sensitive data, refer to the Secret Service. Configurations are used to control frontend behavior, A/B testing, feature flags, and other non-sensitive settings. Request​ Responses​ 200401500 Current configuration","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"List Certs","type":0,"sectionRef":"#","url":"/docs/1backend-api/list-certs","content":"List Certs POST /proxy-svc/certs List certs that the edge proxy will use to cert requests. Request​ Responses​ 200400401500 Certs listed successfully","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"List Containers","type":0,"sectionRef":"#","url":"/docs/1backend-api/list-containers","content":"List Containers POST /container-svc/containers List containers. Requires the container-svc:container:view permission. Request​ Responses​ 200400401500 OK","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"List Logs","type":0,"sectionRef":"#","url":"/docs/1backend-api/list-container-logs","content":"List Logs POST /container-svc/logs List Container logs. Requires the container-svc:log:view permission. Request​ Responses​ 200400401500 OK","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"List Downloads","type":0,"sectionRef":"#","url":"/docs/1backend-api/list-downloads","content":"List Downloads POST /file-svc/downloads List download details. Requires the file-svc:download:view permission. Responses​ 200401500 List of downloads","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"List Definitions","type":0,"sectionRef":"#","url":"/docs/1backend-api/list-definitions","content":"List Definitions GET /registry-svc/definitions Retrieves a list of all definitions or filters them by specific criteria. Responses​ 200400500 OK","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"List Enrolls","type":0,"sectionRef":"#","url":"/docs/1backend-api/list-enrolls","content":"List Enrolls POST /user-svc/enrolls List enrolls. Role, user ID or contact ID must be specified. Requires the user-svc:enroll:view permission, which by default all users have. Caller can only list enrolls of roles they own (unless they are an admin). Request​ Responses​ 200400401500 Enrolls listed successfully","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"List Messages","type":0,"sectionRef":"#","url":"/docs/1backend-api/list-messages","content":"List Messages POST /chat-svc/messages Fetch messages (and associated assets) for a specific chat thread. Request​ Responses​ 200400401500 Messages and assets successfully retrieved","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"List Service Instances","type":0,"sectionRef":"#","url":"/docs/1backend-api/list-instances","content":"List Service Instances GET /registry-svc/instances Retrieves a list of all instances or filters them by specific criteria (e.g., host, IP). Request​ Responses​ 200400500 OK","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"List Models","type":0,"sectionRef":"#","url":"/docs/1backend-api/list-models","content":"List Models POST /model-svc/models Retrieves a list of models. Requires model-svc:model:view permission. Responses​ 200401500 OK","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"List Organizations","type":0,"sectionRef":"#","url":"/docs/1backend-api/list-organizations","content":"List Organizations POST /user-svc/organizations Requires the user-svc:organization:view permission, that only admins have by default. Request​ Responses​ 200400401500 Organization listed successfully","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"List Permits","type":0,"sectionRef":"#","url":"/docs/1backend-api/list-permits","content":"List Permits POST /user-svc/permits List permits. Requires the user-svc:permit:view permission, which only admins have by default. &amp;todo Users should be able to list permits referring to them. Request​ Responses​ 200401500 OK","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"List Nodes","type":0,"sectionRef":"#","url":"/docs/1backend-api/list-nodes","content":"List Nodes POST /registry-svc/nodes Retrieve a list of nodes. Request​ Responses​ 200400401500 OK","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"List Permissions","type":0,"sectionRef":"#","url":"/docs/1backend-api/list-permissions","content":"List Permissions POST /user-svc/permissions List permissions by roles. Caller can only list permissions for roles they have. Request​ Responses​ 200400401500 OK","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"List Prompts","type":0,"sectionRef":"#","url":"/docs/1backend-api/list-prompts","content":"List Prompts POST /prompt-svc/prompts List prompts that satisfy a query. Request​ Responses​ 200400401500 OK","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"List Routes","type":0,"sectionRef":"#","url":"/docs/1backend-api/list-routes","content":"List Routes POST /proxy-svc/routes List routes that the edge proxy will use to route requests. Request​ Responses​ 200400401500 Routes listd successfully","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"List Platforms","type":0,"sectionRef":"#","url":"/docs/1backend-api/list-platforms","content":"List Platforms POST /model-svc/platforms Retrieves a list of AI platforms. Eg. LlamaCpp, StableDiffusion etc. Requires model-svc:platform:view permission. Responses​ 200401500 OK","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"List Secrets","type":0,"sectionRef":"#","url":"/docs/1backend-api/list-secrets","content":"List Secrets POST /secret-svc/secrets List secrets by key(s) if authorized. Request​ Responses​ 200401500 List Secret Response","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"List Uploads","type":0,"sectionRef":"#","url":"/docs/1backend-api/list-uploads","content":"List Uploads POST /file-svc/uploads Lists uploaded files, returning only metadata about each upload. To retrieve file content, use the Serve an Uploaded File endpoint, which serves a single file per request. Note: Retrieving the contents of multiple files in a single request is not supported currently. Requires the file-svc:upload:view permission. Request​ Responses​ 200401500 List of uploads","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"List Threads","type":0,"sectionRef":"#","url":"/docs/1backend-api/list-threads","content":"List Threads POST /chat-svc/threads Fetch all chat threads associated with a specific user Request​ Responses​ 200400401500 Threads successfully retrieved","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Pause a Download","type":0,"sectionRef":"#","url":"/docs/1backend-api/pause-download","content":"Pause a Download PUT /file-svc/download/:url/pause Pause a download that is currently in progress. Requires the file-svc:download:edit permission. Request​ Responses​ 200400401500 Success response","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"List Users","type":0,"sectionRef":"#","url":"/docs/1backend-api/list-users","content":"List Users POST /user-svc/users Fetches a list of users with optional query filters and pagination. Requires the user-svc:user:view permission that only admins have by default. Request​ Responses​ 200400401500 List of users retrieved successfully","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Make a Model Default","type":0,"sectionRef":"#","url":"/docs/1backend-api/make-default","content":"Make a Model Default PUT /model-svc/model/:modelId/make-default Sets a model as the default model — when prompts are sent without a Model ID, the default model is used. Request​ Responses​ 200400401500 OK","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Login","type":0,"sectionRef":"#","url":"/docs/1backend-api/login","content":"Login POST /user-svc/login Authenticates a user and returns a token. Request​ Responses​ 200400404500 Login successful","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Prompt an AI","type":0,"sectionRef":"#","url":"/docs/1backend-api/prompt","content":"Prompt an AI POST /prompt-svc/prompt Sends a prompt and waits for a response if sync is true. If sync is false, adds the prompt to the queue and returns immediately. Prompts can be used for text-to-text, text-to-image, image-to-image, and other types of generation. If no model ID is specified, the default model will be used (see Model Svc for details). The default model may or may not support the requested generation type. Prompting Modes High-Level Parameters: Uses predefined parameters relevant to text-to-image, image-to-image, etc. This mode abstracts away the underlying engine (e.g., LLaMA, Stable Diffusion) and focuses on functionality.Engine-Specific Parameters: Uses engineParameters to directly specify an AI engine, exposing all available parameters for fine-tuned control. Permissions Required: prompt-svc:prompt:create Request​ Responses​ 200400401500 OK","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Prompt Types","type":0,"sectionRef":"#","url":"/docs/1backend-api/prompt-types","content":"Prompt Types POST /prompt-svc/types The only purpose of this &quot;endpoint&quot; is to export types otherwise not appearing in the API docs. This endpoint otherwise does nothing. Do not depend on this endpoint, only its types. Request​ Responses​ 200400401500 OK","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Publish an Event","type":0,"sectionRef":"#","url":"/docs/1backend-api/publish-event","content":"Publish an Event POST /firehose-svc/event Publishes an event to the firehose service after authorization check Request​ Responses​ 200400401 {}","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Query Objects","type":0,"sectionRef":"#","url":"/docs/1backend-api/query-objects","content":"Query Objects POST /data-svc/objects Retrieves objects from a specified table based on search criteria. Requires authorization and user authentication. Use helper functions in your respective client library such as condition constructors (equal, contains, startsWith) and field selectors (field, fields, id) for easier access. Request​ Responses​ 200400401500 Successful retrieval of objects","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Refresh Token","type":0,"sectionRef":"#","url":"/docs/1backend-api/refresh-token","content":"Refresh Token POST /user-svc/refresh-token Refreshes an existing token, including inactive ones. The old token becomes inactive (if not already inactive), and a new, active token is issued. This allows continued verification of user roles without requiring a new login. Inactive tokens are refreshable unless explicitly revoked (no mechanism for this yet). Leaked tokens should be handled separately, via a revocation flag or deletion. Responses​ 200401500 Refresh Token successful","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Read or Create App","type":0,"sectionRef":"#","url":"/docs/1backend-api/read-app","content":"Read or Create App POST /user-svc/app Get an app by host, or create it if it does not exist. Request​ Responses​ 200401500 App retrieved or created successfully","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Register","type":0,"sectionRef":"#","url":"/docs/1backend-api/register","content":"Register POST /user-svc/register Register a new user with a name, email, and password. Request​ Responses​ 200400500 OK","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Read Self","type":0,"sectionRef":"#","url":"/docs/1backend-api/read-self","content":"Read Self POST /user-svc/self Retrieves user information based on the authentication token in the request header. Typically called by single-page applications during the initial page load. While some details (such as roles, slug, user ID, and active organization ID) can be extracted from the JWT, this endpoint returns additional data, including the full user object and associated organizations. ReadSelf intentionally still works after token revocation until the token expires. This is to ensure that the user is not notified of token revocation (though some information is leaked by the count token functionality @todo). Request​ Responses​ 200400500 OK","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Register Instance","type":0,"sectionRef":"#","url":"/docs/1backend-api/register-instance","content":"Register Instance PUT /registry-svc/instance Registers an instance. Idempotent. Request​ Responses​ 201400401500 Created","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Remove Prompt","type":0,"sectionRef":"#","url":"/docs/1backend-api/remove-prompt","content":"Remove Prompt POST /prompt-svc/remove Remove a prompt by ID. Request​ Responses​ 200400401500 {}","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Remove Instance","type":0,"sectionRef":"#","url":"/docs/1backend-api/remove-instance","content":"Remove Instance DELETE /registry-svc/instance/:id Removes a registered instance by ID. Request​ Responses​ 204400401404500 No Content","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Reset Password","type":0,"sectionRef":"#","url":"/docs/1backend-api/reset-password","content":"Reset Password POST /user-svc/:userId/reset-password Allows an administrator to change a user's password. Request​ Responses​ 200400401500 Password changed successfully","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Run a Container","type":0,"sectionRef":"#","url":"/docs/1backend-api/run-container","content":"Run a Container PUT /container-svc/container Runs a Docker container with the specified parameters. Requires the container-svc:container:run permission. Request​ Responses​ 200400401500 OK","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Revoke Tokens","type":0,"sectionRef":"#","url":"/docs/1backend-api/revoke-tokens","content":"Revoke Tokens DELETE /user-svc/tokens Revoke tokens in one of the following scenarios: For the current user.For another user (see userId field), if permitted (user-svc:token:revoke permission, typically by admins). Request​ Responses​ 200400500 OK","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Remove Secrets","type":0,"sectionRef":"#","url":"/docs/1backend-api/remove-secrets","content":"Remove Secrets DELETE /secret-svc/secrets Remove secrets if authorized to do so Request​ Responses​ 200401500 Remove Secret Response","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Save Certs","type":0,"sectionRef":"#","url":"/docs/1backend-api/save-certs","content":"Save Certs PUT /proxy-svc/certs This endpoint only exist for testing purposes. Only callable by admins Certs should be saved by the Proxy Svc and its edge proxying functionality internally, not through this endpoint. Request​ Responses​ 200400401500 Certs saved successfully","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Save Config","type":0,"sectionRef":"#","url":"/docs/1backend-api/save-config","content":"Save Config PUT /config-svc/config Save the provided configuration to the server. The app from the caller's token is used to determine which app the config belongs to. The caller's camelCased slug (e.g., &quot;test-user-slug&quot; becomes &quot;testUserSlug&quot;) is used as the config key automatically, except for users who have the &quot;config-svc:config:edit-on-behalf&quot; permission (admins), who can specify any key they want. Admins (users with the &quot;config-svc:config:edit-on-behalf&quot; permission) can also provide an &quot;app&quot; field in the request body to specify which app the config belongs to, while non-admin users cannot specify the &quot;app&quot; field, the app associated with their token will be used. The save performs a deep merge, that is: Nested objects are recursively merged rather than replaced.If a field exists in both the existing and the incoming config and both values are objects, their contents are merged.If a field exists in both but one or both values are not objects (e.g., string, number, array), the incoming value replaces the existing one.Fields present only in the incoming config are added.Fields present only in the existing config are preserved.Top-level and nested merges follow the same rules. Request​ Responses​ 200401500 Save Config Response","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Register a Definition","type":0,"sectionRef":"#","url":"/docs/1backend-api/save-definition","content":"Register a Definition PUT /registry-svc/definition Registers a new definition, associating an definition address with a slug acquired from the bearer token. Request​ Responses​ 201400401500 Created","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Save Enrolls","type":0,"sectionRef":"#","url":"/docs/1backend-api/save-enrolls","content":"Save Enrolls PUT /user-svc/enrolls Enroll a list of users by contact or user Id to acquire a role. Works on future or current users. A user can only enroll an other user to a role if the user &quot;owns&quot; that role. A user who owns a role can enroll others in that roll in any app. The same request might contain enrolls for different apps. A user &quot;owns&quot; a role in the following cases: A static role where the role ID is prefixed with the caller's slug.Any dynamic or static role where the caller is an admin (has *:admin postfix of that role). Examples: A user with the slug joe-doe owns roles like joe-doe:* such as joe-doe:any-custom-role.A user with any slug who has the role my-service:admin owns my-service:* roles such as my-service:user.A user with any slug who has the role user-svc:org:{%orgId}:admin owns user-svc:org:{%orgId}:* such as user-svc:org:{%orgId}:user. Request​ Responses​ 200400401500 Enrolls saved successfully","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Save Membership","type":0,"sectionRef":"#","url":"/docs/1backend-api/save-membership","content":"Save Membership PUT /user-svc/organization/:organizationId/user/:userId Adds a user to an organization by saving a Membership. Also issues the corresponding Enroll, which grants the user their dynamic organization role (e.g. user-svc:org:{org_123}:user). Request​ Responses​ 200400401403404500 User added successfully","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Save Message","type":0,"sectionRef":"#","url":"/docs/1backend-api/save-message","content":"Save Message POST /chat-svc/thread/:threadId/message Save a new message to a specific thread. Request​ Responses​ 200400401500 Message successfully added","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Save an Organization","type":0,"sectionRef":"#","url":"/docs/1backend-api/save-organization","content":"Save an Organization PUT /user-svc/organization Allows a logged-in user to save an organization. The user initiating the request will be assigned the role of admin for that organization. The initiating user will receive a dynamic role in the format user-svc:org:{organizationId}:admin, where {organizationId} is a unique identifier for the saved organization. Dynamic roles are generated based on specific user-resource associations (in this case the resource being the organization), offering more flexible permission management compared to static roles. Request​ Responses​ 200400401500 User saved successfully","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Save Routes","type":0,"sectionRef":"#","url":"/docs/1backend-api/save-routes","content":"Save Routes PUT /proxy-svc/routes Save routes that the edge proxy will use to route requests. Request​ Responses​ 200400401500 Routes saved successfully","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Save Permits","type":0,"sectionRef":"#","url":"/docs/1backend-api/save-permits","content":"Save Permits PUT /user-svc/permits Save permits. Permits give access to users with certain slugs and roles to permissions. Request​ Responses​ 200400401500 Permit saved successfully","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Save Secrets","type":0,"sectionRef":"#","url":"/docs/1backend-api/save-secrets","content":"Save Secrets PUT /secret-svc/secrets Save secrets if authorized to do so. Requires the secret-svc:secret:save permission. Users can only save secrets prefixed with their user slug unless they also have thesecret-svc:secret:save-unprefixed permission, which allows them to save a secret without a slug prefix. Request​ Responses​ 200401500 Save Secret Response","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Save Thread","type":0,"sectionRef":"#","url":"/docs/1backend-api/save-thread","content":"Save Thread POST /chat-svc/thread Create or update a chat thread. Requires the chat-svc:thread:edit permission. Request​ Responses​ 200400401500 Thread successfully created","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Save User Profile","type":0,"sectionRef":"#","url":"/docs/1backend-api/save-self","content":"Save User Profile PUT /user-svc/self Save user's own profile information. Request​ Responses​ 200400401500 OK","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Save User","type":0,"sectionRef":"#","url":"/docs/1backend-api/save-user","content":"Save User PUT /user-svc/user/:userId Save user information based on the provided user ID. Intended for admins. Requires the user-svc:user:edit permission. For a user to edit their own profile, see saveSelf. Request​ Responses​ 200400401500 OK","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"View Self Node","type":0,"sectionRef":"#","url":"/docs/1backend-api/self-node","content":"View Self Node GET /registry-svc/node/self Show the local node. Request​ Responses​ 200400401500 OK","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Send an Email","type":0,"sectionRef":"#","url":"/docs/1backend-api/send-email","content":"Send an Email POST /email-svc/email Sends an email with optional attachments via a supported email provider. Currently, only SendGrid is supported. Additional providers may be added in the future. Required secrets from the Secret Svc for SendGrid: sender-email: Sender's email address.sender-name: Sender's display name.sendgrid-api-key: API key for SendGrid. Request​ Responses​ 200400401500 Successfully sent the email","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Send OTP","type":0,"sectionRef":"#","url":"/docs/1backend-api/send-otp","content":"Send OTP POST /user-svc/otp/send Generates and sends a one-time password (OTP) to the specified contact. The OTP can be used for contact verification or login depending on purpose. Request​ Responses​ 200400404500 OTP sent successfully","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Serve an Uploaded File","type":0,"sectionRef":"#","url":"/docs/1backend-api/serve-upload","content":"Serve an Uploaded File GET /file-svc/serve/upload/:fileId Retrieves and serves a previously uploaded file using its File ID. Note: The ID and FileID fields of an upload are different. FileID is a unique identifier for the file itself.ID is a unique identifier for a specific replica of the file. Since 1Backend is a distributed system, files can be replicated across multiple nodes. This means each uploaded file may have multiple records with the same FileID but different IDs. Request​ Responses​ 200400404500 File served successfully","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Serve Uploaded Image","type":0,"sectionRef":"#","url":"/docs/1backend-api/serve-uploaded-image","content":"Serve Uploaded Image GET /image-svc/serve/upload/:fileId Retrieves and serves a previously uploaded image file using its File ID. Request​ Responses​ 200400404500 File served successfully","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Serve a Downloaded file","type":0,"sectionRef":"#","url":"/docs/1backend-api/serve-download","content":"Serve a Downloaded file GET /file-svc/serve/download/:url Serves a previously downloaded file based on its URL. Request​ Responses​ 200400404500 File served successfully","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Start the Default Model","type":0,"sectionRef":"#","url":"/docs/1backend-api/start-default-model","content":"Start the Default Model PUT /model-svc/default-model/start Starts The Default Model. Requires the model-svc:model:create permission. Responses​ 200401500 OK","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Stop a Container","type":0,"sectionRef":"#","url":"/docs/1backend-api/stop-container","content":"Stop a Container PUT /container-svc/container/stop Stops a Docker container with the specified parameters. Requires the container-svc:container:stop permission. Request​ Responses​ 200400401500 OK","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Subscribe to the Event Stream","type":0,"sectionRef":"#","url":"/docs/1backend-api/subscribe-to-events","content":"Subscribe to the Event Stream GET /firehose-svc/events/subscribe Establish a subscription to the firehose events and accept a real time stream of them. Responses​ 200401500 Event data","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Subscribe to Prompt Responses by Thread","type":0,"sectionRef":"#","url":"/docs/1backend-api/subscribe-to-prompt-responses","content":"Subscribe to Prompt Responses by Thread GET /prompt-svc/prompts/:threadId/responses/subscribe Subscribe to prompt responses by thread via Server-Sent Events (SSE). You can subscribe to threads before they are created. The streamed strings are of type StreamChunk, see the PromptTypes endpoint for more details. Request​ Responses​ 200400401 Streaming response","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Start a Model","type":0,"sectionRef":"#","url":"/docs/1backend-api/start-model","content":"Start a Model PUT /model-svc/model/:modelId/start Starts a model by ID Request​ Responses​ 200401500 OK","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Update Objects","type":0,"sectionRef":"#","url":"/docs/1backend-api/update-objects","content":"Update Objects POST /data-svc/objects/update Update fields of objects that match the given filters using the provided object. Any fields not included in the incoming object will remain unchanged. Request​ Responses​ 200400401500 Successful update of objects","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Upload a File","type":0,"sectionRef":"#","url":"/docs/1backend-api/upload-file","content":"Upload a File PUT /file-svc/upload Uploads a file to the server. Currently if using the clients only one file can be uploaded at a time due to this bug https://github.com/OpenAPITools/openapi-generator/issues/11341Once that is fixed we should have an PUT /file-svc/uploads/uploadFiles (note the plural) endpoints. In reality the endpoint &quot;unofficially&quot; supports multiple files. YMMV. Requires the file-svc:upload:create permission. Request​ Responses​ 200400401500 File uploaded successfully","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Upsert an Instance","type":0,"sectionRef":"#","url":"/docs/1backend-api/upsert-instance","content":"Upsert an Instance PUT /policy-svc/instance/:instanceId Allows user to upsert a new policy instance based on a template. Request​ Responses​ 200400401500 Instance upserted successfully","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Upsert a Generic Object","type":0,"sectionRef":"#","url":"/docs/1backend-api/upsert-object","content":"Upsert a Generic Object PUT /data-svc/object/:objectId Creates a new dynamic object or updates an existing one based on the provided data. Requires authorization and user authentication. Request​ Responses​ 200400401500 Successful creation or update of object","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Upsert Objects","type":0,"sectionRef":"#","url":"/docs/1backend-api/upsert-objects","content":"Upsert Objects PUT /data-svc/objects/upsert Upserts objects by ids. Request​ Responses​ 200400401500 Successful upsert of objects","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Container Svc","type":0,"sectionRef":"#","url":"/docs/built-in-services/container-svc","content":"Container Svc The Container Svc manages Docker containers on individual nodes, providing a unified API for container lifecycle management, image building, and resource monitoring. This page provides a comprehensive overview of Container Svc. For detailed API information, refer to the Container Svc API documentation. Architecture​ The Container Svc is node-local and non-distributed—each instance only manages containers on its own node. This design simplifies container management while supporting advanced features like GPU acceleration and persistent storage. Access Control​ Container Svc uses permission-based access control: container-svc:container:view - View container informationcontainer-svc:container:run - Create and start containerscontainer-svc:container:stop - Stop containerscontainer-svc:log:view - View container logscontainer-svc:image:build - Build custom images By default, these permissions are granted to: model-svc and deploy-svc for container operationsAdministrators for all container management operations System Requirements​ Docker Configuration​ Docker daemon must be running and accessibleDocker socket must be mounted (typically /var/run/docker.sock)User must have Docker permissions Common Issues​ Docker Permission Denied # Add user to docker group sudo usermod -aG docker $USER # Restart session or run newgrp docker GPU Not Detected # Check NVIDIA drivers nvidia-smi # Verify Docker GPU support docker run --rm --gpus all nvidia/cuda:11.0-base nvidia-smi Container Won't Start Check Docker daemon status: systemctl status dockerVerify image availability: docker imagesReview container logs via Container Svc API Port Conflicts Use dynamic port allocation or check for port conflictsReview existing container port mappings Related Services​ Model Svc - AI model deployment and managementFile Svc - Asset downloading and file managementRegistry Svc - Node and instance registry","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Config Svc","type":0,"sectionRef":"#","url":"/docs/built-in-services/config-svc","content":"Config Svc The Config Svc stores public, non-sensitive, end-user–facing data. It is not for secrets or internal infrastructure configuration (those belong in Secret Svc). Think of it as the place to put knobs and information that your application or users need at runtime, but that is safe to expose publicly. Examples: Shop opening timesFeature flags like enableNewUIUI preferences (theme = &quot;dark&quot;, theme colors, layout)Supported languages This page provides a high-level overview of Config Svc. For detailed information, refer to the Config Svc API documentation. CLI Usage​ Saving Configs​ Use the config save command to save configuration data from YAML files: # Save a single config file oo config save ./my-config.yaml # Save multiple config files from a directory oo config save ./configs/ # Using aliases oo co s ./my-config.yaml oo configs save ./my-config.yaml Config File Structure​ Config files should be in YAML format with the following structure: # Optional: specify target app. # Only users with the permission &quot;config-svc:config:edit-on-behalf&quot; (typically admins) can specify this. # For other users the app from the token will be used. app: &quot;my-app&quot; # Optional: specify target app. # Only users with the permission &quot;config-svc:config:edit-on-behalf&quot; (typically admins) can specify this. # For other users the slug of the user will be used. key: &quot;user-slug&quot; data: # Your configuration data here featureFlags: enableNewUI: true maxUsers: 100 settings: theme: &quot;dark&quot; language: &quot;en&quot; notifications: email: true push: false Multiple Configs in One File​ You can also define multiple configs in a single YAML file as an array: - app: &quot;my-app&quot; key: &quot;user1&quot; data: preferences: theme: &quot;light&quot; - app: &quot;my-app&quot; key: &quot;user2&quot; data: preferences: theme: &quot;dark&quot; Querying Configs​ Use the config list command to retrieve and view configurations: # List all configs for the current app oo config list # Using aliases oo co ls oo configs list The output shows configs in a tabular format: CONFIG KEY APP JSON user1 my-app {&quot;preferences&quot;:{&quot;theme&quot;:&quot;light&quot;}} user2 my-app {&quot;preferences&quot;:{&quot;theme&quot;:&quot;dark&quot;}} Data Structure &amp; Behavior​ Deep Merge​ The Config Svc performs deep merging when saving configurations: Nested objects are recursively merged rather than replacedConflicting primitive values (strings, numbers, booleans) are replaced by incoming valuesNew fields are added to existing configsExisting fields not present in the incoming config are preserved Deep Merge Example​ Existing config: { &quot;ui&quot;: { &quot;theme&quot;: &quot;light&quot;, &quot;sidebar&quot;: { &quot;collapsed&quot;: false, &quot;width&quot;: 250 } }, &quot;features&quot;: { &quot;notifications&quot;: true } } Incoming config: data: ui: theme: &quot;dark&quot; # This will replace &quot;light&quot; sidebar: width: 300 # This will replace 250, collapsed: false is preserved newFeature: true # This will be added Result after merge: { &quot;ui&quot;: { &quot;theme&quot;: &quot;dark&quot;, # Updated &quot;sidebar&quot;: { &quot;collapsed&quot;: false, # Preserved &quot;width&quot;: 300 # Updated } }, &quot;features&quot;: { &quot;notifications&quot;: true # Preserved }, &quot;newFeature&quot;: true # Added } Config Identification​ Configs are uniquely identified by: App: The application name. Automatically determined from user's token unless the caller has the &quot;config-svc:config:edit-on-behalf&quot; permission - in that case the caller can specify this field.Key: The camelCased user slug (e.g., jane-doe becomes janeDoе). Automatically determined from the user's slug unless the caller has the &quot;config-svc:config:edit-on-behalf&quot; permission - in that case the caller can specify this field. The internal ID format is: {app}_{camelCasedSlug} Access Rules​ Read Access​ All configs are publicly readable even without a user account. Write Access​ Regular Users​ Can only write to configs under their own slugThe key field is automatically set to their camelCased slugThe app field is automatically set from their tokenCannot specify custom app or key values Administrators​ Have the config-svc:config:edit-on-behalf permissionCan specify any key value to edit configs for other usersCan specify any app value to target different applicationsMust provide a key when editing on behalf of others Permission-Based Access Example​ Regular user with slug jane-doe: # This file will automatically save under key &quot;janeDoe&quot; data: preferences: theme: &quot;dark&quot; User with the config-svc:config:edit-on-behalf permission (e.g., admin): app: &quot;production-app&quot; # Can specify target app key: &quot;john-smith&quot; # Can specify target user data: adminSettings: maxFileSize: &quot;10MB&quot; Related​ Secret Svc to store sensitive data like internal configuration and secretsConfig Svc API documentation for programmatic access","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Data Svc","type":0,"sectionRef":"#","url":"/docs/built-in-services/data-svc","content":"Data Svc The Data Svc is a Firebase-inspired backendless database service that allows direct data operations from frontends, eliminating the need for basic CRUD microservices. This page provides a comprehensive overview of Data Svc. For detailed API information, refer to the Data Svc API documentation. Architecture &amp; Purpose​ Data Svc serves as a lightweight database abstraction designed for rapid prototyping and backendless applications. It provides: Direct frontend access to database operationsMulti-tenant data isolation through permissionsFirebase-like flexibility with schemaless JSON objectsComprehensive permission system for fine-grained access control Key Features​ Tables &amp; Objects: Store schemaless JSON data in named tablesPermission-Based Access: Control who can read, write, and delete dataAdvanced Querying: Filter, sort, and paginate resultsReal-time Capabilities: Integration with Firehose Svc for live updatesCLI &amp; API Access: Use both command-line and programmatic interfaces Creating Objects​ # Create a single object oo post /data-svc/object \\ --object.table=&quot;user_profiles&quot; \\ --object.readers=&quot;_self&quot; \\ --object.writers=&quot;_self&quot; \\ --object.deleters=&quot;_self&quot; \\ --object.data.name=&quot;John Doe&quot; \\ --object.data.email=&quot;john@example.com&quot; \\ --object.data.preferences.theme=&quot;dark&quot; # Create a pet object with specific ID oo post /data-svc/object \\ --object.id=&quot;pet_fluffy123&quot; \\ --object.table=&quot;pet&quot; \\ --object.readers=&quot;_self&quot; \\ --object.writers=&quot;_self&quot; \\ --object.deleters=&quot;_self&quot; \\ --object.data.name=&quot;Fluffy&quot; \\ --object.data.species=&quot;cat&quot; \\ --object.data.age=3 Querying Objects​ # Query all objects in a table oo post /data-svc/objects \\ --table=&quot;user_profiles&quot; \\ --readers=&quot;_self&quot; # Query with filtering oo post /data-svc/objects \\ --table=&quot;pet&quot; \\ --readers=&quot;_self&quot; \\ --query.filters='[{&quot;fields&quot;:[&quot;data.species&quot;],&quot;op&quot;:&quot;equals&quot;,&quot;jsonValues&quot;:&quot;[\\&quot;cat\\&quot;]&quot;}]' # Query with sorting and pagination oo post /data-svc/objects \\ --table=&quot;pet&quot; \\ --readers=&quot;_self&quot; \\ --query.orderBys='[{&quot;field&quot;:&quot;data.age&quot;,&quot;desc&quot;:true,&quot;sortingType&quot;:&quot;numeric&quot;}]' \\ --query.limit=10 # Query with pagination using after oo post /data-svc/objects \\ --table=&quot;pet&quot; \\ --readers=&quot;_self&quot; \\ --query.orderBys='[{&quot;field&quot;:&quot;data.age&quot;,&quot;desc&quot;:true,&quot;sortingType&quot;:&quot;numeric&quot;}]' \\ --query.limit=10 \\ --query.jsonAfter='[5]' Updating Objects​ # Update objects by filter oo post /data-svc/objects/update \\ --table=&quot;pet&quot; \\ --filters='[{&quot;fields&quot;:[&quot;data.species&quot;],&quot;op&quot;:&quot;equals&quot;,&quot;jsonValues&quot;:&quot;[\\&quot;cat\\&quot;]&quot;}]' \\ --object.data.vaccinated=true # Upsert specific object by ID oo put /data-svc/object/pet_fluffy123 \\ --object.data.name=&quot;Fluffy Updated&quot; \\ --object.data.age=4 Deleting Objects​ # Delete objects by filter oo post /data-svc/objects/delete \\ --table=&quot;pet&quot; \\ --filters='[{&quot;fields&quot;:[&quot;data.species&quot;],&quot;op&quot;:&quot;equals&quot;,&quot;jsonValues&quot;:&quot;[\\&quot;dog\\&quot;]&quot;}]' Object Structure &amp; Data Model​ Basic Object Format​ { &quot;id&quot;: &quot;pet_fluffy123&quot;, &quot;table&quot;: &quot;pet&quot;, &quot;readers&quot;: [&quot;usr_12345&quot;, &quot;org_67890&quot;], &quot;writers&quot;: [&quot;usr_12345&quot;], &quot;deleters&quot;: [&quot;usr_12345&quot;], &quot;authors&quot;: [&quot;usr_12345&quot;], &quot;data&quot;: { &quot;name&quot;: &quot;Fluffy&quot;, &quot;species&quot;: &quot;cat&quot;, &quot;age&quot;: 3, &quot;preferences&quot;: { &quot;food&quot;: &quot;salmon&quot;, &quot;toys&quot;: [&quot;ball&quot;, &quot;mouse&quot;] } }, &quot;createdAt&quot;: &quot;2023-01-01T10:00:00Z&quot;, &quot;updatedAt&quot;: &quot;2023-01-01T10:00:00Z&quot; } Table Naming &amp; Object IDs​ Table names: Use singular form (e.g., pet, user_profile)Object IDs: Must be prefixed with table name (e.g., pet_fluffy123)Auto-generated IDs: Leave empty for automatic generation # Auto-generated ID oo post /data-svc/object \\ --object.table=&quot;pet&quot; \\ --object.data.name=&quot;Auto Pet&quot; # Custom ID (must match table prefix) oo post /data-svc/object \\ --object.id=&quot;pet_custom123&quot; \\ --object.table=&quot;pet&quot; \\ --object.data.name=&quot;Custom Pet&quot; Permission System​ The Data Svc permission model provides fine-grained access control with four permission types: Permission Types​ Readers​ Users/roles who can view objects: { &quot;readers&quot;: [&quot;usr_12345&quot;, &quot;org_67890&quot;, &quot;role_managers&quot;] } Writers​ Users/roles who can modify objects: { &quot;writers&quot;: [&quot;usr_12345&quot;, &quot;org_67890&quot;] } Deleters​ Users/roles who can delete objects: { &quot;deleters&quot;: [&quot;usr_12345&quot;] } Authors​ System-assigned creators (cannot be spoofed): { &quot;authors&quot;: [&quot;usr_12345&quot;, &quot;org_67890&quot;] } Permission Shortcuts​ _self: Refers to the current user's ID_org: Refers to the current user's active organization # Using permission shortcuts oo post /data-svc/object \\ --object.table=&quot;private_note&quot; \\ --object.readers=&quot;_self&quot; \\ --object.writers=&quot;_self&quot; \\ --object.deleters=&quot;_self&quot; \\ --object.data.content=&quot;My private note&quot; Multi-Tenant Access Control​ Data Svc supports shared tables where multiple users store data with isolation: # User A creates a profile oo post /data-svc/object \\ --object.table=&quot;user_profile&quot; \\ --object.readers=&quot;_self&quot; \\ --object.writers=&quot;_self&quot; \\ --object.data.name=&quot;Alice&quot; # User B creates a separate profile in same table oo post /data-svc/object \\ --object.table=&quot;user_profile&quot; \\ --object.readers=&quot;_self&quot; \\ --object.writers=&quot;_self&quot; \\ --object.data.name=&quot;Bob&quot; Cross-User Permissions​ Grant access to specific users or organizations: # Share data with specific user oo post /data-svc/object \\ --object.table=&quot;shared_document&quot; \\ --object.readers='[&quot;usr_alice123&quot;, &quot;usr_bob456&quot;]' \\ --object.writers='[&quot;usr_alice123&quot;]' \\ --object.deleters='[&quot;usr_alice123&quot;]' \\ --object.data.title=&quot;Shared Project Plan&quot; # Share with organization oo post /data-svc/object \\ --object.table=&quot;team_resource&quot; \\ --object.readers='[&quot;org_company123&quot;]' \\ --object.writers='[&quot;org_company123&quot;]' \\ --object.data.resource=&quot;Team Guidelines&quot; Advanced Querying​ Filter Operations​ Data Svc supports comprehensive filtering with various operators: # Equals filter oo post /data-svc/objects \\ --table=&quot;pet&quot; \\ --readers=&quot;_self&quot; \\ --query.filters='[{&quot;fields&quot;:[&quot;data.species&quot;],&quot;op&quot;:&quot;equals&quot;,&quot;jsonValues&quot;:&quot;[\\&quot;cat\\&quot;]&quot;}]' # Contains filter (for strings) oo post /data-svc/objects \\ --table=&quot;pet&quot; \\ --readers=&quot;_self&quot; \\ --query.filters='[{&quot;fields&quot;:[&quot;data.name&quot;],&quot;op&quot;:&quot;contains&quot;,&quot;jsonValues&quot;:&quot;[\\&quot;flu\\&quot;]&quot;}]' # Greater than filter (for numbers) oo post /data-svc/objects \\ --table=&quot;pet&quot; \\ --readers=&quot;_self&quot; \\ --query.filters='[{&quot;fields&quot;:[&quot;data.age&quot;],&quot;op&quot;:&quot;greaterThan&quot;,&quot;jsonValues&quot;:&quot;[5]&quot;}]' # Multiple filters (AND logic) oo post /data-svc/objects \\ --table=&quot;pet&quot; \\ --readers=&quot;_self&quot; \\ --query.filters='[ {&quot;fields&quot;:[&quot;data.species&quot;],&quot;op&quot;:&quot;equals&quot;,&quot;jsonValues&quot;:&quot;[\\&quot;cat\\&quot;]&quot;}, {&quot;fields&quot;:[&quot;data.age&quot;],&quot;op&quot;:&quot;greaterThan&quot;,&quot;jsonValues&quot;:&quot;[2]&quot;} ]' Sorting &amp; Ordering​ # Sort by age (ascending) oo post /data-svc/objects \\ --table=&quot;pet&quot; \\ --readers=&quot;_self&quot; \\ --query.orderBys='[{&quot;field&quot;:&quot;data.age&quot;,&quot;sortingType&quot;:&quot;numeric&quot;}]' # Sort by age (descending) oo post /data-svc/objects \\ --table=&quot;pet&quot; \\ --readers=&quot;_self&quot; \\ --query.orderBys='[{&quot;field&quot;:&quot;data.age&quot;,&quot;desc&quot;:true,&quot;sortingType&quot;:&quot;numeric&quot;}]' # Sort by name (string) oo post /data-svc/objects \\ --table=&quot;pet&quot; \\ --readers=&quot;_self&quot; \\ --query.orderBys='[{&quot;field&quot;:&quot;data.name&quot;,&quot;sortingType&quot;:&quot;string&quot;}]' Pagination​ # First page (limit 5) oo post /data-svc/objects \\ --table=&quot;pet&quot; \\ --readers=&quot;_self&quot; \\ --query.orderBys='[{&quot;field&quot;:&quot;data.age&quot;,&quot;sortingType&quot;:&quot;numeric&quot;}]' \\ --query.limit=5 # Next page (after age 3) oo post /data-svc/objects \\ --table=&quot;pet&quot; \\ --readers=&quot;_self&quot; \\ --query.orderBys='[{&quot;field&quot;:&quot;data.age&quot;,&quot;sortingType&quot;:&quot;numeric&quot;}]' \\ --query.limit=5 \\ --query.jsonAfter='[3]' Real-World Usage Examples​ 1. User Profile Management​ # Create user profile oo post /data-svc/object \\ --object.table=&quot;user_profile&quot; \\ --object.readers=&quot;_self&quot; \\ --object.writers=&quot;_self&quot; \\ --object.deleters=&quot;_self&quot; \\ --object.data.name=&quot;John Doe&quot; \\ --object.data.email=&quot;john@example.com&quot; \\ --object.data.preferences.theme=&quot;dark&quot; \\ --object.data.preferences.notifications=true # Update profile preferences oo post /data-svc/objects/update \\ --table=&quot;user_profile&quot; \\ --filters='[{&quot;fields&quot;:[&quot;authors&quot;],&quot;op&quot;:&quot;intersects&quot;,&quot;jsonValues&quot;:&quot;[\\&quot;usr_currentuser\\&quot;]&quot;}]' \\ --object.data.preferences.theme=&quot;light&quot; # Query own profile oo post /data-svc/objects \\ --table=&quot;user_profile&quot; \\ --readers=&quot;_self&quot; 2. Todo List Application​ # Create todo item oo post /data-svc/object \\ --object.table=&quot;todo&quot; \\ --object.readers=&quot;_self&quot; \\ --object.writers=&quot;_self&quot; \\ --object.deleters=&quot;_self&quot; \\ --object.data.title=&quot;Learn Data Svc&quot; \\ --object.data.completed=false \\ --object.data.priority=&quot;high&quot; \\ --object.data.dueDate=&quot;2023-12-31&quot; # Mark todo as completed oo post /data-svc/objects/update \\ --table=&quot;todo&quot; \\ --filters='[{&quot;fields&quot;:[&quot;data.title&quot;],&quot;op&quot;:&quot;equals&quot;,&quot;jsonValues&quot;:&quot;[\\&quot;Learn Data Svc\\&quot;]&quot;}]' \\ --object.data.completed=true # Get pending todos oo post /data-svc/objects \\ --table=&quot;todo&quot; \\ --readers=&quot;_self&quot; \\ --query.filters='[{&quot;fields&quot;:[&quot;data.completed&quot;],&quot;op&quot;:&quot;equals&quot;,&quot;jsonValues&quot;:&quot;[false]&quot;}]' \\ --query.orderBys='[{&quot;field&quot;:&quot;data.priority&quot;,&quot;sortingType&quot;:&quot;string&quot;}]' 3. Team Collaboration​ # Create shared team document oo post /data-svc/object \\ --object.table=&quot;team_document&quot; \\ --object.readers='[&quot;org_team123&quot;]' \\ --object.writers='[&quot;org_team123&quot;]' \\ --object.deleters='[&quot;usr_teamlead456&quot;]' \\ --object.data.title=&quot;Project Specs&quot; \\ --object.data.content=&quot;Initial project specifications...&quot; \\ --object.data.status=&quot;draft&quot; # Add team member comments oo post /data-svc/object \\ --object.table=&quot;document_comment&quot; \\ --object.readers='[&quot;org_team123&quot;]' \\ --object.writers='[&quot;org_team123&quot;]' \\ --object.data.documentId=&quot;team_document_proj123&quot; \\ --object.data.author=&quot;Alice Smith&quot; \\ --object.data.comment=&quot;Looks good, needs timeline&quot; # Query team documents oo post /data-svc/objects \\ --table=&quot;team_document&quot; \\ --readers='[&quot;org_team123&quot;]' \\ --query.filters='[{&quot;fields&quot;:[&quot;data.status&quot;],&quot;op&quot;:&quot;equals&quot;,&quot;jsonValues&quot;:&quot;[\\&quot;draft\\&quot;]&quot;}]' 4. E-commerce Product Catalog​ # Create product oo post /data-svc/object \\ --object.table=&quot;product&quot; \\ --object.readers='[&quot;any&quot;]' \\ --object.writers='[&quot;role_admin&quot;]' \\ --object.deleters='[&quot;role_admin&quot;]' \\ --object.data.name=&quot;Premium Headphones&quot; \\ --object.data.price=199.99 \\ --object.data.category=&quot;electronics&quot; \\ --object.data.inStock=true \\ --object.data.tags='[&quot;wireless&quot;, &quot;premium&quot;, &quot;audio&quot;]' # Search products by category oo post /data-svc/objects \\ --table=&quot;product&quot; \\ --readers='[&quot;any&quot;]' \\ --query.filters='[{&quot;fields&quot;:[&quot;data.category&quot;],&quot;op&quot;:&quot;equals&quot;,&quot;jsonValues&quot;:&quot;[\\&quot;electronics\\&quot;]&quot;}]' \\ --query.orderBys='[{&quot;field&quot;:&quot;data.price&quot;,&quot;sortingType&quot;:&quot;numeric&quot;}]' # Filter by price range oo post /data-svc/objects \\ --table=&quot;product&quot; \\ --readers='[&quot;any&quot;]' \\ --query.filters='[ {&quot;fields&quot;:[&quot;data.price&quot;],&quot;op&quot;:&quot;greaterThanOrEqual&quot;,&quot;jsonValues&quot;:&quot;[100]&quot;}, {&quot;fields&quot;:[&quot;data.price&quot;],&quot;op&quot;:&quot;lessThanOrEqual&quot;,&quot;jsonValues&quot;:&quot;[300]&quot;} ]' Related Services​ Secret Svc: Store sensitive data securelyFirehose Svc: Real-time event streamingFile Svc: File storage and managementUser Svc: User authentication and roles For production applications requiring complex data relationships, consider using dedicated databases alongside Data Svc for specific use cases.","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Chat Svc","type":0,"sectionRef":"#","url":"/docs/built-in-services/chat-svc","content":"Chat Svc The Chat Svc manages conversational threads and messages, serving as the primary interface for AI-powered chat applications and user interactions with LLM systems. This page provides a comprehensive overview of Chat Svc. For detailed API information, refer to the Chat Svc API documentation. Architecture &amp; Design​ The Chat Svc follows a thread-based conversation model where: Threads represent conversation sessions or topicsMessages are individual pieces of content within threadsUsers can participate in multiple threadsAI responses are seamlessly integrated via message creation Core Concepts​ Threads​ Conversation containers that group related messages together. Think of them as chat rooms or conversation sessions. Messages​ Individual pieces of content within threads, supporting: Text contentFile attachmentsMetadata for extensibilityUser attribution (or AI-generated content) Topics​ Tag-like categorization system for organizing threads by subject or purpose. API Endpoints​ Thread Management​ Create/Update Thread​ POST /chat-svc/thread Creates a new thread or updates an existing one. Request Body: { &quot;id&quot;: &quot;thr_abc123&quot;, &quot;title&quot;: &quot;AI Assistant Conversation&quot;, &quot;userIds&quot;: [&quot;user_123&quot;, &quot;user_456&quot;], &quot;topicIds&quot;: [&quot;ai-help&quot;, &quot;troubleshooting&quot;] } Response: { &quot;thread&quot;: { &quot;id&quot;: &quot;thr_abc123&quot;, &quot;title&quot;: &quot;AI Assistant Conversation&quot;, &quot;userIds&quot;: [&quot;user_123&quot;, &quot;user_456&quot;], &quot;topicIds&quot;: [&quot;ai-help&quot;, &quot;troubleshooting&quot;], &quot;createdAt&quot;: &quot;2024-01-15T10:30:00Z&quot;, &quot;updatedAt&quot;: &quot;2024-01-15T10:30:00Z&quot; } } List Threads​ POST /chat-svc/threads Retrieves threads accessible to the authenticated user. Request Body: { &quot;ids&quot;: [&quot;thr_abc123&quot;, &quot;thr_def456&quot;] } Delete Thread​ DELETE /chat-svc/thread/{threadId} Permanently removes a thread and all its messages. Message Management​ Add Message​ POST /chat-svc/thread/{threadId}/message Adds a new message to an existing thread. Request Body: { &quot;id&quot;: &quot;msg_xyz789&quot;, &quot;text&quot;: &quot;Hello, I need help with my API integration&quot;, &quot;userId&quot;: &quot;user_123&quot;, &quot;fileIds&quot;: [&quot;file_attachment1&quot;], &quot;meta&quot;: { &quot;priority&quot;: &quot;high&quot;, &quot;category&quot;: &quot;support&quot; } } List Messages​ POST /chat-svc/messages Retrieves messages from threads, with optional filtering. Request Body: { &quot;threadId&quot;: &quot;thr_abc123&quot;, &quot;ids&quot;: [&quot;msg_xyz789&quot;] } Response: { &quot;messages&quot;: [ { &quot;id&quot;: &quot;msg_xyz789&quot;, &quot;threadId&quot;: &quot;thr_abc123&quot;, &quot;text&quot;: &quot;Hello, I need help with my API integration&quot;, &quot;userId&quot;: &quot;user_123&quot;, &quot;fileIds&quot;: [&quot;file_attachment1&quot;], &quot;meta&quot;: {&quot;priority&quot;: &quot;high&quot;}, &quot;createdAt&quot;: &quot;2024-01-15T10:35:00Z&quot;, &quot;updatedAt&quot;: &quot;2024-01-15T10:35:00Z&quot; } ] } Delete Message​ DELETE /chat-svc/message/{messageId} Removes a specific message from its thread. Events Endpoint​ GET /chat-svc/events Documentation endpoint showing available real-time events. Real-Time Features​ Chat Svc publishes events through Firehose Svc for real-time applications: Event Types​ Thread Events​ chatThreadAdded - New thread createdchatThreadUpdate - Thread modified (title, users, topics) Message Events​ chatMessageAdded - New message posted to thread Event Structure​ { &quot;name&quot;: &quot;chatMessageAdded&quot;, &quot;data&quot;: { &quot;threadId&quot;: &quot;thr_abc123&quot; } } AI Integration​ Prompt Svc Integration​ Chat Svc seamlessly integrates with Prompt Svc for AI-powered conversations: User sends message → Chat Svc stores user messageAI processing → Prompt Svc processes via LLMAI response → Chat Svc receives and stores AI messageReal-time delivery → Events notify clients of new messages AI Message Flow​ Streaming AI Responses​ For real-time AI interactions, Chat Svc supports: Progressive responses via streaming chunksReal-time updates as AI generates contentCompletion events when AI finishes responding File Attachments​ Messages support file attachments through integration with File Svc: { &quot;text&quot;: &quot;Here's the document you requested&quot;, &quot;fileIds&quot;: [ &quot;file_document1.pdf&quot;, &quot;file_screenshot.png&quot;, &quot;file_data.csv&quot; ] } File attachments enable: Document sharing in conversationsImage/media support for rich interactionsAI analysis of uploaded contentPersistent storage of conversation assets Usage Examples​ Creating a Chat Application​ 1. Start a New Conversation​ # Create a thread for AI assistance curl -X POST &quot;http://localhost:11337/chat-svc/thread&quot; \\ -H &quot;Authorization: Bearer $TOKEN&quot; \\ -H &quot;Content-Type: application/json&quot; \\ -d '{ &quot;title&quot;: &quot;AI Code Review&quot;, &quot;topicIds&quot;: [&quot;development&quot;, &quot;code-review&quot;] }' 2. Send User Message​ # Add user message to thread curl -X POST &quot;http://localhost:11337/chat-svc/thread/thr_abc123/message&quot; \\ -H &quot;Authorization: Bearer $TOKEN&quot; \\ -H &quot;Content-Type: application/json&quot; \\ -d '{ &quot;text&quot;: &quot;Can you review this JavaScript function?&quot;, &quot;fileIds&quot;: [&quot;file_code.js&quot;] }' 3. List Conversation History​ # Get all messages in the thread curl -X POST &quot;http://localhost:11337/chat-svc/messages&quot; \\ -H &quot;Authorization: Bearer $TOKEN&quot; \\ -H &quot;Content-Type: application/json&quot; \\ -d '{ &quot;threadId&quot;: &quot;thr_abc123&quot; }' Multi-User Conversations​ # Create a team discussion thread curl -X POST &quot;http://localhost:11337/chat-svc/thread&quot; \\ -H &quot;Authorization: Bearer $TOKEN&quot; \\ -H &quot;Content-Type: application/json&quot; \\ -d '{ &quot;title&quot;: &quot;Project Planning Session&quot;, &quot;userIds&quot;: [&quot;user_alice&quot;, &quot;user_bob&quot;, &quot;user_charlie&quot;], &quot;topicIds&quot;: [&quot;planning&quot;, &quot;project-alpha&quot;] }' AI Assistant Integration​ // Subscribe to real-time events for AI responses const eventSource = new EventSource('/firehose-svc/events'); eventSource.addEventListener('chatMessageAdded', (event) =&gt; { const data = JSON.parse(event.data); // Fetch the new message fetch('/chat-svc/messages', { method: 'POST', headers: { 'Authorization': `Bearer ${token}` }, body: JSON.stringify({ threadId: data.threadId }) }) .then(response =&gt; response.json()) .then(messages =&gt; { // Update UI with new message displayNewMessage(messages.messages[0]); }); }); // Send message and trigger AI response async function sendMessage(threadId, text) { // Add user message await fetch(`/chat-svc/thread/${threadId}/message`, { method: 'POST', headers: { 'Authorization': `Bearer ${token}` }, body: JSON.stringify({ text }) }); // Trigger AI processing (Prompt Svc will handle automatically) } Topic-Based Organization​ # Create threads with specific topics for organization curl -X POST &quot;http://localhost:11337/chat-svc/thread&quot; \\ -H &quot;Authorization: Bearer $TOKEN&quot; \\ -d '{ &quot;title&quot;: &quot;Bug Reports&quot;, &quot;topicIds&quot;: [&quot;bugs&quot;, &quot;frontend&quot;, &quot;urgent&quot;] }' curl -X POST &quot;http://localhost:11337/chat-svc/thread&quot; \\ -H &quot;Authorization: Bearer $TOKEN&quot; \\ -d '{ &quot;title&quot;: &quot;Feature Requests&quot;, &quot;topicIds&quot;: [&quot;features&quot;, &quot;enhancement&quot;, &quot;v2.0&quot;] }' Access Control​ Chat Svc uses comprehensive permission-based access control: Thread Permissions​ chat-svc:thread:create - Create new threadschat-svc:thread:view - View thread informationchat-svc:thread:edit - Modify thread propertieschat-svc:thread:delete - Delete threadschat-svc:thread:stream - Subscribe to thread events Message Permissions​ chat-svc:message:create - Add messages to threadschat-svc:message:view - Read messageschat-svc:message:edit - Modify messageschat-svc:message:delete - Remove messageschat-svc:message:stream - Subscribe to message events Default Access​ By default, permissions are granted to: Administrators - Full access to all operationsRegular Users - Access to threads they participate in User-Based Filtering​ Users can only see threads where they are listed in userIdsMessage access is controlled by thread membershipThread creators automatically gain access Data Models​ Thread Structure​ { &quot;id&quot;: &quot;thr_emSQnpJbhG&quot;, &quot;title&quot;: &quot;Conversation Title&quot;, &quot;userIds&quot;: [&quot;user1&quot;, &quot;user2&quot;], &quot;topicIds&quot;: [&quot;topic1&quot;, &quot;topic2&quot;], &quot;createdAt&quot;: &quot;2024-01-15T10:30:00Z&quot;, &quot;updatedAt&quot;: &quot;2024-01-15T10:30:00Z&quot; } Message Structure​ { &quot;id&quot;: &quot;msg_emSOPlW58o&quot;, &quot;threadId&quot;: &quot;thr_emSQnpJbhG&quot;, &quot;text&quot;: &quot;Message content&quot;, &quot;userId&quot;: &quot;user_123&quot;, &quot;fileIds&quot;: [&quot;file1&quot;, &quot;file2&quot;], &quot;meta&quot;: { &quot;customField&quot;: &quot;value&quot;, &quot;priority&quot;: &quot;high&quot; }, &quot;createdAt&quot;: &quot;2024-01-15T10:35:00Z&quot;, &quot;updatedAt&quot;: &quot;2024-01-15T10:35:00Z&quot; } AI Messages​ AI-generated messages have specific characteristics: userId is empty (indicates AI origin) meta contains model information: { &quot;modelId&quot;: &quot;huggingface/llama-model&quot;, &quot;platformId&quot;: &quot;llama-cpp&quot; } Integration Patterns​ Frontend Applications​ Real-time chat interfaces using WebSocket eventsProgressive AI responses with streaming updatesFile sharing within conversationsThread organization by topics Backend Services​ AI model integration via Prompt SvcAutomated responses to user messagesContent analysis of uploaded filesConversation analytics and insights Mobile Applications​ Push notifications for new messagesOffline message queuing with eventual consistencyRich media support for attachmentsCross-platform synchronization Performance &amp; Scalability​ Optimizations​ Pagination for large message listsIndexing on threadId and userId for fast queriesCaching of frequently accessed threadsEvent batching for high-volume scenarios Best Practices​ Limit message size for optimal performanceUse topics for efficient thread organizationImplement pagination for message historySubscribe selectively to relevant events only Troubleshooting​ Common Issues​ Messages Not Appearing Verify thread exists before adding messagesCheck user permissions for thread accessEnsure proper event subscription setup AI Responses Not Generated Confirm Prompt Svc integration is activeVerify AI model is running and accessibleCheck message format matches AI expectations Real-time Events Missing Validate Firehose Svc connectivityEnsure proper event subscription to correct threadCheck authentication tokens for event access File Attachments Not Loading Verify File Svc integration and file existenceCheck file permissions and access rightsConfirm fileIds are valid references Related Services​ Prompt Svc - AI conversation processingFile Svc - File attachment managementFirehose Svc - Real-time event streamingUser Svc - User authentication and authorization","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"File Svc","type":0,"sectionRef":"#","url":"/docs/built-in-services/file-svc","content":"File Svc The File Svc is a distributed file storage and caching service that handles file uploads, downloads from external URLs, and content delivery across the 1Backend infrastructure. This page provides a comprehensive overview of File Svc. For detailed API information, refer to the File Svc API documentation. Architecture &amp; Purpose​ File Svc serves as the content management layer for 1Backend, providing: Distributed Storage: Files are replicated across multiple nodes for reliabilityURL Caching: Downloads and caches external files for faster accessUpload Management: Handles multipart file uploads from clientsContent Delivery: Serves files with proper MIME types and headersAsset Integration: Automatically provides files to containers and services Key Features​ Multi-Node Distribution: Files stored across different nodes with automatic replicationSmart Proxying: Serves files from the nearest available nodeResume Support: Partial downloads with resume capabilitySecurity: File access controls and secure file ID generationPerformance: Intelligent caching and streaming for optimal delivery CLI Usage​ File Svc doesn't have dedicated CLI commands. Instead, use the generic HTTP commands to interact with the API endpoints: Downloading &amp; Caching Files​ # Download and cache a file from URL oo put /file-svc/download \\ --url=&quot;https://example.com/large-model.gguf&quot; \\ --folderPath=&quot;/downloads&quot; # Get download status oo get /file-svc/download/https%3A%2F%2Fexample.com%2Flarge-model.gguf # List all downloads oo post /file-svc/downloads # Pause a download oo put /file-svc/download/https%3A%2F%2Fexample.com%2Flarge-model.gguf/pause File Uploads​ # Upload a file using curl (multipart form data) curl -X PUT &quot;http://localhost:11337/file-svc/upload&quot; \\ -H &quot;Authorization: Bearer $TOKEN&quot; \\ -F &quot;file=@./my-document.pdf&quot; # List uploaded files oo post /file-svc/uploads \\ --userId=&quot;usr_12345&quot; Serving Files​ # Serve an uploaded file by file ID curl &quot;http://localhost:11337/file-svc/serve/upload/file_abc123xyz&quot; # Serve a downloaded file by URL curl &quot;http://localhost:11337/file-svc/serve/download/https%3A%2F%2Fexample.com%2Fmodel.gguf&quot; # Using with browser (downloads with proper filename) open &quot;http://localhost:11337/file-svc/serve/upload/file_abc123xyz&quot; Distributed Architecture​ Multi-Node Storage​ File Svc operates in a distributed manner: File Replication &amp; Access​ Upload Replicas: Files can be stored on multiple nodesSmart Routing: Requests automatically routed to nodes with the fileTransparent Proxying: If a file isn't local, the request is proxied to the correct nodeUnique File IDs: Files have both local IDs and global file IDs for distributed access Node-Local Folders​ Each File Svc node maintains: ~/.1backend/ ├── uploads/ # User uploaded files └── downloads/ # Cached external files File Types &amp; Management​ Downloads (External Files)​ Downloads are external files cached locally for performance: # Download an AI model oo put /file-svc/download \\ --url=&quot;https://huggingface.co/microsoft/DialoGPT-medium/resolve/main/pytorch_model.bin&quot; \\ --folderPath=&quot;/models&quot; # Check download progress oo get /file-svc/download/https%3A%2F%2Fhuggingface.co%2Fmicrosoft%2FDialoGPT-medium%2Fresolve%2Fmain%2Fpytorch_model.bin Response Example: { &quot;exists&quot;: true, &quot;download&quot;: { &quot;id&quot;: &quot;down_abc123&quot;, &quot;url&quot;: &quot;https://huggingface.co/microsoft/DialoGPT-medium/resolve/main/pytorch_model.bin&quot;, &quot;fileName&quot;: &quot;pytorch_model.bin&quot;, &quot;progress&quot;: 75.5, &quot;downloadedBytes&quot;: 890234567, &quot;fileSize&quot;: 1179648000, &quot;status&quot;: &quot;InProgress&quot;, &quot;filePath&quot;: &quot;/root/.1backend/downloads/encoded_filename&quot; } } Uploads (User Files)​ Uploads are files submitted by users or services: # List user uploads oo post /file-svc/uploads \\ --userId=&quot;usr_12345&quot; Response Example: { &quot;uploads&quot;: [ { &quot;id&quot;: &quot;upl_xyz789&quot;, &quot;fileId&quot;: &quot;file_abc123def&quot;, &quot;fileName&quot;: &quot;profile-picture.jpg&quot;, &quot;fileSize&quot;: 2048576, &quot;userId&quot;: &quot;usr_12345&quot;, &quot;nodeId&quot;: &quot;node_server01&quot;, &quot;createdAt&quot;: &quot;2023-01-01T10:00:00Z&quot; } ] } Integration Patterns​ Container Assets (AI Models)​ File Svc automatically integrates with Container Svc for AI model downloads: { &quot;image&quot;: &quot;llama-cpp-python:latest&quot;, &quot;assets&quot;: [ { &quot;envVarKey&quot;: &quot;MODEL_PATH&quot;, &quot;url&quot;: &quot;https://huggingface.co/TheBloke/Mistral-7B-Instruct-v0.2-GGUF/resolve/main/mistral-7b-instruct-v0.2.Q4_K_M.gguf&quot; } ] } Flow: Container Svc requests the model file from File SvcFile Svc downloads and caches the model if not presentFile is served to Container Svc and mounted in the containerEnvironment variable MODEL_PATH points to the file location Chat &amp; File Attachments​ Integration with Chat Svc for message attachments: # Upload attachment curl -X PUT &quot;http://localhost:11337/file-svc/upload&quot; \\ -H &quot;Authorization: Bearer $TOKEN&quot; \\ -F &quot;file=@./document.pdf&quot; # Use file ID in chat message oo post /chat-svc/thread/thread_123/message \\ --text=&quot;Here's the document&quot; \\ --fileIds='[&quot;file_abc123def&quot;]' Data Svc Integration​ Store file references in Data Svc objects: # Create object with file references oo post /data-svc/object \\ --object.table=&quot;document&quot; \\ --object.readers=&quot;_self&quot; \\ --object.data.title=&quot;Project Report&quot; \\ --object.data.attachments='[&quot;file_report123&quot;, &quot;file_charts456&quot;]' Real-World Usage Examples​ 1. AI Model Management​ # Download a large language model oo put /file-svc/download \\ --url=&quot;https://huggingface.co/microsoft/DialoGPT-large/resolve/main/pytorch_model.bin&quot; \\ --folderPath=&quot;/models/dialogpt&quot; # Check download progress oo get /file-svc/download/https%3A%2F%2Fhuggingface.co%2Fmicrosoft%2FDialoGPT-large%2Fresolve%2Fmain%2Fpytorch_model.bin # Monitor until complete watch -n 5 'oo post /file-svc/downloads | grep -A 10 &quot;DialoGPT&quot;' # Once complete, use in container oo put /container-svc/container \\ --image=&quot;my-ai-service:latest&quot; \\ --assets='[{&quot;envVarKey&quot;: &quot;MODEL_PATH&quot;, &quot;url&quot;: &quot;https://huggingface.co/microsoft/DialoGPT-large/resolve/main/pytorch_model.bin&quot;}]' 2. Document Management System​ # Upload user documents curl -X PUT &quot;http://localhost:11337/file-svc/upload&quot; \\ -H &quot;Authorization: Bearer $TOKEN&quot; \\ -F &quot;file=@./contract.pdf&quot; \\ -F &quot;file=@./invoice.xlsx&quot; # List user's documents oo post /file-svc/uploads \\ --userId=&quot;usr_company123&quot; # Store document metadata in Data Svc oo post /data-svc/object \\ --object.table=&quot;document&quot; \\ --object.readers='[&quot;org_company123&quot;]' \\ --object.data.title=&quot;Q4 Contract&quot; \\ --object.data.fileId=&quot;file_contract789&quot; \\ --object.data.category=&quot;legal&quot; \\ --object.data.uploadedBy=&quot;usr_john456&quot; 3. Content Delivery Network​ # Cache frequently accessed files oo put /file-svc/download \\ --url=&quot;https://cdn.example.com/assets/logo.png&quot; \\ --folderPath=&quot;/cdn-cache&quot; oo put /file-svc/download \\ --url=&quot;https://cdn.example.com/assets/style.css&quot; \\ --folderPath=&quot;/cdn-cache&quot; # Serve cached content (much faster than original CDN) curl &quot;http://localhost:11337/file-svc/serve/download/https%3A%2F%2Fcdn.example.com%2Fassets%2Flogo.png&quot; 4. Backup &amp; Migration​ # Download backup files oo put /file-svc/download \\ --url=&quot;https://backups.mycompany.com/database-backup-2023-12.sql.gz&quot; \\ --folderPath=&quot;/backups&quot; # Upload processed files curl -X PUT &quot;http://localhost:11337/file-svc/upload&quot; \\ -H &quot;Authorization: Bearer $TOKEN&quot; \\ -F &quot;file=@./processed-data.csv&quot; # List all cached backups oo post /file-svc/downloads | grep backup 5. Multi-Media Processing​ # Download video for processing oo put /file-svc/download \\ --url=&quot;https://example.com/raw-video.mp4&quot; \\ --folderPath=&quot;/media/input&quot; # Process and upload result # (after processing with video service) curl -X PUT &quot;http://localhost:11337/file-svc/upload&quot; \\ -H &quot;Authorization: Bearer $TOKEN&quot; \\ -F &quot;file=@./processed-video.mp4&quot; # Create media object with references oo post /data-svc/object \\ --object.table=&quot;media&quot; \\ --object.readers=&quot;_self&quot; \\ --object.data.title=&quot;Processed Video&quot; \\ --object.data.originalFile=&quot;https://example.com/raw-video.mp4&quot; \\ --object.data.processedFileId=&quot;file_processed123&quot; File Serving &amp; Content Delivery​ Content Headers​ File Svc automatically sets appropriate headers: Content-Type: application/pdf Content-Disposition: attachment; filename=&quot;document.pdf&quot; Content-Length: 2048576 Direct File Access​ # Serve file directly (downloads with proper filename) curl -O -J &quot;http://localhost:11337/file-svc/serve/upload/file_abc123def&quot; # Serve with custom application wget &quot;http://localhost:11337/file-svc/serve/download/https%3A%2F%2Fexample.com%2Ffile.zip&quot; # Embed in web pages # &lt;img src=&quot;http://localhost:11337/file-svc/serve/upload/file_image123&quot; /&gt; Streaming &amp; Performance​ Progressive Download: Large files stream as they downloadResume Support: Interrupted downloads can resume from where they left offMIME Detection: Automatic content-type detection from file extensionsEfficient Proxying: Minimal overhead when proxying between nodes File Security &amp; Access Control​ Secure File IDs​ # File IDs are cryptographically secure file_8kJ9pL2mN5qR7sT1vU3wX6yZ4aB7cD9eF2gH5iJ8k Non-enumerable: Cannot guess other file IDsGlobally unique: Safe across distributed systemOpaque: No information leaked about file contents Permission System​ File operations require specific permissions: # Download permissions file-svc:download:create # Start downloads file-svc:download:view # List and check downloads # Upload permissions file-svc:upload:create # Upload files file-svc:upload:view # List uploads Service Integration Permissions​ # Container Svc can download assets model-svc -&gt; file-svc:download:create model-svc -&gt; file-svc:download:view # Prompt Svc can handle file uploads prompt-svc -&gt; file-svc:upload:create Performance Optimization​ Caching Strategy​ # Pre-download frequently used files oo put /file-svc/download \\ --url=&quot;https://cdn.example.com/frequently-used.js&quot; \\ --folderPath=&quot;/cache&quot; # Batch download related files oo put /file-svc/download \\ --url=&quot;https://example.com/model.gguf&quot; \\ --folderPath=&quot;/models&quot; oo put /file-svc/download \\ --url=&quot;https://example.com/tokenizer.json&quot; \\ --folderPath=&quot;/models&quot; Bandwidth Management​ # Monitor download progress oo get /file-svc/download/https%3A%2F%2Fexample.com%2Flarge-file.zip # Pause heavy downloads during peak hours oo put /file-svc/download/https%3A%2F%2Fexample.com%2Flarge-file.zip/pause # Resume when bandwidth available oo put /file-svc/download \\ --url=&quot;https://example.com/large-file.zip&quot; \\ --folderPath=&quot;/downloads&quot; Monitoring &amp; Observability​ Download Status Tracking​ # List all downloads with status oo post /file-svc/downloads Status Values: Pending: Download queued but not startedInProgress: Currently downloadingCompleted: Download finished successfullyPaused: Download temporarily pausedFailed: Download failed (can be retried) Upload Management​ # Monitor user uploads oo post /file-svc/uploads \\ --userId=&quot;usr_12345&quot; # Check storage usage per user oo post /file-svc/uploads | jq '.uploads | group_by(.userId) | map({user: .[0].userId, count: length, totalSize: map(.fileSize) | add})' Node Distribution​ # Check which nodes have which files oo post /file-svc/uploads | jq '.uploads | group_by(.nodeId)' # Monitor download distribution oo post /file-svc/downloads | jq '.downloads | group_by(.nodeId // &quot;unknown&quot;)' Troubleshooting​ Common Issues​ Download Failures​ # Check download status oo get /file-svc/download/https%3A%2F%2Fexample.com%2Ffile.zip # Retry failed download oo put /file-svc/download \\ --url=&quot;https://example.com/file.zip&quot; \\ --folderPath=&quot;/downloads&quot; File Not Found Errors​ # Verify file exists across nodes oo post /file-svc/uploads | grep &quot;file_abc123&quot; # Check download replicas oo post /file-svc/downloads | grep &quot;example.com/file.zip&quot; Upload Permission Errors​ # Verify user permissions oo get /user-svc/permits | grep &quot;file-svc:upload&quot; # Check authentication oo whoami Debug Commands​ # List all file operations oo post /file-svc/uploads oo post /file-svc/downloads # Check specific file by ID curl -I &quot;http://localhost:11337/file-svc/serve/upload/file_abc123&quot; # Verify URL encoding for downloads node -e &quot;console.log(encodeURIComponent('https://example.com/file.zip'))&quot; Storage Management​ Disk Usage​ File Svc stores files in predictable locations: # Check upload storage usage du -sh ~/.1backend/uploads/ # Check download cache usage du -sh ~/.1backend/downloads/ # Clean up old downloads (manual process) find ~/.1backend/downloads/ -mtime +30 -delete File Lifecycle​ Downloads: Cached indefinitely unless manually cleanedUploads: Persist until explicitly deletedReplicas: Multiple copies may exist across nodesCleanup: Currently manual (automatic cleanup planned) API Reference Summary​ Endpoint\tMethod\tPurpose/file-svc/download\tPUT\tStart/resume download from URL /file-svc/download/{url}\tGET\tGet download status /file-svc/download/{url}/pause\tPUT\tPause active download /file-svc/downloads\tPOST\tList all downloads /file-svc/upload\tPUT\tUpload file (multipart) /file-svc/uploads\tPOST\tList uploaded files /file-svc/serve/upload/{fileId}\tGET\tServe uploaded file /file-svc/serve/download/{url}\tGET\tServe downloaded file Related Services​ Container Svc: Automatic asset downloading for containersChat Svc: File attachments in messagesData Svc: Store file references in objectsModel Svc: AI model file management Future Enhancements​ Planned Features​ Automatic Cleanup: Configurable retention policies for cached filesCompression: Automatic compression for large filesDeduplication: Avoid storing duplicate files across nodesThumbnails: Automatic thumbnail generation for imagesVirus Scanning: Optional malware detection for uploads Integration Roadmap​ CDN Integration: Direct integration with external CDNsCloud Storage: Support for S3, Google Cloud, Azure blob storageWebRTC: Peer-to-peer file transfer for large filesStreaming: Live video/audio streaming capabilities File Svc provides the foundation for robust, distributed file management in 1Backend, supporting everything from AI model deployment to user content management.","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Model Svc","type":0,"sectionRef":"#","url":"/docs/built-in-services/model-svc","content":"Model Svc The Model Svc is an AI model orchestration service that manages, deploys, and operates Large Language Models (LLMs) and other AI models across different runtime platforms with automatic GPU acceleration support. This page provides a comprehensive overview of Model Svc. For detailed API information, refer to the Model Svc API documentation. Architecture &amp; Purpose​ Model Svc serves as the AI model management layer for 1Backend, providing: Model Catalog: Curated collection of popular AI models (Mistral, LLaMA, CodeLlama, etc.)Platform Abstraction: Support for different AI runtimes (LlamaCpp, Stable Diffusion)Container Orchestration: Automatic deployment via Container SvcAsset Management: Model file downloading and caching via File SvcGPU Acceleration: Automatic CUDA detection and optimizationStatus Monitoring: Real-time model health and readiness tracking Key Features​ Multi-Platform Support: LlamaCpp for text generation, Stable Diffusion for image generationSmart GPU Detection: Automatic CUDA version detection and image selectionModel Lifecycle: Start, status monitoring, default model managementResource Optimization: Intelligent container sizing based on model requirementsAsset Caching: Automatic model file downloading with resume support CLI Usage​ Model Svc uses HTTP commands for all operations: Starting Models​ # Start the default model oo put /model-svc/default-model/start # Start a specific model by ID oo put /model-svc/model/huggingface%2FTheBloke%2Fmistral-7b-instruct-v0.2.Q4_K_M.gguf/start # Start a lightweight model for testing oo put /model-svc/model/huggingface%2FTheBloke%2Ftinyllama-1.1b-chat-v1.0.Q4_K_S.gguf/start # Start Stable Diffusion for image generation oo put /model-svc/model/nicklucche%2Fstable-diffusion/start Model Status &amp; Monitoring​ # Check default model status oo get /model-svc/default-model/status # Check specific model status oo get /model-svc/model/huggingface%2FTheBloke%2Fmistral-7b-instruct-v0.2.Q4_K_M.gguf/status # Get model details oo get /model-svc/model/huggingface%2FTheBloke%2Fcodellama-7b.Q4_K_M.gguf Model Management​ # List all available models oo post /model-svc/models # List AI platforms oo post /model-svc/platforms # Set default model oo put /model-svc/model/huggingface%2FTheBloke%2Fmistral-7b-instruct-v0.2.Q4_K_M.gguf/make-default URL Encoding for Model IDs​ Model IDs contain special characters that must be URL-encoded: # Original ID: huggingface/TheBloke/mistral-7b-instruct-v0.2.Q4_K_M.gguf # URL encoded: huggingface%2FTheBloke%2Fmistral-7b-instruct-v0.2.Q4_K_M.gguf # Use this helper for encoding echo &quot;huggingface/TheBloke/mistral-7b-instruct-v0.2.Q4_K_M.gguf&quot; | jq -rR @uri Platform Architecture​ AI Platforms​ Model Svc supports multiple AI runtime platforms: LlamaCpp Platform​ { &quot;id&quot;: &quot;llama-cpp&quot;, &quot;name&quot;: &quot;Llama CPP&quot;, &quot;types&quot;: [&quot;text-to-text&quot;], &quot;architectures&quot;: { &quot;default&quot;: { &quot;container&quot;: { &quot;imageTemplate&quot;: &quot;crufter/llama-cpp-python:default-1-latest&quot;, &quot;port&quot;: 8000 } }, &quot;cuda&quot;: { &quot;container&quot;: { &quot;imageTemplate&quot;: &quot;crufter/llama-cpp-python:cuda-$cudaVersion-latest&quot;, &quot;port&quot;: 8000, &quot;envars&quot;: [{&quot;key&quot;: &quot;NVIDIA_VISIBLE_DEVICES&quot;, &quot;value&quot;: &quot;all&quot;}] }, &quot;defaultCudaVersion&quot;: &quot;12.8.0&quot;, &quot;cudaVersionPrecision&quot;: 3 } } } Stable Diffusion Platform​ { &quot;id&quot;: &quot;stable-diffusion&quot;, &quot;name&quot;: &quot;Stable Diffusion&quot;, &quot;types&quot;: [&quot;text-to-image&quot;, &quot;image-to-image&quot;], &quot;architectures&quot;: { &quot;default&quot;: { &quot;container&quot;: { &quot;imageTemplate&quot;: &quot;crufter/stable-diffusion:default-1-latest&quot;, &quot;port&quot;: 7860, &quot;envars&quot;: [{&quot;key&quot;: &quot;CLI_ARGS&quot;, &quot;value&quot;: &quot;--no-half --precision full --allow-code --enable-insecure-extension-access --api&quot;}] } }, &quot;cuda&quot;: { &quot;container&quot;: { &quot;imageTemplate&quot;: &quot;crufter/stable-diffusion:cuda-$cudaVersion-latest&quot;, &quot;port&quot;: 7860 }, &quot;defaultCudaVersion&quot;: &quot;12.1&quot;, &quot;defaultCudnnVersion&quot;: &quot;9&quot; } } } GPU Acceleration (CUDA)​ Model Svc automatically detects and configures GPU acceleration: CUDA Version Detection: Automatically detects system CUDA versionMatches to appropriate container imageFalls back to default version if specific image unavailableSupports precision control (major.minor.patch) Model Catalog​ Popular Models​ Mistral 7B (Recommended)​ # High-quality general purpose model Model ID: huggingface/TheBloke/mistral-7b-instruct-v0.2.Q4_K_M.gguf Size: 4.37 GB, RAM: 6.87 GB Quality: Q4_K_M (medium, balanced quality - recommended) Prompt: [INST] {prompt} [/INST] CodeLlama (Code Generation)​ # Specialized for programming tasks Model ID: huggingface/TheBloke/codellama-7b.Q4_K_M.gguf Size: 4.24 GB, RAM: 6.74 GB Quality: Q4_K_M (medium, balanced quality - recommended) Prompt: {prompt} TinyLlama (Lightweight)​ # Fast, minimal resource usage Model ID: huggingface/TheBloke/tinyllama-1.1b-chat-v1.0.Q4_K_S.gguf Size: 0.5 GB, RAM: 3.0 GB Quality: Q4_K_S (small, acceptable quality) Prompt: &lt;|system|&gt;\\n{system_message}&lt;/s&gt;\\n&lt;|user|&gt;\\n{prompt}&lt;/s&gt;\\n&lt;|assistant|&gt; LLaMA2 Chat Uncensored​ # Uncensored conversational model Model ID: huggingface/TheBloke/llama2_7b_chat_uncensored.Q4_K_M.gguf Size: 4.08 GB, RAM: 6.58 GB Uncensored: true Prompt: ### HUMAN:\\n{prompt}\\n\\n### RESPONSE:\\n Stable Diffusion (Image Generation)​ # Text-to-image generation Model ID: nicklucche/stable-diffusion Platform: stable-diffusion Types: text-to-image, image-to-image Model Quality Levels​ Quality\tSize\tRAM Usage\tQuality Loss\tRecommendationQ2_K\tSmallest\t~5.5GB\tSignificant\tNot recommended Q3_K_S\tVery Small\t~5.7GB\tHigh\tTesting only Q3_K_M\tSmall\t~6.1GB\tSubstantial\tBasic usage Q4_K_M\tMedium\t~6.9GB\tBalanced\t✅ Recommended Q5_K_M\tLarge\t~7.3GB\tVery Low\tHigh quality Q6_K\tVery Large\t~8.0GB\tExtremely Low\tMaximum quality Q8_0\tLargest\t~9.7GB\tMinimal\tNot recommended Container Integration​ Model Launch Flow​ Container Configuration​ Model Svc automatically configures containers based on: # Container naming (single model per node) Container Name: &quot;the-1backend-container&quot; Host Port: 8001 (standardized) # GPU Configuration (when available) NVIDIA_VISIBLE_DEVICES=all GPU Capabilities: enabled # Volume Mounts (for model persistence) Keeps: [&quot;/model&quot;, &quot;/cache&quot;] # Environment Variables (model-specific) MODEL=/path/to/downloaded/model.gguf CLI_ARGS=--specific-model-args Real-World Usage Examples​ 1. Text Generation Setup​ # Start with a balanced general-purpose model oo put /model-svc/model/huggingface%2FTheBloke%2Fmistral-7b-instruct-v0.2.Q4_K_M.gguf/start # Monitor startup progress watch -n 2 'oo get /model-svc/default-model/status' # Wait for model to be ready # {&quot;status&quot;: {&quot;assetsReady&quot;: true, &quot;running&quot;: true, &quot;address&quot;: &quot;localhost:8001&quot;}} # Test with Prompt Svc oo post /prompt-svc/prompt \\ --message=&quot;Explain quantum computing in simple terms&quot; \\ --type=&quot;text-to-text&quot; 2. Code Generation Workflow​ # Start CodeLlama for programming tasks oo put /model-svc/model/huggingface%2FTheBloke%2Fcodellama-7b.Q4_K_M.gguf/start # Set as default for code tasks oo put /model-svc/model/huggingface%2FTheBloke%2Fcodellama-7b.Q4_K_M.gguf/make-default # Generate code oo post /prompt-svc/prompt \\ --message=&quot;Write a Python function to calculate Fibonacci numbers&quot; \\ --type=&quot;text-to-text&quot; 3. Image Generation Setup​ # Start Stable Diffusion oo put /model-svc/model/nicklucche%2Fstable-diffusion/start # Monitor status (image models take longer to start) oo get /model-svc/model/nicklucche%2Fstable-diffusion/status # Generate images via Prompt Svc oo post /prompt-svc/prompt \\ --message=&quot;A serene mountain landscape at sunset&quot; \\ --type=&quot;text-to-image&quot; 4. Model Comparison Testing​ # Test different model sizes MODELS=( &quot;huggingface%2FTheBloke%2Ftinyllama-1.1b-chat-v1.0.Q4_K_S.gguf&quot; &quot;huggingface%2FTheBloke%2Fmistral-7b-instruct-v0.2.Q3_K_M.gguf&quot; &quot;huggingface%2FTheBloke%2Fmistral-7b-instruct-v0.2.Q4_K_M.gguf&quot; ) for MODEL in &quot;${MODELS[@]}&quot;; do echo &quot;Testing $MODEL&quot; oo put /model-svc/model/$MODEL/start sleep 30 # Wait for model to load # Test response quality oo post /prompt-svc/prompt \\ --message=&quot;Write a short story about a robot learning to paint&quot; \\ --type=&quot;text-to-text&quot; echo &quot;---&quot; done 5. Production Model Deployment​ # Use high-quality model for production oo put /model-svc/model/huggingface%2FTheBloke%2Fmistral-7b-instruct-v0.2.Q5_K_M.gguf/start # Set as system default oo put /model-svc/model/huggingface%2FTheBloke%2Fmistral-7b-instruct-v0.2.Q5_K_M.gguf/make-default # Verify configuration oo get /model-svc/default-model/status # Test with realistic workload oo post /prompt-svc/prompt \\ --message=&quot;Analyze this business proposal and provide recommendations&quot; \\ --type=&quot;text-to-text&quot; 6. GPU-Optimized Deployment​ # Check available models oo post /model-svc/models | jq '.models[] | select(.size &lt; 8) | {id, name, size, maxRam}' # Start model (will auto-detect GPU) oo put /model-svc/model/huggingface%2FTheBloke%2Fmistral-7b-instruct-v0.2.Q4_K_M.gguf/start # Verify GPU usage docker stats the-1backend-container # Monitor GPU memory nvidia-smi Asset Management &amp; File Integration​ Model File Handling​ Model Svc integrates seamlessly with File Svc: # Check model asset status oo get /model-svc/model/huggingface%2FTheBloke%2Fmistral-7b-instruct-v0.2.Q4_K_M.gguf # Monitor download progress oo get /file-svc/download/https%3A%2F%2Fhuggingface.co%2FTheBloke%2FMistral-7B-Instruct-v0.2-GGUF%2Fresolve%2Fmain%2Fmistral-7b-instruct-v0.2.Q4_K_M.gguf # List all cached models oo post /file-svc/downloads | jq '.downloads[] | select(.url | contains(&quot;huggingface&quot;))' Asset Flow: Model start requestedCheck if model files exist in File Svc cacheIf missing, trigger download from HuggingFace/sourceFiles cached in ~/.1backend/downloads/Container launched with model file mounted as $MODEL environment variable Storage Requirements​ # Check model storage usage du -sh ~/.1backend/downloads/ # Popular model sizes: TinyLlama 1.1B: ~500MB Mistral 7B Q4_K_M: ~4.4GB CodeLlama 7B: ~4.2GB LLaMA2 7B: ~4.1GB Mixtral 8x7B: ~15-50GB (depending on quality) Llama 3 70B: ~26-43GB (depending on quality) Model Status &amp; Health Monitoring​ Status Response Structure​ { &quot;status&quot;: { &quot;assetsReady&quot;: true, &quot;running&quot;: true, &quot;address&quot;: &quot;localhost:8001&quot; } } Status Fields: assetsReady: Model files downloaded and availablerunning: Container is running AND responding to requestsaddress: Network address where model can be accessed Health Check Process​ Monitoring Commands​ # Continuous status monitoring watch -n 5 'oo get /model-svc/default-model/status' # Check container logs if model fails docker logs the-1backend-container # Monitor resource usage docker stats the-1backend-container # Check model API directly curl http://localhost:8001/health # List all running models oo post /model-svc/models | jq '.models[] | {id, name, size}' Configuration Management​ Default Model Configuration​ Model Svc stores the current default model in Config Svc: # Check current default model oo post /config-svc/configs \\ --keys='[&quot;modelSvc&quot;]' | jq '.configs.modelSvc.data.currentModelId' # The default model ID (if none set) Default: &quot;huggingface/TheBloke/mistral-7b-instruct-v0.2.Q3_K_S.gguf&quot; Environment Variables​ # GPU platform detection OB_GPU_PLATFORM=cuda # Enables CUDA support OB_LLM_HOST=localhost # Override model host address # Container resource limits DOCKER_MEMORY_LIMIT=8g # Container memory limit NVIDIA_VISIBLE_DEVICES=all # GPU access Integration Patterns​ With Prompt Svc​ Model Svc provides the AI backend for Prompt Svc: # Start model oo put /model-svc/default-model/start # Use through Prompt Svc oo post /prompt-svc/prompt \\ --message=&quot;Hello, how are you?&quot; \\ --type=&quot;text-to-text&quot; # Model address is automatically used by Prompt Svc # (localhost:8001) With Chat Svc​ Chat applications automatically use the default model: # Ensure model is running oo get /model-svc/default-model/status # Create chat thread oo post /chat-svc/thread \\ --threadData.title=&quot;AI Assistant&quot; # Send message (automatically routed to Model Svc) oo post /chat-svc/thread/thread_123/message \\ --text=&quot;Explain machine learning&quot; \\ --userId=&quot;usr_456&quot; With File Svc​ Model assets are managed through File Svc: # Check model file cache oo post /file-svc/downloads | grep -A 5 &quot;mistral&quot; # Manually download model files oo put /file-svc/download \\ --url=&quot;https://huggingface.co/TheBloke/Mistral-7B-Instruct-v0.2-GGUF/resolve/main/mistral-7b-instruct-v0.2.Q4_K_M.gguf&quot; \\ --folderPath=&quot;/models&quot; Performance Optimization​ Resource Planning​ # Small setup (&lt; 8GB RAM) Model: TinyLlama 1.1B Q4_K_S RAM: ~3GB Storage: ~500MB # Medium setup (8-16GB RAM) Model: Mistral 7B Q4_K_M RAM: ~7GB Storage: ~4.4GB # Large setup (16+ GB RAM) Model: Mistral 7B Q5_K_M RAM: ~7.3GB Storage: ~4.8GB # GPU setup (8+ GB VRAM) Model: Mistral 7B Q4_K_M + CUDA RAM: ~7GB + GPU acceleration VRAM: ~4GB Startup Optimization​ # Pre-download model files oo put /file-svc/download \\ --url=&quot;https://huggingface.co/TheBloke/Mistral-7B-Instruct-v0.2-GGUF/resolve/main/mistral-7b-instruct-v0.2.Q4_K_M.gguf&quot; \\ --folderPath=&quot;/models&quot; # Then start model (skips download) oo put /model-svc/model/huggingface%2FTheBloke%2Fmistral-7b-instruct-v0.2.Q4_K_M.gguf/start # Use fastest small model for development oo put /model-svc/model/huggingface%2FTheBloke%2Ftinyllama-1.1b-chat-v1.0.Q4_K_S.gguf/start Troubleshooting​ Common Issues​ Model Won't Start​ # Check asset download status oo get /model-svc/model/YOUR_MODEL_ID/status # Check file download progress oo post /file-svc/downloads | grep &quot;YOUR_MODEL&quot; # Check container logs docker logs the-1backend-container # Verify model exists in catalog oo post /model-svc/models | grep &quot;YOUR_MODEL&quot; Out of Memory Errors​ # Check available memory free -h # Use smaller model oo put /model-svc/model/huggingface%2FTheBloke%2Ftinyllama-1.1b-chat-v1.0.Q4_K_S.gguf/start # Monitor container memory docker stats the-1backend-container GPU Not Detected​ # Check CUDA installation nvidia-smi # Verify Docker GPU support docker run --rm --gpus all nvidia/cuda:11.0-base nvidia-smi # Check Model Svc GPU platform echo $OB_GPU_PLATFORM # Should be &quot;cuda&quot; Model Download Failures​ # Check internet connectivity curl -I https://huggingface.co # Retry download manually oo put /file-svc/download \\ --url=&quot;YOUR_MODEL_URL&quot; \\ --folderPath=&quot;/models&quot; # Check download errors oo post /file-svc/downloads | jq '.downloads[] | select(.status != &quot;Completed&quot;)' Debug Commands​ # Full model information oo get /model-svc/model/YOUR_MODEL_ID # Container status docker ps | grep the-1backend-container # Model API health curl http://localhost:8001/health # File system usage du -sh ~/.1backend/downloads/ df -h # Network connectivity curl -I http://localhost:8001 telnet localhost 8001 API Reference Summary​ Endpoint\tMethod\tPurpose/model-svc/default-model/start\tPUT\tStart the default model /model-svc/model/{modelId}/start\tPUT\tStart specific model /model-svc/default-model/status\tGET\tGet default model status /model-svc/model/{modelId}/status\tGET\tGet specific model status /model-svc/models\tPOST\tList all available models /model-svc/platforms\tPOST\tList AI platforms /model-svc/model/{modelId}\tGET\tGet model details /model-svc/model/{modelId}/make-default\tPUT\tSet model as default Permissions &amp; Security​ # Required permissions model-svc:model:create # Start models model-svc:model:view # View model status and list model-svc:platform:view # List platforms # Service permissions (automatic) prompt-svc -&gt; model-svc:model:view # Prompt Svc can query models prompt-svc -&gt; model-svc:platform:view # Prompt Svc can list platforms Related Services​ Container Svc: Runs AI model containersFile Svc: Downloads and caches model filesPrompt Svc: Sends prompts to running modelsChat Svc: AI-powered chat applicationsConfig Svc: Stores default model configuration Future Enhancements​ Planned Features​ Multi-Model Support: Run multiple models simultaneouslyModel Quantization: Dynamic quality adjustment based on available resourcesAuto-Scaling: Scale model instances based on request loadModel Marketplace: Extended catalog with community modelsFine-Tuning: Support for custom model training and fine-tuning Integration Roadmap​ Cloud Providers: Integration with cloud GPU services (AWS, GCP, Azure)Model Serving: Dedicated model serving platforms (TensorRT, TorchServe)Distributed Inference: Model sharding across multiple nodesA/B Testing: Compare different models for the same taskCost Optimization: Automatic model selection based on cost/performance Model Svc provides the foundation for AI-powered applications in 1Backend, handling everything from model deployment to health monitoring with automatic GPU acceleration and intelligent resource management.","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Proxy Svc","type":0,"sectionRef":"#","url":"/docs/built-in-services/proxy-svc","content":"Proxy Svc The Proxy Svc is a sophisticated reverse proxy and load balancer that handles both internal service routing and edge traffic management with automatic HTTPS certificate provisioning. This page provides a comprehensive overview of Proxy Svc. For detailed API information, refer to the Proxy Svc API documentation. Architecture &amp; Purpose​ Proxy Svc serves as the traffic management layer for 1Backend, providing: Service Proxying: Routes requests to custom services registered in the Registry SvcEdge Proxying: Handles external HTTPS traffic with automatic TLS terminationLoad Balancing: Intelligent distribution with health-aware routingCertificate Management: Automatic Let's Encrypt certificate provisioning and renewalMulti-Tenant Routing: Domain-based routing for multiple applications Dual Operation Modes​ Microfrontends by Path​ Proxy Svc supports hosting multiple frontends under a single domain by using path-prefix routes. This makes it easy to run a microfrontend architecture without extra gateways. Example Routes​ id: &quot;x.localhost&quot; target: &quot;http://root-frontend:8080&quot; id: &quot;x.localhost/app&quot; target: &quot;http://app-frontend:3000&quot; id: &quot;x.localhost/app/admin&quot; target: &quot;http://admin-frontend:4000&quot; How Lookup Works​ When a request comes in, Proxy Svc tries the longest matching prefix: /app/admin/settings → matches x.localhost/app/admin → goes to http://admin-frontend:4000/app/admin/settings /app/page → matches x.localhost/app → goes to http://app-frontend:3000/app/page / or anything else → falls back to x.localhost → goes to http://root-frontend:8080/ Visual Flow​ Benefits: Multiple independent frontends can live under one domainDeepest path prefix always takes precedence, ensuring /app/admin resolves correctlyEasy to extend: just add more host+path routes Routes and Apps​ The Proxy Svc and its routes enable you to host multiple web applications (ie. websites) under different hosts using a single 1Backend installation. In this section we'll explore the most minimal multiapp setup possible.First make sure 1Backend runs with OB_EDGE_PROXY set to true: # Some setup is needed to make sure the server can bind to port 80 ~/1backend/server$ go build -o server main.go &amp;&amp; sudo setcap 'cap_net_bind_service=+ep' ./server &amp;&amp; OB_EDGE_PROXY_TEST_MODE=true ./server # Output streams... Now let's launch two servers: node -e &quot; const http=require('http'); http.createServer((_,res)=&gt;res.end('Server A\\n')).listen(4200); http.createServer((_,res)=&gt;res.end('Server B\\n')).listen(4201); &quot; # routeA.yaml id: &quot;127.0.0.1&quot; target: &quot;127.0.0.1:4200&quot; # routeB.yaml id: &quot;localhost&quot; target: &quot;127.0.0.1:4201&quot; Please note that the ID and the target is the same because we have no domain to route. oo route save routeA.yaml oo route save routeB.yaml Now you're ready to call them: $ curl 127.0.0.1 Server A $ curl localhost Server B CLI Usage​ Route Management​ # List all configured routes oo routes list # Save routes from YAML file oo routes save routes.yaml # Save routes from directory (processes all .yaml files) oo routes save ./config/routes/ Route Configuration Files​ Single Route YAML​ # api-route.yaml id: &quot;api.example.com&quot; target: &quot;http://1backend:11337&quot; Multiple Routes YAML​ # routes.yaml - id: &quot;api.example.com&quot; target: &quot;http://1backend:11337&quot; - id: &quot;example.com&quot; target: &quot;http://frontend:8080&quot; - id: &quot;cdn.example.com&quot; target: &quot;http://nginx:80&quot; - id: &quot;app.example.com&quot; target: &quot;http://react-app:3000&quot; Service Proxying (Internal Routing)​ How Service Routing Works​ When you send a request to 1Backend: curl http://127.0.0.1:11337/user-svc/login The routing decision follows this flow: Edge Proxy Flow​ Automatic HTTPS Certificates​ The edge proxy automatically handles: Certificate Provisioning: Requests certificates from Let's EncryptChallenge Handling: Responds to ACME HTTP-01 challenges on port 80TLS Termination: Handles SSL/TLS encryption/decryptionCertificate Renewal: Automatically renews certificates before expiryCertificate Storage: Encrypted storage in the database crufter@cruftop:~/1backend$ oo certs ls CERT ID CREATED AT UPDATED AT COMMON NAME ISSUER NOT BEFORE NOT AFTER SERIAL singulatron.com 2025-06-08 2025-08-09 14:22:44 singulatron.com E6 2025-08-09 2025-11-07 34394815… api.singulatron.com 2025-06-08 2025-08-09 14:15:47 api.singulatron.com E5 2025-08-09 2025-11-07 83840157… acme_account+key 2025-06-08 2025-06-08 14:12:42 ","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Secret Svc","type":0,"sectionRef":"#","url":"/docs/built-in-services/secret-svc","content":"Secret Svc The Secret Svc provides secure, encrypted storage for sensitive configuration data in 1Backend. It offers enterprise-grade secret management with multi-tenant access controls, encryption at rest, GitOps integration, and comprehensive audit capabilities. This page provides comprehensive usage examples and advanced features. For API details, see Secret Svc API documentation. Access rules​ Read​ Any logged in user who is amongst a Secret's Readers can read a secret. Write​ Create​ Any logged in user can create a secret. Non-admin users can only create secrets with the key prefixed by their slug, ie: deploy-svc/EXAMPLE-KEY vs non-prefixed keys such as EMAIL_API_KEY Non-prefixed keys like EMAIL_API_KEY can only be created by admin users. This prefix rule serves two purposes: It is clear which secret keys are &quot;static&quot; and originating from admin usersIt can prevent issues where a user claims a key knowing that it might be used later and overwritten/populated by an admin with sensitive information Update​ After a key is created further write access is governed by the Writers block. Entities​ Secret​ id: &quot;secr_eG8IvKwB0A&quot; key: &quot;MY_API_KEY&quot; value: &quot;nNl4X9+@95Z&quot; # Slugs of services and users who can read the secret readers: - &quot;alice&quot; - &quot;bob&quot; # Slugs of services and users who can modify the secret writers: - &quot;alice&quot; - &quot;bob&quot; # Slugs of services and users who can delete the secret deleters: - &quot;service-admin&quot; # Slugs of services and users who can change the &quot;readers&quot; list canChangeReaders: - &quot;alice&quot; # Slugs of services and users who can change the &quot;writers&quot; list canChangeWriters: - &quot;alice&quot; # Slugs of services and users who can change the &quot;deleters&quot; list canChangeDeleters: - &quot;alice&quot; Design choices​ The Secret Svc, like most things in 1Backend, is designed to be simple to reason about. Instead of the 1Backend injecting environment variables into service containers when they are deployed, the services are left to their own devices to read secrets from the Secret Svc through normal service calls, using their credentials. This approach also works for services that you deploy manually (e.g., Kubernetes, Docker Compose) rather than through 1Backend. Encryption at rest and transit​ All data is encrypted using the encryption key provided by the envar OB_ENCRYPTION_KEY (see Todo section). The server encrypts the secret values before saving them to disk/DB. The secret values are transmitted to readers unencrypted. Tips​ Encrypt​ The encrypt command helps you create encrypted YAML files that can be safely stored in source control and integrated into Infrastructure-as-Code (IaC) or GitOps workflows. This ensures sensitive data is protected while enabling automated deployment processes. oo secret encrypt example-key example-value id: &quot;secr_eR6LbYOBK2&quot; key: &quot;example-key&quot; value: &quot;62bQMQf5wPMrAsJ7+bcZpKBMtA7Ap7DF6xZaioq9jU0=&quot; encrypted: true checksum: &quot;45a3b25f&quot; checksumAlgorithm: &quot;CRC32&quot; Save the output to a file and, in your continuous delivery pipeline, apply it: oo secret save my-api-key.yaml Checksum​ Checksums are optional and serve to verify the integrity of encrypted values. When an already encrypted value is saved in the Secret Svc, the service decodes it and uses the checksum to ensure the value remains intact. Is Secure​ After setting up your daemon it's a good idea to check if the Secret Svc is secure: $ oo secret is-secure Service is secure. This will return successfully if the encryption key has been changed from the default value and all necessary setup steps have been completed. CLI Reference​ Basic Secret Management​ # Save a simple API key oo secret save DATABASE_URL &quot;postgresql://user:pass@host:5432/db&quot; # List all accessible secrets oo secret list # Show secret values (unmasked) oo secret list --show # Remove a secret by key oo secret remove --key DATABASE_URL Secure Encryption Workflow​ # Encrypt a secret for GitOps (interactive - hides value from terminal) oo secret encrypt API_KEY Enter secret value: [hidden] # Direct encryption (for automation) oo secret encrypt API_KEY &quot;super-secret-value&quot; # Check if service is properly secured oo secret is-secure Secret Management Commands​ oo secret save - Store Secrets​ Basic Usage: # Save key-value pair oo secret save &lt;key&gt; &lt;value&gt; # Save from YAML file oo secret save &lt;file.yaml&gt; # Save multiple secrets from directory oo secret save &lt;directory&gt; Examples: # API credentials oo secret save STRIPE_SECRET_KEY &quot;sk_test_abc123&quot; oo secret save OPENAI_API_KEY &quot;sk-proj-xyz789&quot; # Database connection oo secret save DB_PASSWORD &quot;complex-password-123&quot; # Service-specific secrets (auto-prefixed for non-admin users) oo secret save auth-svc/JWT_SECRET &quot;jwt-signing-key&quot; oo secret save payment-svc/WEBHOOK_SECRET &quot;webhook-validation-key&quot; oo secret list - View Secrets​ Usage: oo secret list [options] oo secret list [key-pattern] Options: --show - Display actual values (unmasked)--namespace, -n - Filter by namespace/app Examples: # List all secrets (values masked) oo secret list # Show actual secret values oo secret list --show # Filter by key pattern oo secret list DATABASE oo secret remove - Delete Secrets​ Usage: oo secret remove --key &lt;key&gt; [--key &lt;key2&gt;...] oo secret remove --id &lt;id&gt; [--id &lt;id2&gt;...] Examples: # Remove by key oo secret remove --key API_KEY # Remove multiple by key oo secret remove --key DB_USER --key DB_PASS # Remove by ID oo secret remove --id secr_abc123 oo secret encrypt - GitOps Encryption​ Usage: oo secret encrypt &lt;key&gt; [value] Examples: # Interactive encryption (secure - no terminal history) oo secret encrypt PRODUCTION_API_KEY Enter secret value: [hidden] # Direct encryption for automation oo secret encrypt STAGING_KEY &quot;staging-value&quot; # Output ready for version control oo secret encrypt DATABASE_PASSWORD &gt; secrets/prod-db.yaml oo secret is-secure - Security Check​ # Verify service security configuration oo secret is-secure Service is secure. # Example warning output oo secret is-secure Error: secret svc is not secure: it is using the default encryption key File-Based Secret Management​ Single Secret YAML Structure​ # production-api-key.yaml id: &quot;secr_prod_api_001&quot; key: &quot;PRODUCTION_API_KEY&quot; value: &quot;a37/KUAr4SOYi6Xw9i9T8qo3QCk8WvnzONo47jHAkwk=&quot; encrypted: true checksum: &quot;45a3b25f&quot; checksumAlgorithm: &quot;CRC32&quot; # Access control readers: - &quot;payment-svc&quot; - &quot;order-svc&quot; - &quot;admin-team&quot; writers: - &quot;admin-team&quot; - &quot;devops-team&quot; deleters: - &quot;admin-team&quot; # Permission management canChangeReaders: - &quot;admin-team&quot; canChangeWriters: - &quot;admin-team&quot; canChangeDeleters: - &quot;admin-team&quot; Multiple Secrets YAML Structure​ # application-secrets.yaml - id: &quot;secr_db_primary&quot; key: &quot;DATABASE_URL&quot; value: &quot;encrypted-connection-string&quot; encrypted: true readers: [&quot;api-svc&quot;, &quot;worker-svc&quot;] writers: [&quot;admin-team&quot;] - id: &quot;secr_redis_cache&quot; key: &quot;REDIS_URL&quot; value: &quot;redis://localhost:6379&quot; encrypted: false readers: [&quot;api-svc&quot;, &quot;cache-svc&quot;] writers: [&quot;devops-team&quot;] - id: &quot;secr_jwt_signing&quot; key: &quot;JWT_SECRET&quot; value: &quot;encrypted-jwt-key&quot; encrypted: true readers: [&quot;auth-svc&quot;] writers: [&quot;security-team&quot;] Batch Operations​ # Deploy all production secrets oo secret save secrets/production/ # Update staging environment oo secret save environments/staging-secrets.yaml Advanced Permission Management​ Granular Access Control​ The Secret Svc implements fine-grained permission management with six distinct access levels: Permission Types​ readers - Can view secret valueswriters - Can modify secret valuesdeleters - Can remove secretscanChangeReaders - Can modify the readers listcanChangeWriters - Can modify the writers listcanChangeDeleters - Can modify the deleters list User vs &quot;Admin&quot; Access​ Regular Users: Can only create secrets with keys prefixed by their user slugAutomatically granted all permissions on their own secretsMust be explicitly granted access to others' secretsNeed the Admin Users: Can create secrets with any key nameHave access to all secrets regardless of permission listsCan modify any secret's permission structure Permission Scenarios​ Service-to-Service Communication​ # auth-service-secrets.yaml - key: &quot;auth-svc/DATABASE_URL&quot; value: &quot;encrypted-db-connection&quot; encrypted: true readers: [&quot;auth-svc&quot;] # Only auth service can read writers: [&quot;devops-team&quot;] # Only devops can update deleters: [&quot;admin-team&quot;] # Only admins can delete - key: &quot;auth-svc/JWT_SECRET&quot; value: &quot;encrypted-jwt-key&quot; encrypted: true readers: [&quot;auth-svc&quot;, &quot;api-gateway&quot;] # Both services need access writers: [&quot;security-team&quot;] deleters: [&quot;security-team&quot;] Cross-Team Secret Sharing​ # shared-infrastructure-secrets.yaml - key: &quot;MONITORING_API_KEY&quot; value: &quot;encrypted-monitoring-key&quot; encrypted: true readers: [&quot;platform-team&quot;, &quot;sre-team&quot;, &quot;monitoring-svc&quot;] writers: [&quot;platform-team&quot;] deleters: [&quot;platform-team&quot;] canChangeReaders: [&quot;platform-team&quot;, &quot;sre-team&quot;] # Both teams can add readers canChangeWriters: [&quot;platform-team&quot;] # Only platform team controls writers Encryption and Security​ Supported Checksum Algorithms​ The Secret Svc supports multiple checksum algorithms for data integrity verification: CRC32 (default) - Fast, good for basic integrity checksSHA-256 - Cryptographically secure, recommended for productionSHA-512 - Maximum security, slower performanceBLAKE2s - Fast and secure alternative to SHA family Encryption Workflow for GitOps​ 1. Encrypt Locally​ # Create encrypted secret file oo secret encrypt PRODUCTION_DATABASE_URL &gt; secrets/prod-db.yaml # Example output (safe for version control): # id: &quot;secr_ABC123&quot; # key: &quot;PRODUCTION_DATABASE_URL&quot; # value: &quot;a37/KUAr4SOYi6Xw9i9T8qo3QCk8WvnzONo47jHAkwk=&quot; # encrypted: true # checksum: &quot;45a3b25f&quot; # checksumAlgorithm: &quot;CRC32&quot; 2. Version Control Integration​ # Commit encrypted secrets safely git add secrets/ git commit -m &quot;Add production database credentials&quot; git push origin main 3. Deployment Pipeline​ # In CI/CD pipeline oo secret save secrets/production/ oo secret save secrets/staging/ # Verify deployment oo secret is-secure oo secret list --namespace production Real-World Usage Patterns​ Multi-Environment Management​ Development Environment Setup​ # Development secrets (unencrypted for local debugging) oo secret save dev/DATABASE_URL &quot;postgresql://localhost:5432/myapp_dev&quot; oo secret save dev/REDIS_URL &quot;redis://localhost:6379&quot; oo secret save dev/API_KEY &quot;dev-api-key-12345&quot; # List development secrets oo secret list --namespace dev Microservices Architecture​ Service-Specific Secret Management​ # Authentication service secrets oo secret save auth-svc/JWT_SECRET &quot;$(openssl rand -base64 32)&quot; oo secret save auth-svc/OAUTH_CLIENT_SECRET &quot;oauth-client-secret&quot; oo secret save auth-svc/PASSWORD_SALT &quot;$(openssl rand -base64 16)&quot; # Payment service secrets oo secret save payment-svc/STRIPE_SECRET_KEY &quot;sk_live_abc123&quot; oo secret save payment-svc/WEBHOOK_SECRET &quot;whsec_xyz789&quot; # Email service secrets oo secret save email-svc/SENDGRID_API_KEY &quot;SG.abc123&quot; oo secret save email-svc/SMTP_PASSWORD &quot;smtp-password&quot; Cross-Service Dependencies​ # shared-service-secrets.yaml - key: &quot;shared/DATABASE_URL&quot; value: &quot;encrypted-shared-db-connection&quot; encrypted: true readers: - &quot;auth-svc&quot; - &quot;user-svc&quot; - &quot;payment-svc&quot; - &quot;order-svc&quot; writers: [&quot;dba-team&quot;] deleters: [&quot;admin-team&quot;] - key: &quot;shared/REDIS_URL&quot; value: &quot;encrypted-redis-connection&quot; encrypted: true readers: - &quot;cache-svc&quot; - &quot;session-svc&quot; - &quot;rate-limiter-svc&quot; writers: [&quot;infrastructure-team&quot;] Security Best Practices​ Encryption Key Management​ Change Default Encryption Key # Always verify encryption is properly configured oo secret is-secure # Set strong encryption key in environment export OB_ENCRYPTION_KEY=&quot;$(openssl rand -base64 32)&quot; Access Control Best Practices​ Principle of Least Privilege # Give minimum necessary access - key: &quot;payment-svc/STRIPE_KEY&quot; readers: [&quot;payment-svc&quot;] # Only payment service writers: [&quot;payment-admin&quot;] # Only payment administrators deleters: [&quot;security-team&quot;] # Only security team can delete ","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Policy Svc","type":0,"sectionRef":"#","url":"/docs/built-in-services/policy-svc","content":"Policy Svc The Policy Svc is a comprehensive access control and rate limiting service that provides protection against abuse, ensures fair resource usage, and maintains service reliability through configurable policies. This page provides a comprehensive overview of Policy Svc. For detailed API information, refer to the Policy Svc API documentation. Architecture &amp; Purpose​ Policy Svc serves as the service protection layer for 1Backend, providing: Rate Limiting: Prevent resource exhaustion by limiting requests per user/IP/endpointAccess Control: Block malicious IPs or users from accessing servicesAbuse Prevention: Protect against DDoS attacks and automated abuseFair Usage: Ensure equitable resource distribution across usersService Reliability: Maintain system stability under high load Key Features​ Flexible Templates: Pre-built policies for common protection scenariosMultiple Entities: Rate limit by user ID, IP address, or custom identifiersGranular Scoping: Apply policies per-endpoint or globally across servicesTime Windows: Configurable periods (seconds, minutes, hours, days)Explicit Integration: Services opt-in to policy checking for maximum control CLI Usage​ Policy Svc uses HTTP commands for all operations: Creating Policy Instances​ # Rate limit user registrations: 5 per IP per day oo put /policy-svc/instance/registration-rate-limit \\ --instance.endpoint=&quot;/user-svc/register&quot; \\ --instance.templateId=&quot;rate-limit&quot; \\ --instance.parameters.rateLimit.maxRequests=5 \\ --instance.parameters.rateLimit.timeWindow=&quot;1d&quot; \\ --instance.parameters.rateLimit.entity=&quot;ip&quot; \\ --instance.parameters.rateLimit.scope=&quot;endpoint&quot; # Block malicious IPs from login endpoint oo put /policy-svc/instance/login-ip-blocklist \\ --instance.endpoint=&quot;/user-svc/login&quot; \\ --instance.templateId=&quot;blocklist&quot; \\ --instance.parameters.blocklist.blockedIPs='[&quot;192.168.1.100&quot;, &quot;10.0.0.50&quot;]' # Rate limit API calls: 100 per user per hour across all endpoints oo put /policy-svc/instance/api-user-rate-limit \\ --instance.endpoint=&quot;&quot; \\ --instance.templateId=&quot;rate-limit&quot; \\ --instance.parameters.rateLimit.maxRequests=100 \\ --instance.parameters.rateLimit.timeWindow=&quot;1h&quot; \\ --instance.parameters.rateLimit.entity=&quot;userId&quot; \\ --instance.parameters.rateLimit.scope=&quot;global&quot; Checking Access Control​ # Check if request is allowed (call from your service) oo post /policy-svc/check \\ --endpoint=&quot;/user-svc/register&quot; \\ --method=&quot;POST&quot; \\ --ip=&quot;192.168.1.10&quot; \\ --userId=&quot;usr_12345&quot; # Response: {&quot;allowed&quot;: true} or {&quot;allowed&quot;: false} Policy Management​ # Update existing policy (same endpoint, overwrites) oo put /policy-svc/instance/registration-rate-limit \\ --instance.endpoint=&quot;/user-svc/register&quot; \\ --instance.templateId=&quot;rate-limit&quot; \\ --instance.parameters.rateLimit.maxRequests=10 \\ --instance.parameters.rateLimit.timeWindow=&quot;1d&quot; \\ --instance.parameters.rateLimit.entity=&quot;ip&quot; \\ --instance.parameters.rateLimit.scope=&quot;endpoint&quot; # Multiple policies can apply to the same endpoint oo put /policy-svc/instance/registration-user-rate-limit \\ --instance.endpoint=&quot;/user-svc/register&quot; \\ --instance.templateId=&quot;rate-limit&quot; \\ --instance.parameters.rateLimit.maxRequests=3 \\ --instance.parameters.rateLimit.timeWindow=&quot;1h&quot; \\ --instance.parameters.rateLimit.entity=&quot;userId&quot; \\ --instance.parameters.rateLimit.scope=&quot;endpoint&quot; Policy Templates​ Rate Limit Template​ The Rate Limit template provides flexible request throttling: { &quot;templateId&quot;: &quot;rate-limit&quot;, &quot;parameters&quot;: { &quot;rateLimit&quot;: { &quot;maxRequests&quot;: 10, &quot;timeWindow&quot;: &quot;1m&quot;, &quot;entity&quot;: &quot;ip&quot;, &quot;scope&quot;: &quot;endpoint&quot; } } } Parameters: maxRequests: Maximum number of requests allowedtimeWindow: Time period for the limit (e.g., &quot;30s&quot;, &quot;5m&quot;, &quot;1h&quot;, &quot;24h&quot;, &quot;7d&quot;)entity: Who to track (&quot;ip&quot;, &quot;userId&quot;)scope: Where to apply (&quot;endpoint&quot;, &quot;global&quot;) Time Window Formats: &quot;30s&quot; # 30 seconds &quot;5m&quot; # 5 minutes &quot;1h&quot; # 1 hour &quot;24h&quot; # 24 hours &quot;7d&quot; # 7 days &quot;168h&quot; # 1 week (alternative) Entity Types: &quot;ip&quot;: Rate limit by client IP address&quot;userId&quot;: Rate limit by authenticated user ID Scope Types: &quot;endpoint&quot;: Limit applies only to the specified endpoint&quot;global&quot;: Limit applies across all endpoints for the entity Blocklist Template​ The Blocklist template provides IP-based access control: { &quot;templateId&quot;: &quot;blocklist&quot;, &quot;parameters&quot;: { &quot;blocklist&quot;: { &quot;blockedIPs&quot;: [&quot;192.168.1.100&quot;, &quot;10.0.0.50&quot;, &quot;203.0.113.0&quot;] } } } Parameters: blockedIPs: Array of IP addresses to block Service Integration Patterns​ Explicit Policy Checking​ Unlike middleware-based solutions, Policy Svc requires explicit integration: // In your service endpoint func (s *MyService) CreatePost(w http.ResponseWriter, r *http.Request) { // Extract request context userID := getUserID(r) clientIP := getClientIP(r) // Check policy checkRsp, _, err := s.client.PolicySvcAPI.Check(r.Context()). Body(openapi.PolicySvcCheckRequest{ Endpoint: &quot;/posts-svc/post&quot;, Method: &quot;POST&quot;, Ip: clientIP, UserId: userID, }).Execute() if err != nil { http.Error(w, &quot;Policy check failed&quot;, 500) return } if !checkRsp.Allowed { http.Error(w, &quot;Rate limit exceeded&quot;, 429) return } // Proceed with business logic s.createPost(r) } CLI-Based Integration​ # In a shell script or CLI-based service USER_ID=&quot;usr_12345&quot; CLIENT_IP=&quot;192.168.1.10&quot; ALLOWED=$(oo post /policy-svc/check \\ --endpoint=&quot;/api/data/upload&quot; \\ --method=&quot;POST&quot; \\ --ip=&quot;$CLIENT_IP&quot; \\ --userId=&quot;$USER_ID&quot; | jq -r '.allowed') if [ &quot;$ALLOWED&quot; = &quot;true&quot; ]; then echo &quot;Processing request...&quot; # Handle the request else echo &quot;Request blocked by policy&quot; exit 1 fi Real-World Usage Examples​ 1. User Registration Protection​ # Prevent registration abuse: 3 registrations per IP per day oo put /policy-svc/instance/registration-ip-limit \\ --instance.endpoint=&quot;/user-svc/register&quot; \\ --instance.templateId=&quot;rate-limit&quot; \\ --instance.parameters.rateLimit.maxRequests=3 \\ --instance.parameters.rateLimit.timeWindow=&quot;24h&quot; \\ --instance.parameters.rateLimit.entity=&quot;ip&quot; \\ --instance.parameters.rateLimit.scope=&quot;endpoint&quot; # Also limit per user: 1 registration per user per hour (prevent multiple accounts) oo put /policy-svc/instance/registration-user-limit \\ --instance.endpoint=&quot;/user-svc/register&quot; \\ --instance.templateId=&quot;rate-limit&quot; \\ --instance.parameters.rateLimit.maxRequests=1 \\ --instance.parameters.rateLimit.timeWindow=&quot;1h&quot; \\ --instance.parameters.rateLimit.entity=&quot;userId&quot; \\ --instance.parameters.rateLimit.scope=&quot;endpoint&quot; # Test the policy oo post /policy-svc/check \\ --endpoint=&quot;/user-svc/register&quot; \\ --method=&quot;POST&quot; \\ --ip=&quot;192.168.1.10&quot; \\ --userId=&quot;usr_test&quot; 2. API Rate Limiting​ # General API rate limiting: 1000 requests per user per hour oo put /policy-svc/instance/api-rate-limit \\ --instance.endpoint=&quot;&quot; \\ --instance.templateId=&quot;rate-limit&quot; \\ --instance.parameters.rateLimit.maxRequests=1000 \\ --instance.parameters.rateLimit.timeWindow=&quot;1h&quot; \\ --instance.parameters.rateLimit.entity=&quot;userId&quot; \\ --instance.parameters.rateLimit.scope=&quot;global&quot; # Expensive operations: 10 AI prompts per user per hour oo put /policy-svc/instance/prompt-rate-limit \\ --instance.endpoint=&quot;/prompt-svc/prompt&quot; \\ --instance.templateId=&quot;rate-limit&quot; \\ --instance.parameters.rateLimit.maxRequests=10 \\ --instance.parameters.rateLimit.timeWindow=&quot;1h&quot; \\ --instance.parameters.rateLimit.entity=&quot;userId&quot; \\ --instance.parameters.rateLimit.scope=&quot;endpoint&quot; # File uploads: 5 uploads per user per 10 minutes oo put /policy-svc/instance/upload-rate-limit \\ --instance.endpoint=&quot;/file-svc/upload&quot; \\ --instance.templateId=&quot;rate-limit&quot; \\ --instance.parameters.rateLimit.maxRequests=5 \\ --instance.parameters.rateLimit.timeWindow=&quot;10m&quot; \\ --instance.parameters.rateLimit.entity=&quot;userId&quot; \\ --instance.parameters.rateLimit.scope=&quot;endpoint&quot; 3. DDoS Protection​ # Aggressive rate limiting for login attempts oo put /policy-svc/instance/login-ip-protection \\ --instance.endpoint=&quot;/user-svc/login&quot; \\ --instance.templateId=&quot;rate-limit&quot; \\ --instance.parameters.rateLimit.maxRequests=5 \\ --instance.parameters.rateLimit.timeWindow=&quot;5m&quot; \\ --instance.parameters.rateLimit.entity=&quot;ip&quot; \\ --instance.parameters.rateLimit.scope=&quot;endpoint&quot; # Block known malicious IPs oo put /policy-svc/instance/malicious-ip-blocklist \\ --instance.endpoint=&quot;&quot; \\ --instance.templateId=&quot;blocklist&quot; \\ --instance.parameters.blocklist.blockedIPs='[&quot;185.220.101.0&quot;, &quot;185.220.102.0&quot;, &quot;tor-exit-node-1.com&quot;]' # Emergency rate limiting during attack oo put /policy-svc/instance/emergency-rate-limit \\ --instance.endpoint=&quot;&quot; \\ --instance.templateId=&quot;rate-limit&quot; \\ --instance.parameters.rateLimit.maxRequests=10 \\ --instance.parameters.rateLimit.timeWindow=&quot;1m&quot; \\ --instance.parameters.rateLimit.entity=&quot;ip&quot; \\ --instance.parameters.rateLimit.scope=&quot;global&quot; 4. Fair Resource Usage​ # Chat service: 50 messages per user per hour oo put /policy-svc/instance/chat-rate-limit \\ --instance.endpoint=&quot;/chat-svc/thread/*/message&quot; \\ --instance.templateId=&quot;rate-limit&quot; \\ --instance.parameters.rateLimit.maxRequests=50 \\ --instance.parameters.rateLimit.timeWindow=&quot;1h&quot; \\ --instance.parameters.rateLimit.entity=&quot;userId&quot; \\ --instance.parameters.rateLimit.scope=&quot;endpoint&quot; # Data service: 100 object creations per user per day oo put /policy-svc/instance/data-creation-limit \\ --instance.endpoint=&quot;/data-svc/object&quot; \\ --instance.templateId=&quot;rate-limit&quot; \\ --instance.parameters.rateLimit.maxRequests=100 \\ --instance.parameters.rateLimit.timeWindow=&quot;24h&quot; \\ --instance.parameters.rateLimit.entity=&quot;userId&quot; \\ --instance.parameters.rateLimit.scope=&quot;endpoint&quot; # Model usage: 20 model starts per user per day (expensive operation) oo put /policy-svc/instance/model-start-limit \\ --instance.endpoint=&quot;/model-svc/model/*/start&quot; \\ --instance.templateId=&quot;rate-limit&quot; \\ --instance.parameters.rateLimit.maxRequests=20 \\ --instance.parameters.rateLimit.timeWindow=&quot;24h&quot; \\ --instance.parameters.rateLimit.entity=&quot;userId&quot; \\ --instance.parameters.rateLimit.scope=&quot;endpoint&quot; 5. Abuse Prevention​ # Prevent password reset abuse: 3 attempts per IP per hour oo put /policy-svc/instance/password-reset-limit \\ --instance.endpoint=&quot;/user-svc/password-reset&quot; \\ --instance.templateId=&quot;rate-limit&quot; \\ --instance.parameters.rateLimit.maxRequests=3 \\ --instance.parameters.rateLimit.timeWindow=&quot;1h&quot; \\ --instance.parameters.rateLimit.entity=&quot;ip&quot; \\ --instance.parameters.rateLimit.scope=&quot;endpoint&quot; # Email verification: 5 requests per user per day oo put /policy-svc/instance/email-verification-limit \\ --instance.endpoint=&quot;/user-svc/verify-email&quot; \\ --instance.templateId=&quot;rate-limit&quot; \\ --instance.parameters.rateLimit.maxRequests=5 \\ --instance.parameters.rateLimit.timeWindow=&quot;24h&quot; \\ --instance.parameters.rateLimit.entity=&quot;userId&quot; \\ --instance.parameters.rateLimit.scope=&quot;endpoint&quot; # Account creation from specific regions (compliance) oo put /policy-svc/instance/region-blocklist \\ --instance.endpoint=&quot;/user-svc/register&quot; \\ --instance.templateId=&quot;blocklist&quot; \\ --instance.parameters.blocklist.blockedIPs='[&quot;192.0.2.0&quot;, &quot;203.0.113.0&quot;]' 6. Service-Specific Policies​ # Container service: Limit container launches oo put /policy-svc/instance/container-launch-limit \\ --instance.endpoint=&quot;/container-svc/container&quot; \\ --instance.templateId=&quot;rate-limit&quot; \\ --instance.parameters.rateLimit.maxRequests=10 \\ --instance.parameters.rateLimit.timeWindow=&quot;1h&quot; \\ --instance.parameters.rateLimit.entity=&quot;userId&quot; \\ --instance.parameters.rateLimit.scope=&quot;endpoint&quot; # Image generation: Expensive AI operations oo put /policy-svc/instance/image-generation-limit \\ --instance.endpoint=&quot;/prompt-svc/prompt&quot; \\ --instance.templateId=&quot;rate-limit&quot; \\ --instance.parameters.rateLimit.maxRequests=5 \\ --instance.parameters.rateLimit.timeWindow=&quot;1h&quot; \\ --instance.parameters.rateLimit.entity=&quot;userId&quot; \\ --instance.parameters.rateLimit.scope=&quot;endpoint&quot; # Secret management: Sensitive operations oo put /policy-svc/instance/secret-access-limit \\ --instance.endpoint=&quot;/secret-svc/secret&quot; \\ --instance.templateId=&quot;rate-limit&quot; \\ --instance.parameters.rateLimit.maxRequests=50 \\ --instance.parameters.rateLimit.timeWindow=&quot;1h&quot; \\ --instance.parameters.rateLimit.entity=&quot;userId&quot; \\ --instance.parameters.rateLimit.scope=&quot;endpoint&quot; Policy Patterns &amp; Best Practices​ Layered Protection Strategy​ # Layer 1: Global IP-based protection (very permissive) oo put /policy-svc/instance/global-ip-protection \\ --instance.endpoint=&quot;&quot; \\ --instance.templateId=&quot;rate-limit&quot; \\ --instance.parameters.rateLimit.maxRequests=1000 \\ --instance.parameters.rateLimit.timeWindow=&quot;1m&quot; \\ --instance.parameters.rateLimit.entity=&quot;ip&quot; \\ --instance.parameters.rateLimit.scope=&quot;global&quot; # Layer 2: Endpoint-specific limits (moderate) oo put /policy-svc/instance/api-endpoint-limit \\ --instance.endpoint=&quot;/api/v1/data&quot; \\ --instance.templateId=&quot;rate-limit&quot; \\ --instance.parameters.rateLimit.maxRequests=100 \\ --instance.parameters.rateLimit.timeWindow=&quot;1m&quot; \\ --instance.parameters.rateLimit.entity=&quot;ip&quot; \\ --instance.parameters.rateLimit.scope=&quot;endpoint&quot; # Layer 3: User-based fair usage (strict) oo put /policy-svc/instance/user-fair-usage \\ --instance.endpoint=&quot;/api/v1/data&quot; \\ --instance.templateId=&quot;rate-limit&quot; \\ --instance.parameters.rateLimit.maxRequests=50 \\ --instance.parameters.rateLimit.timeWindow=&quot;1m&quot; \\ --instance.parameters.rateLimit.entity=&quot;userId&quot; \\ --instance.parameters.rateLimit.scope=&quot;endpoint&quot; Time Window Strategies​ # Burst protection: Short-term limits oo put /policy-svc/instance/burst-protection \\ --instance.endpoint=&quot;/api/search&quot; \\ --instance.templateId=&quot;rate-limit&quot; \\ --instance.parameters.rateLimit.maxRequests=10 \\ --instance.parameters.rateLimit.timeWindow=&quot;30s&quot; \\ --instance.parameters.rateLimit.entity=&quot;ip&quot; \\ --instance.parameters.rateLimit.scope=&quot;endpoint&quot; # Sustained usage: Medium-term limits oo put /policy-svc/instance/sustained-usage \\ --instance.endpoint=&quot;/api/search&quot; \\ --instance.templateId=&quot;rate-limit&quot; \\ --instance.parameters.rateLimit.maxRequests=100 \\ --instance.parameters.rateLimit.timeWindow=&quot;10m&quot; \\ --instance.parameters.rateLimit.entity=&quot;userId&quot; \\ --instance.parameters.rateLimit.scope=&quot;endpoint&quot; # Daily quotas: Long-term limits oo put /policy-svc/instance/daily-quota \\ --instance.endpoint=&quot;/api/search&quot; \\ --instance.templateId=&quot;rate-limit&quot; \\ --instance.parameters.rateLimit.maxRequests=1000 \\ --instance.parameters.rateLimit.timeWindow=&quot;24h&quot; \\ --instance.parameters.rateLimit.entity=&quot;userId&quot; \\ --instance.parameters.rateLimit.scope=&quot;endpoint&quot; Monitoring &amp; Observability​ Policy Effectiveness Testing​ # Test rate limit behavior test_rate_limit() { local endpoint=$1 local max_requests=$2 echo &quot;Testing rate limit for $endpoint (max: $max_requests)&quot; for i in $(seq 1 $((max_requests + 2))); do result=$(oo post /policy-svc/check \\ --endpoint=&quot;$endpoint&quot; \\ --method=&quot;POST&quot; \\ --ip=&quot;192.168.1.10&quot; \\ --userId=&quot;test_user&quot; | jq -r '.allowed') echo &quot;Request $i: $result&quot; done } # Test registration endpoint test_rate_limit &quot;/user-svc/register&quot; 5 Policy Audit Commands​ # Check policy coverage for critical endpoints critical_endpoints=( &quot;/user-svc/register&quot; &quot;/user-svc/login&quot; &quot;/prompt-svc/prompt&quot; &quot;/file-svc/upload&quot; &quot;/container-svc/container&quot; ) for endpoint in &quot;${critical_endpoints[@]}&quot;; do echo &quot;Testing policy for $endpoint&quot; oo post /policy-svc/check \\ --endpoint=&quot;$endpoint&quot; \\ --method=&quot;POST&quot; \\ --ip=&quot;192.168.1.10&quot; \\ --userId=&quot;audit_user&quot; done Load Testing Integration​ # Use with load testing tools load_test_with_policy() { local endpoint=$1 local concurrent_users=$2 # Pre-check policy status oo post /policy-svc/check \\ --endpoint=&quot;$endpoint&quot; \\ --method=&quot;POST&quot; \\ --ip=&quot;192.168.1.10&quot; \\ --userId=&quot;load_test_user&quot; # Run load test (example with curl) for i in $(seq 1 $concurrent_users); do curl -X POST &quot;$endpoint&quot; \\ -H &quot;Authorization: Bearer $TOKEN&quot; \\ -H &quot;X-Forwarded-For: 192.168.1.$i&quot; &amp; done wait } Policy Response Handling​ Service Implementation Patterns​ # Standard response handling in services handle_policy_check() { local endpoint=$1 local user_id=$2 local client_ip=$3 response=$(oo post /policy-svc/check \\ --endpoint=&quot;$endpoint&quot; \\ --method=&quot;POST&quot; \\ --ip=&quot;$client_ip&quot; \\ --userId=&quot;$user_id&quot;) allowed=$(echo &quot;$response&quot; | jq -r '.allowed') if [ &quot;$allowed&quot; = &quot;true&quot; ]; then return 0 # Allow request else echo &quot;HTTP/1.1 429 Too Many Requests&quot; echo &quot;Content-Type: application/json&quot; echo &quot;&quot; echo '{&quot;error&quot;:&quot;Rate limit exceeded&quot;,&quot;retryAfter&quot;:&quot;60&quot;}' return 1 # Block request fi } # Usage in endpoint handler if handle_policy_check &quot;/api/data/create&quot; &quot;$USER_ID&quot; &quot;$CLIENT_IP&quot;; then # Process the request echo &quot;Processing request...&quot; else # Request was blocked exit 1 fi HTTP Status Code Standards​ # Proper HTTP responses for policy violations # Rate limiting echo &quot;HTTP/1.1 429 Too Many Requests&quot; echo &quot;Retry-After: 60&quot; echo &quot;X-RateLimit-Limit: 100&quot; echo &quot;X-RateLimit-Remaining: 0&quot; echo &quot;X-RateLimit-Reset: 1640995200&quot; # IP blocking echo &quot;HTTP/1.1 403 Forbidden&quot; echo &quot;Content-Type: application/json&quot; echo '{&quot;error&quot;:&quot;Access denied from this IP address&quot;}' # General policy violation echo &quot;HTTP/1.1 403 Forbidden&quot; echo &quot;Content-Type: application/json&quot; echo '{&quot;error&quot;:&quot;Request blocked by security policy&quot;}' Advanced Configuration​ Dynamic Policy Updates​ # Update policy during high load (emergency response) oo put /policy-svc/instance/emergency-login-limit \\ --instance.endpoint=&quot;/user-svc/login&quot; \\ --instance.templateId=&quot;rate-limit&quot; \\ --instance.parameters.rateLimit.maxRequests=1 \\ --instance.parameters.rateLimit.timeWindow=&quot;5m&quot; \\ --instance.parameters.rateLimit.entity=&quot;ip&quot; \\ --instance.parameters.rateLimit.scope=&quot;endpoint&quot; # Relax policies during maintenance oo put /policy-svc/instance/maintenance-mode \\ --instance.endpoint=&quot;/user-svc/login&quot; \\ --instance.templateId=&quot;rate-limit&quot; \\ --instance.parameters.rateLimit.maxRequests=50 \\ --instance.parameters.rateLimit.timeWindow=&quot;1m&quot; \\ --instance.parameters.rateLimit.entity=&quot;ip&quot; \\ --instance.parameters.rateLimit.scope=&quot;endpoint&quot; # Remove emergency restrictions oo put /policy-svc/instance/normal-login-limit \\ --instance.endpoint=&quot;/user-svc/login&quot; \\ --instance.templateId=&quot;rate-limit&quot; \\ --instance.parameters.rateLimit.maxRequests=10 \\ --instance.parameters.rateLimit.timeWindow=&quot;1m&quot; \\ --instance.parameters.rateLimit.entity=&quot;ip&quot; \\ --instance.parameters.rateLimit.scope=&quot;endpoint&quot; Conditional Policies​ # Different limits for different user types (implemented in service logic) check_policy_with_user_tier() { local user_id=$1 local endpoint=$2 local client_ip=$3 # Get user tier from user service user_tier=$(oo get /user-svc/user/$user_id | jq -r '.user.tier') case $user_tier in &quot;premium&quot;) instance_id=&quot;premium-user-limit&quot; ;; &quot;basic&quot;) instance_id=&quot;basic-user-limit&quot; ;; *) instance_id=&quot;default-user-limit&quot; ;; esac # Check appropriate policy oo post /policy-svc/check \\ --endpoint=&quot;$endpoint&quot; \\ --method=&quot;POST&quot; \\ --ip=&quot;$client_ip&quot; \\ --userId=&quot;$user_id&quot; } Troubleshooting​ Common Issues​ Policy Not Applying​ # Check if policy instance exists oo put /policy-svc/instance/test-policy \\ --instance.endpoint=&quot;/test-endpoint&quot; \\ --instance.templateId=&quot;rate-limit&quot; \\ --instance.parameters.rateLimit.maxRequests=1 \\ --instance.parameters.rateLimit.timeWindow=&quot;1m&quot; \\ --instance.parameters.rateLimit.entity=&quot;ip&quot; \\ --instance.parameters.rateLimit.scope=&quot;endpoint&quot; # Test the policy immediately oo post /policy-svc/check \\ --endpoint=&quot;/test-endpoint&quot; \\ --method=&quot;POST&quot; \\ --ip=&quot;192.168.1.10&quot; \\ --userId=&quot;test_user&quot; Rate Limits Too Restrictive​ # Check current rate limit status oo post /policy-svc/check \\ --endpoint=&quot;/api/problematic-endpoint&quot; \\ --method=&quot;POST&quot; \\ --ip=&quot;192.168.1.10&quot; \\ --userId=&quot;affected_user&quot; # Temporarily increase limits oo put /policy-svc/instance/temporary-increase \\ --instance.endpoint=&quot;/api/problematic-endpoint&quot; \\ --instance.templateId=&quot;rate-limit&quot; \\ --instance.parameters.rateLimit.maxRequests=100 \\ --instance.parameters.rateLimit.timeWindow=&quot;1m&quot; \\ --instance.parameters.rateLimit.entity=&quot;userId&quot; \\ --instance.parameters.rateLimit.scope=&quot;endpoint&quot; Blocked IPs​ # Check if IP is in blocklist oo post /policy-svc/check \\ --endpoint=&quot;/any-endpoint&quot; \\ --method=&quot;GET&quot; \\ --ip=&quot;SUSPECTED_IP&quot; \\ --userId=&quot;any_user&quot; # Update blocklist to remove IP oo put /policy-svc/instance/ip-blocklist \\ --instance.endpoint=&quot;&quot; \\ --instance.templateId=&quot;blocklist&quot; \\ --instance.parameters.blocklist.blockedIPs='[&quot;192.168.1.100&quot;]' # Removed the IP Policy Conflicts​ # Multiple policies can apply to the same endpoint # They are evaluated in sequence - if ANY policy blocks, request is denied # Example: Both IP and user rate limits apply oo put /policy-svc/instance/endpoint-ip-limit \\ --instance.endpoint=&quot;/api/data&quot; \\ --instance.templateId=&quot;rate-limit&quot; \\ --instance.parameters.rateLimit.maxRequests=100 \\ --instance.parameters.rateLimit.timeWindow=&quot;1m&quot; \\ --instance.parameters.rateLimit.entity=&quot;ip&quot; \\ --instance.parameters.rateLimit.scope=&quot;endpoint&quot; oo put /policy-svc/instance/endpoint-user-limit \\ --instance.endpoint=&quot;/api/data&quot; \\ --instance.templateId=&quot;rate-limit&quot; \\ --instance.parameters.rateLimit.maxRequests=50 \\ --instance.parameters.rateLimit.timeWindow=&quot;1m&quot; \\ --instance.parameters.rateLimit.entity=&quot;userId&quot; \\ --instance.parameters.rateLimit.scope=&quot;endpoint&quot; Debug Commands​ # Test policy behavior with different parameters debug_policy() { local endpoint=$1 local user_id=$2 local ip=$3 echo &quot;=== Policy Debug for $endpoint ===&quot; echo &quot;User: $user_id, IP: $ip&quot; response=$(oo post /policy-svc/check \\ --endpoint=&quot;$endpoint&quot; \\ --method=&quot;POST&quot; \\ --ip=&quot;$ip&quot; \\ --userId=&quot;$user_id&quot;) echo &quot;Response: $response&quot; allowed=$(echo &quot;$response&quot; | jq -r '.allowed') if [ &quot;$allowed&quot; = &quot;true&quot; ]; then echo &quot;✅ Request ALLOWED&quot; else echo &quot;❌ Request BLOCKED&quot; fi } # Usage debug_policy &quot;/user-svc/login&quot; &quot;usr_test&quot; &quot;192.168.1.10&quot; Security Considerations​ Policy Security Best Practices​ # 1. Protect admin endpoints aggressively oo put /policy-svc/instance/admin-protection \\ --instance.endpoint=&quot;/admin/*&quot; \\ --instance.templateId=&quot;rate-limit&quot; \\ --instance.parameters.rateLimit.maxRequests=5 \\ --instance.parameters.rateLimit.timeWindow=&quot;1h&quot; \\ --instance.parameters.rateLimit.entity=&quot;ip&quot; \\ --instance.parameters.rateLimit.scope=&quot;endpoint&quot; # 2. Layer multiple protection mechanisms oo put /policy-svc/instance/login-ip-limit \\ --instance.endpoint=&quot;/user-svc/login&quot; \\ --instance.templateId=&quot;rate-limit&quot; \\ --instance.parameters.rateLimit.maxRequests=5 \\ --instance.parameters.rateLimit.timeWindow=&quot;5m&quot; \\ --instance.parameters.rateLimit.entity=&quot;ip&quot; \\ --instance.parameters.rateLimit.scope=&quot;endpoint&quot; oo put /policy-svc/instance/login-user-limit \\ --instance.endpoint=&quot;/user-svc/login&quot; \\ --instance.templateId=&quot;rate-limit&quot; \\ --instance.parameters.rateLimit.maxRequests=3 \\ --instance.parameters.rateLimit.timeWindow=&quot;5m&quot; \\ --instance.parameters.rateLimit.entity=&quot;userId&quot; \\ --instance.parameters.rateLimit.scope=&quot;endpoint&quot; # 3. Block known malicious IP ranges oo put /policy-svc/instance/tor-blocklist \\ --instance.endpoint=&quot;&quot; \\ --instance.templateId=&quot;blocklist&quot; \\ --instance.parameters.blocklist.blockedIPs='[&quot;185.220.101.0&quot;, &quot;185.220.102.0&quot;]' Incident Response​ # Emergency lockdown procedure emergency_lockdown() { echo &quot;🚨 Implementing emergency lockdown...&quot; # Severely restrict all endpoints oo put /policy-svc/instance/emergency-global-limit \\ --instance.endpoint=&quot;&quot; \\ --instance.templateId=&quot;rate-limit&quot; \\ --instance.parameters.rateLimit.maxRequests=1 \\ --instance.parameters.rateLimit.timeWindow=&quot;1m&quot; \\ --instance.parameters.rateLimit.entity=&quot;ip&quot; \\ --instance.parameters.rateLimit.scope=&quot;global&quot; echo &quot;✅ Emergency lockdown active&quot; } # Gradual recovery procedure gradual_recovery() { echo &quot;🔄 Starting gradual recovery...&quot; # Increase limits gradually oo put /policy-svc/instance/recovery-phase-1 \\ --instance.endpoint=&quot;&quot; \\ --instance.templateId=&quot;rate-limit&quot; \\ --instance.parameters.rateLimit.maxRequests=10 \\ --instance.parameters.rateLimit.timeWindow=&quot;1m&quot; \\ --instance.parameters.rateLimit.entity=&quot;ip&quot; \\ --instance.parameters.rateLimit.scope=&quot;global&quot; sleep 300 # Wait 5 minutes oo put /policy-svc/instance/recovery-phase-2 \\ --instance.endpoint=&quot;&quot; \\ --instance.templateId=&quot;rate-limit&quot; \\ --instance.parameters.rateLimit.maxRequests=50 \\ --instance.parameters.rateLimit.timeWindow=&quot;1m&quot; \\ --instance.parameters.rateLimit.entity=&quot;ip&quot; \\ --instance.parameters.rateLimit.scope=&quot;global&quot; echo &quot;✅ Recovery phase 2 complete&quot; } API Reference Summary​ Endpoint\tMethod\tPurpose/policy-svc/instance/{instanceId}\tPUT\tCreate or update policy instance /policy-svc/check\tPOST\tCheck if request is allowed by policies Permissions &amp; Security​ # Admin permissions (required for policy management) policy-svc:instance:create # Create policy instances policy-svc:instance:edit # Modify policy instances policy-svc:instance:delete # Remove policy instances policy-svc:template:view # View policy templates # User permissions (for policy checking) policy-svc:check:view # Check policies (typically granted to services) Related Services​ User Svc: User authentication and registration protectionFile Svc: Upload rate limiting and abuse preventionPrompt Svc: AI usage rate limiting and fair accessContainer Svc: Resource-intensive operation limiting Future Enhancements​ Planned Features​ Geographic Blocking: Block requests from specific countries/regionsUser Behavior Analysis: Dynamic rate limiting based on user patternsCustom Templates: User-defined policy templatesPolicy Analytics: Detailed reporting on policy effectivenessWhitelist Support: Allow-lists for trusted IPs/users Integration Roadmap​ Automatic Detection: AI-powered abuse detection and policy adjustmentExternal Feeds: Integration with threat intelligence feedsCircuit Breakers: Automatic service protection during overloadPolicy Scheduling: Time-based policy activation/deactivationMulti-Factor Policies: Complex policies combining multiple conditions Policy Svc provides the essential protection layer for 1Backend services, ensuring system reliability, fair resource usage, and protection against abuse through flexible, configurable policies.","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Prompt Svc","type":0,"sectionRef":"#","url":"/docs/built-in-services/prompt-svc","content":"Prompt Svc The Prompt Svc is a resilient AI orchestration service that provides a unified interface for interacting with Large Language Models (LLMs) and other AI systems through a queue-based architecture with real-time streaming capabilities. This page provides a comprehensive overview of Prompt Svc. For detailed API information, refer to the Prompt Svc API documentation. Architecture &amp; Purpose​ Prompt Svc serves as the AI interaction layer for 1Backend, providing: Unified Interface: Single API for all AI model interactions (text, image, audio)Queue Management: Resilient processing with automatic retries and exponential backoffReal-Time Streaming: Live response streaming via Server-Sent Events (SSE)Multi-Modal Support: Text-to-text, text-to-image, image-to-image, and morePlatform Abstraction: Support for different AI engines (LlamaCpp, Stable Diffusion)Integration Layer: Seamless connection with Chat Svc and Model Svc Key Features​ Asynchronous Processing: Queue-based prompt handling with status trackingSynchronous Mode: Blocking calls for scripting and simple integrationsStreaming Responses: Real-time output streaming for progressive resultsRetry Logic: Automatic retry with exponential backoff for failed promptsTemplate System: Flexible prompt templates for different model formatsMulti-Platform: Engine-agnostic and engine-specific parameter support CLI Usage​ Prompt Svc provides both synchronous and asynchronous interaction modes: Text Generation (Synchronous)​ # Simple text generation with default model oo post /prompt-svc/prompt \\ --prompt=&quot;Explain quantum computing in simple terms&quot; \\ --sync=true # With specific model oo post /prompt-svc/prompt \\ --prompt=&quot;Write a Python function to calculate Fibonacci numbers&quot; \\ --modelId=&quot;huggingface/TheBloke/codellama-7b.Q4_K_M.gguf&quot; \\ --sync=true # Using high-level parameters oo post /prompt-svc/prompt \\ --prompt=&quot;Hello, how are you?&quot; \\ --parameters.textToText.template=&quot;[INST] {prompt} [/INST]&quot; \\ --sync=true # Using engine-specific parameters oo post /prompt-svc/prompt \\ --prompt=&quot;What is the meaning of life?&quot; \\ --engineParameters.llamaCpp.template=&quot;### HUMAN:\\n{prompt}\\n\\n### RESPONSE:\\n&quot; \\ --sync=true Text Generation (Asynchronous with Streaming)​ # Submit prompt to queue oo post /prompt-svc/prompt \\ --prompt=&quot;Write a detailed essay about artificial intelligence&quot; \\ --threadId=&quot;thread_12345&quot; \\ --sync=false # Subscribe to streaming responses (in another terminal) curl -N -H &quot;Authorization: Bearer $TOKEN&quot; \\ &quot;http://localhost:11337/prompt-svc/prompts/thread_12345/responses/subscribe&quot; # Or using Server-Sent Events in JavaScript # const eventSource = new EventSource('/prompt-svc/prompts/thread_12345/responses/subscribe'); Image Generation​ # Text-to-image with Stable Diffusion oo post /prompt-svc/prompt \\ --prompt=&quot;A serene mountain landscape at sunset, digital art&quot; \\ --parameters.textToImage.width=512 \\ --parameters.textToImage.height=512 \\ --parameters.textToImage.steps=20 \\ --sync=true # Using Stable Diffusion engine parameters oo post /prompt-svc/prompt \\ --prompt=&quot;A futuristic city with flying cars&quot; \\ --engineParameters.stableDiffusion.txt2Img.width=768 \\ --engineParameters.stableDiffusion.txt2Img.height=768 \\ --engineParameters.stableDiffusion.txt2Img.num_inference_steps=30 \\ --sync=true Advanced Configuration​ # With retry configuration and thread management oo post /prompt-svc/prompt \\ --prompt=&quot;Analyze this business case and provide recommendations&quot; \\ --threadId=&quot;business_analysis_001&quot; \\ --maxRetries=5 \\ --modelId=&quot;huggingface/TheBloke/mistral-7b-instruct-v0.2.Q4_K_M.gguf&quot; \\ --sync=false # Custom prompt ID (for idempotency) oo post /prompt-svc/prompt \\ --id=&quot;prom_custom_12345&quot; \\ --prompt=&quot;Generate a summary of the latest AI research&quot; \\ --threadId=&quot;ai_research_summary&quot; \\ --sync=true Prompt Management​ # List active prompts oo post /prompt-svc/prompts # List prompts with specific status oo post /prompt-svc/prompts \\ --query.filters='[{&quot;field&quot;: &quot;status&quot;, &quot;operator&quot;: &quot;equals&quot;, &quot;value&quot;: &quot;running&quot;}]' # Remove a prompt from queue oo delete /prompt-svc/prompt/prom_12345 # List prompts for specific thread oo post /prompt-svc/prompts \\ --query.filters='[{&quot;field&quot;: &quot;threadId&quot;, &quot;operator&quot;: &quot;equals&quot;, &quot;value&quot;: &quot;thread_12345&quot;}]' Prompt Types &amp; Capabilities​ Text Generation Types​ # General text-to-text Type: &quot;Text-to-Text&quot; Use: General language tasks, conversations, analysis # Question answering Type: &quot;Question Answering&quot; Use: Specific questions with factual answers # Translation Type: &quot;Translation&quot; Use: Language translation tasks # Summarization Type: &quot;Summarization&quot; Use: Text summarization and condensation # Text generation Type: &quot;Text Generation&quot; Use: Creative writing, code generation Image Generation Types​ # Text-to-image Type: &quot;Text-to-Image&quot; Use: Generate images from text descriptions # Image-to-image Type: &quot;Image-to-Image&quot; Use: Transform existing images based on prompts # Unconditional image generation Type: &quot;Unconditional Image Generation&quot; Use: Generate random images without prompts Multimodal Types​ # Image-text-to-text Type: &quot;Image-Text-to-Text&quot; Use: Analyze images with text context # Visual question answering Type: &quot;Visual Question Answering&quot; Use: Answer questions about images # Document question answering Type: &quot;Document Question Answering&quot; Use: Extract information from document images Queue Architecture &amp; Processing​ Queue Flow​ Queue Management​ # Monitor queue status oo post /prompt-svc/prompts \\ --query.filters='[{&quot;field&quot;: &quot;status&quot;, &quot;operator&quot;: &quot;in&quot;, &quot;value&quot;: [&quot;scheduled&quot;, &quot;running&quot;]}]' # Check retry behavior oo post /prompt-svc/prompts \\ --query.filters='[{&quot;field&quot;: &quot;status&quot;, &quot;operator&quot;: &quot;equals&quot;, &quot;value&quot;: &quot;errored&quot;}]' # Performance monitoring oo post /prompt-svc/prompts \\ --query.orderBy='[{&quot;field&quot;: &quot;createdAt&quot;, &quot;desc&quot;: true}]' \\ --query.limit=10 Queue Status Values: scheduled: Waiting in queue for processingrunning: Currently being processed by AI enginecompleted: Successfully finishederrored: Failed but will be retriedabandoned: Failed after max retriescanceled: Manually canceled Retry Logic​ Prompts that fail are automatically retried with exponential backoff: # Configure retry behavior oo post /prompt-svc/prompt \\ --prompt=&quot;Complex analysis task&quot; \\ --maxRetries=5 \\ --sync=false # Default retry strategy: # Attempt 1: Immediate # Attempt 2: 2 seconds delay # Attempt 3: 4 seconds delay # Attempt 4: 8 seconds delay # Attempt 5: 16 seconds delay Streaming &amp; Real-Time Responses​ Server-Sent Events (SSE)​ # Subscribe to thread streaming curl -N -H &quot;Authorization: Bearer $TOKEN&quot; \\ &quot;http://localhost:11337/prompt-svc/prompts/thread_12345/responses/subscribe&quot; Stream Event Types: // Progress chunk (partial response) { &quot;text&quot;: &quot;Quantum computing is a revolutionary&quot;, &quot;type&quot;: &quot;progress&quot; } // Done chunk (completion) { &quot;text&quot;: &quot; technology that uses quantum mechanics.&quot;, &quot;messageId&quot;: &quot;msg_abc123&quot;, &quot;type&quot;: &quot;done&quot; } JavaScript Integration​ // Real-time streaming in web applications const eventSource = new EventSource( '/prompt-svc/prompts/thread_12345/responses/subscribe', { headers: { 'Authorization': 'Bearer ' + token } } ); eventSource.onmessage = function(event) { const chunk = JSON.parse(event.data); if (chunk.type === 'progress') { // Append text to UI appendToOutput(chunk.text); } else if (chunk.type === 'done') { // Response complete finalizeOutput(chunk.messageId); } }; Stream Management​ # Pre-subscribe to threads (before prompt submission) curl -N -H &quot;Authorization: Bearer $TOKEN&quot; \\ &quot;http://localhost:11337/prompt-svc/prompts/future_thread/responses/subscribe&quot; &amp; # Then submit prompt to that thread oo post /prompt-svc/prompt \\ --prompt=&quot;Generate a story&quot; \\ --threadId=&quot;future_thread&quot; \\ --sync=false Parameter Systems​ High-Level Parameters​ Use these when you don't care about the specific AI engine: # Text-to-text parameters oo post /prompt-svc/prompt \\ --prompt=&quot;Hello world&quot; \\ --parameters.textToText.template=&quot;[INST] {prompt} [/INST]&quot; # Text-to-image parameters oo post /prompt-svc/prompt \\ --prompt=&quot;A beautiful sunset&quot; \\ --parameters.textToImage.width=512 \\ --parameters.textToImage.height=512 \\ --parameters.textToImage.steps=20 \\ --parameters.textToImage.guidanceScale=7.5 Engine-Specific Parameters​ Use these for fine-tuned control over specific AI engines: # LlamaCpp engine parameters oo post /prompt-svc/prompt \\ --prompt=&quot;What is AI?&quot; \\ --engineParameters.llamaCpp.template=&quot;### HUMAN:\\n{prompt}\\n\\n### RESPONSE:\\n&quot; # Stable Diffusion engine parameters oo post /prompt-svc/prompt \\ --prompt=&quot;A spaceship&quot; \\ --engineParameters.stableDiffusion.txt2Img.width=768 \\ --engineParameters.stableDiffusion.txt2Img.height=768 \\ --engineParameters.stableDiffusion.txt2Img.num_inference_steps=30 \\ --engineParameters.stableDiffusion.txt2Img.guidance_scale=8.0 \\ --engineParameters.stableDiffusion.txt2Img.negative_prompt=&quot;blurry, low quality&quot; Real-World Usage Examples​ 1. Interactive Chatbot​ # Start chat session THREAD_ID=&quot;chat_session_$(date +%s)&quot; # Set up streaming in background curl -N -H &quot;Authorization: Bearer $TOKEN&quot; \\ &quot;http://localhost:11337/prompt-svc/prompts/$THREAD_ID/responses/subscribe&quot; &amp; # Send messages oo post /prompt-svc/prompt \\ --prompt=&quot;Hello! I need help with Python programming.&quot; \\ --threadId=&quot;$THREAD_ID&quot; \\ --sync=false oo post /prompt-svc/prompt \\ --prompt=&quot;How do I create a simple web server?&quot; \\ --threadId=&quot;$THREAD_ID&quot; \\ --sync=false 2. Code Generation Pipeline​ # Use CodeLlama for programming tasks CODE_MODEL=&quot;huggingface/TheBloke/codellama-7b.Q4_K_M.gguf&quot; # Generate function oo post /prompt-svc/prompt \\ --prompt=&quot;Write a Python function that calculates the factorial of a number&quot; \\ --modelId=&quot;$CODE_MODEL&quot; \\ --sync=true # Generate tests oo post /prompt-svc/prompt \\ --prompt=&quot;Write unit tests for the factorial function above&quot; \\ --modelId=&quot;$CODE_MODEL&quot; \\ --threadId=&quot;code_generation_session&quot; \\ --sync=true # Generate documentation oo post /prompt-svc/prompt \\ --prompt=&quot;Write docstring documentation for the factorial function&quot; \\ --modelId=&quot;$CODE_MODEL&quot; \\ --threadId=&quot;code_generation_session&quot; \\ --sync=true 3. Content Creation Workflow​ # Research phase oo post /prompt-svc/prompt \\ --prompt=&quot;Research the latest trends in renewable energy technology&quot; \\ --threadId=&quot;content_creation_001&quot; \\ --sync=false # Writing phase oo post /prompt-svc/prompt \\ --prompt=&quot;Write a 500-word article about solar panel efficiency improvements&quot; \\ --threadId=&quot;content_creation_001&quot; \\ --maxRetries=3 \\ --sync=false # Image generation for article oo post /prompt-svc/prompt \\ --prompt=&quot;Solar panels on a modern house roof, bright sunny day, professional photography&quot; \\ --parameters.textToImage.width=1024 \\ --parameters.textToImage.height=768 \\ --threadId=&quot;content_creation_001&quot; \\ --sync=false 4. Document Analysis System​ # Analyze uploaded documents ANALYSIS_THREAD=&quot;doc_analysis_$(date +%s)&quot; # Set up streaming for real-time results curl -N -H &quot;Authorization: Bearer $TOKEN&quot; \\ &quot;http://localhost:11337/prompt-svc/prompts/$ANALYSIS_THREAD/responses/subscribe&quot; &gt; analysis_output.txt &amp; # Submit analysis prompts oo post /prompt-svc/prompt \\ --prompt=&quot;Summarize the key points in this financial report&quot; \\ --threadId=&quot;$ANALYSIS_THREAD&quot; \\ --sync=false oo post /prompt-svc/prompt \\ --prompt=&quot;Extract all financial figures and create a table&quot; \\ --threadId=&quot;$ANALYSIS_THREAD&quot; \\ --sync=false oo post /prompt-svc/prompt \\ --prompt=&quot;Identify potential risks mentioned in the document&quot; \\ --threadId=&quot;$ANALYSIS_THREAD&quot; \\ --sync=false 5. Creative AI Assistant​ # Story generation with multiple prompts STORY_THREAD=&quot;creative_story_$(date +%s)&quot; # Character development oo post /prompt-svc/prompt \\ --prompt=&quot;Create a detailed character profile for a space explorer&quot; \\ --threadId=&quot;$STORY_THREAD&quot; \\ --sync=false # Plot outline oo post /prompt-svc/prompt \\ --prompt=&quot;Create a plot outline for a science fiction adventure&quot; \\ --threadId=&quot;$STORY_THREAD&quot; \\ --sync=false # Generate artwork oo post /prompt-svc/prompt \\ --prompt=&quot;Space explorer in futuristic suit standing on alien planet, concept art style&quot; \\ --parameters.textToImage.width=768 \\ --parameters.textToImage.height=1024 \\ --threadId=&quot;$STORY_THREAD&quot; \\ --sync=false 6. Batch Processing System​ # Process multiple prompts with queue management BATCH_THREAD=&quot;batch_processing_$(date +%s)&quot; # Submit batch of prompts prompts=( &quot;Analyze customer sentiment in this review: 'Great product, fast delivery'&quot; &quot;Translate to Spanish: 'Welcome to our customer support'&quot; &quot;Summarize: 'The quarterly earnings report shows...'&quot; &quot;Generate email template for customer onboarding&quot; ) for i in &quot;${!prompts[@]}&quot;; do oo post /prompt-svc/prompt \\ --id=&quot;batch_item_$i&quot; \\ --prompt=&quot;${prompts[$i]}&quot; \\ --threadId=&quot;$BATCH_THREAD&quot; \\ --maxRetries=2 \\ --sync=false echo &quot;Submitted batch item $i&quot; done # Monitor batch progress watch -n 5 &quot;oo post /prompt-svc/prompts --query.filters='[{\\&quot;field\\&quot;: \\&quot;threadId\\&quot;, \\&quot;operator\\&quot;: \\&quot;equals\\&quot;, \\&quot;value\\&quot;: \\&quot;$BATCH_THREAD\\&quot;}]' | jq '.prompts[] | {id, status}'&quot; Integration Patterns​ Chat Svc Integration​ Prompt Svc automatically integrates with Chat Svc: # Create chat thread CHAT_THREAD=$(oo post /chat-svc/thread \\ --threadData.title=&quot;AI Assistant Chat&quot; | jq -r '.thread.id') # Send prompt (automatically creates chat messages) oo post /prompt-svc/prompt \\ --prompt=&quot;Hello! Can you help me learn Python?&quot; \\ --threadId=&quot;$CHAT_THREAD&quot; \\ --sync=false # View chat history oo post /chat-svc/thread/$CHAT_THREAD/messages Model Svc Integration​ Automatic model management and status checking: # Check model status before prompting oo get /model-svc/default-model/status # Use specific model (Prompt Svc handles model communication) oo post /prompt-svc/prompt \\ --prompt=&quot;Generate code documentation&quot; \\ --modelId=&quot;huggingface/TheBloke/codellama-7b.Q4_K_M.gguf&quot; \\ --sync=true # Fallback to default model if modelId not specified oo post /prompt-svc/prompt \\ --prompt=&quot;What's the weather like?&quot; \\ --sync=true File Svc Integration​ # Upload image for analysis FILE_ID=$(curl -X PUT &quot;http://localhost:11337/file-svc/upload&quot; \\ -H &quot;Authorization: Bearer $TOKEN&quot; \\ -F &quot;file=@./image.jpg&quot; | jq -r '.upload.fileId') # Analyze uploaded image (future feature) oo post /prompt-svc/prompt \\ --prompt=&quot;Describe what you see in this image&quot; \\ --fileIds='[&quot;'$FILE_ID'&quot;]' \\ --sync=true Performance Optimization​ Synchronous vs Asynchronous​ # Use sync=true for: # - Simple scripts # - Testing and development # - Short responses oo post /prompt-svc/prompt \\ --prompt=&quot;What is 2+2?&quot; \\ --sync=true # Use sync=false for: # - Long-running tasks # - Web applications # - Batch processing oo post /prompt-svc/prompt \\ --prompt=&quot;Write a detailed research paper on quantum computing&quot; \\ --threadId=&quot;research_paper_001&quot; \\ --sync=false Queue Optimization​ # Monitor queue depth oo post /prompt-svc/prompts \\ --query.filters='[{&quot;field&quot;: &quot;status&quot;, &quot;operator&quot;: &quot;equals&quot;, &quot;value&quot;: &quot;scheduled&quot;}]' \\ --query.count=true | jq '.count' # Prioritize urgent prompts (submit to dedicated threads) oo post /prompt-svc/prompt \\ --prompt=&quot;URGENT: System security analysis needed&quot; \\ --threadId=&quot;priority_processing&quot; \\ --sync=false # Batch similar prompts for efficiency BATCH_THREAD=&quot;text_analysis_batch&quot; for text in &quot;text1&quot; &quot;text2&quot; &quot;text3&quot;; do oo post /prompt-svc/prompt \\ --prompt=&quot;Analyze sentiment: $text&quot; \\ --threadId=&quot;$BATCH_THREAD&quot; \\ --sync=false done Model Selection​ # Use lightweight models for simple tasks oo post /prompt-svc/prompt \\ --prompt=&quot;Hello, how are you?&quot; \\ --modelId=&quot;huggingface/TheBloke/tinyllama-1.1b-chat-v1.0.Q4_K_S.gguf&quot; \\ --sync=true # Use powerful models for complex tasks oo post /prompt-svc/prompt \\ --prompt=&quot;Analyze this complex business scenario and provide strategic recommendations&quot; \\ --modelId=&quot;huggingface/TheBloke/mistral-7b-instruct-v0.2.Q5_K_M.gguf&quot; \\ --sync=false Monitoring &amp; Observability​ Queue Status Monitoring​ # Real-time queue monitoring monitor_queue() { while true; do echo &quot;=== Queue Status $(date) ===&quot; # Count by status for status in &quot;scheduled&quot; &quot;running&quot; &quot;completed&quot; &quot;errored&quot;; do count=$(oo post /prompt-svc/prompts \\ --query.filters='[{&quot;field&quot;: &quot;status&quot;, &quot;operator&quot;: &quot;equals&quot;, &quot;value&quot;: &quot;'$status'&quot;}]' \\ --query.count=true | jq '.count') echo &quot;$status: $count&quot; done echo &quot;---&quot; sleep 10 done } monitor_queue Performance Analytics​ # Response time analysis oo post /prompt-svc/prompts \\ --query.filters='[{&quot;field&quot;: &quot;status&quot;, &quot;operator&quot;: &quot;equals&quot;, &quot;value&quot;: &quot;completed&quot;}]' \\ --query.orderBy='[{&quot;field&quot;: &quot;createdAt&quot;, &quot;desc&quot;: true}]' \\ --query.limit=10 | jq '.prompts[] | {id, created: .createdAt, lastRun: .lastRun, runCount}' # Error analysis oo post /prompt-svc/prompts \\ --query.filters='[{&quot;field&quot;: &quot;status&quot;, &quot;operator&quot;: &quot;in&quot;, &quot;value&quot;: [&quot;errored&quot;, &quot;abandoned&quot;]}]' | \\ jq '.prompts[] | {id, error, runCount, status}' # Thread activity oo post /prompt-svc/prompts \\ --query.orderBy='[{&quot;field&quot;: &quot;createdAt&quot;, &quot;desc&quot;: true}]' \\ --query.limit=20 | jq '.prompts | group_by(.threadId) | map({thread: .[0].threadId, count: length})' Health Checking​ # Test basic functionality test_prompt_health() { echo &quot;Testing Prompt Svc health...&quot; # Submit test prompt response=$(oo post /prompt-svc/prompt \\ --prompt=&quot;Test prompt for health check&quot; \\ --sync=true) if echo &quot;$response&quot; | jq -e '.prompt.id' &gt; /dev/null; then echo &quot;✅ Prompt Svc is healthy&quot; else echo &quot;❌ Prompt Svc health check failed&quot; echo &quot;$response&quot; fi } test_prompt_health Troubleshooting​ Common Issues​ Prompts Stuck in Queue​ # Check queue status oo post /prompt-svc/prompts \\ --query.filters='[{&quot;field&quot;: &quot;status&quot;, &quot;operator&quot;: &quot;equals&quot;, &quot;value&quot;: &quot;scheduled&quot;}]' # Check model status oo get /model-svc/default-model/status # Restart processing by canceling and resubmitting oo delete /prompt-svc/prompt/STUCK_PROMPT_ID Streaming Not Working​ # Test SSE connection curl -v -N -H &quot;Authorization: Bearer $TOKEN&quot; \\ &quot;http://localhost:11337/prompt-svc/prompts/test_thread/responses/subscribe&quot; # Check firewall/proxy settings # Ensure Server-Sent Events are not blocked High Retry Counts​ # Identify problematic prompts oo post /prompt-svc/prompts \\ --query.filters='[{&quot;field&quot;: &quot;runCount&quot;, &quot;operator&quot;: &quot;gt&quot;, &quot;value&quot;: 3}]' # Check model errors oo post /prompt-svc/prompts \\ --query.filters='[{&quot;field&quot;: &quot;status&quot;, &quot;operator&quot;: &quot;equals&quot;, &quot;value&quot;: &quot;errored&quot;}]' | \\ jq '.prompts[] | {id, error, runCount}' # Verify model is responding curl http://localhost:8001/health Memory/Performance Issues​ # Monitor queue depth QUEUE_SIZE=$(oo post /prompt-svc/prompts \\ --query.filters='[{&quot;field&quot;: &quot;status&quot;, &quot;operator&quot;: &quot;in&quot;, &quot;value&quot;: [&quot;scheduled&quot;, &quot;running&quot;]}]' \\ --query.count=true | jq '.count') echo &quot;Queue depth: $QUEUE_SIZE&quot; # Clear completed prompts (if needed) # Note: This is manual - no automated cleanup yet Debug Commands​ # Detailed prompt inspection debug_prompt() { local prompt_id=$1 echo &quot;=== Debug Prompt: $prompt_id ===&quot; oo post /prompt-svc/prompts \\ --query.filters='[{&quot;field&quot;: &quot;id&quot;, &quot;operator&quot;: &quot;equals&quot;, &quot;value&quot;: &quot;'$prompt_id'&quot;}]' | \\ jq '.prompts[0] | { id, status, prompt, threadId, modelId, runCount, error, createdAt, lastRun }' } # Usage debug_prompt &quot;prom_12345&quot; # Stream testing test_streaming() { local thread_id=&quot;test_stream_$(date +%s)&quot; echo &quot;Testing streaming for thread: $thread_id&quot; # Start streaming in background curl -N -H &quot;Authorization: Bearer $TOKEN&quot; \\ &quot;http://localhost:11337/prompt-svc/prompts/$thread_id/responses/subscribe&quot; &amp; local curl_pid=$! # Submit test prompt oo post /prompt-svc/prompt \\ --prompt=&quot;Count from 1 to 5&quot; \\ --threadId=&quot;$thread_id&quot; \\ --sync=false # Wait and cleanup sleep 10 kill $curl_pid 2&gt;/dev/null } test_streaming Template System​ Prompt Templates​ Different models require different prompt formats: # Mistral format oo post /prompt-svc/prompt \\ --prompt=&quot;What is machine learning?&quot; \\ --parameters.textToText.template=&quot;[INST] {prompt} [/INST]&quot; # Llama2 format oo post /prompt-svc/prompt \\ --prompt=&quot;Explain neural networks&quot; \\ --parameters.textToText.template=&quot;### HUMAN:\\n{prompt}\\n\\n### RESPONSE:\\n&quot; # TinyLlama format oo post /prompt-svc/prompt \\ --prompt=&quot;Hello world&quot; \\ --parameters.textToText.template=&quot;&lt;|system|&gt;\\nYou are a helpful assistant.&lt;/s&gt;\\n&lt;|user|&gt;\\n{prompt}&lt;/s&gt;\\n&lt;|assistant|&gt;&quot; # Auto-detection (uses model's default template) oo post /prompt-svc/prompt \\ --prompt=&quot;Default template test&quot; \\ --modelId=&quot;huggingface/TheBloke/mistral-7b-instruct-v0.2.Q4_K_M.gguf&quot; Template Variables​ # Custom template with system message oo post /prompt-svc/prompt \\ --prompt=&quot;Write code comments&quot; \\ --parameters.textToText.template=&quot;&lt;|system|&gt;\\nYou are a code documentation expert.&lt;/s&gt;\\n&lt;|user|&gt;\\n{prompt}&lt;/s&gt;\\n&lt;|assistant|&gt;&quot; # Multi-variable templates (future feature) # template: &quot;Context: {context}\\nQuestion: {prompt}\\nAnswer:&quot; API Reference Summary​ Endpoint\tMethod\tPurpose/prompt-svc/prompt\tPOST\tSubmit prompt for processing /prompt-svc/prompts\tPOST\tList prompts with filtering /prompt-svc/prompt/{promptId}\tDELETE\tRemove prompt from queue /prompt-svc/prompts/{threadId}/responses/subscribe\tGET\tSubscribe to streaming responses /prompt-svc/types\tPOST\tGet type definitions (for API docs) Permissions &amp; Security​ # Required permissions prompt-svc:prompt:create # Submit prompts prompt-svc:prompt:view # List and view prompts prompt-svc:prompt:stream # Subscribe to streaming responses prompt-svc:prompt:delete # Remove prompts from queue # Privacy protection # Users can only see their own prompts (prompt text hidden for others) Related Services​ Model Svc: AI model management and statusChat Svc: Conversation threading and message storageFile Svc: File attachments and image inputs (future)Policy Svc: Rate limiting AI usage Future Enhancements​ Planned Features​ Multi-Model Orchestration: Automatic model selection based on prompt typeModel Auto-Scaling: Start/stop models based on queue depthFile Input Support: Image/document analysis with file uploadsPrompt Chaining: Connect multiple prompts in workflowsCustom Templates: User-defined prompt templates Integration Roadmap​ Voice Integration: Audio-to-text and text-to-speech capabilitiesVisual Processing: Advanced image analysis and generationWorkflow Engine: Complex multi-step AI workflowsA/B Testing: Compare different models/prompts for same taskAnalytics Dashboard: Detailed usage and performance metrics Prompt Svc provides the essential AI interaction layer for 1Backend, enabling everything from simple chatbots to complex AI workflows with real-time streaming and robust queue management.","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"User Svc","type":0,"sectionRef":"#","url":"/docs/built-in-services/user-svc","content":"User Svc The user service is at the heart of 1Backend, managing users, tokens, organizations, permissions and more. Each service and human on an 1Backend network has an account in the User Svc. This page provides a high-level overview of User Svc. For detailed information, refer to the User Svc API documentation. User Svc supports multitenancy: while users are shared globally, tokens, organizations, permits, enrollments, and memberships are isolated by an &quot;app&quot; field (see Apps section on this page). This approach allows a single 1Backend instance to securely support multiple web applications. Note: Not all services included with 1Backend may support multitenancy. Please refer to the documentation for details and look for the tag multitenant. Glossary​ Token: A JWT (JSON Web Token) issued and signed by the User Svc, used to authenticate both human and service accounts. Role: A simple string identifier like user-svc:user or user-svc:org:{orgId}:admin that represents a specific capability or access level. Roles are embedded in tokens. Enroll: (Enrollment) A mechanism to assign roles to users—both current and future. Enrolls allow roles to be claimed later, once the user joins or logs in. Permission: A string such as petstore-svc:read, typically mapping to an API action or endpoint. Roles can bundle multiple permissions. Permit: A mechanism for assigning permissions to users or roles. Permits define who can access what by connecting users or roles with specific permissions. Organization: A way for users to freely associate with each other. Anyone can create organizations and grant membership to others to their organization. Membership: A formal record that links a user to an organization. Memberships determine which organizations a user belongs to and enable organization-scoped roles to take effect. Overview​ The most important thing about the User Svc is that service (machine) and user (human) accounts look and function the same. Every service you write needs to register at startup, or log in with the credentials it saves and manages if it's already registered. Just like a human. A service account is not an admin account, it's a simple user level account. You might wonder how service-to-service calls work then. The answer is permits. Permits​ Most endpoints on 1Backend can only be called by administrators by default. Let's take prompting. If you want to let your users prompt AIs you might write a wrapper service called User Prompter Svc with the slug user-prompter-svc. If we look at the Add Prompt endpoint API docs, we can see that it mentions Requires the `prompt-svc:prompt:create` permission. To enable your service to call the Add Prompt endpoint, we need to create a permit with your service slug and the permission mentioned above: id: &quot;user-prompter-permit&quot; permission: &quot;prompt-svc:prompt:create&quot; slugs: - &quot;user-prompter-svc&quot; You can apply these permits with an administrator account in your CI workflow with the oo CLI: oo permit save user-prompter-permit.yaml Auth patterns​ Role-based access​ Role-Only Checks: Authorize users based solely on their assigned roles. This is the simplest method—no need to check individual permissions. Permission-based access​ API Permission Check: Use the Has Permission endpoint with the user's authentication headers and a permission ID to verify access dynamically. This endpoint is designed to be easy to cache (it has no other params apart from the caller header and a permission). Permission-based checks offer more nuanced control than simple role-only checks—permits can grant specific permissions to slugs, roles and more. If you are looking at restricting access to endpoints in other ways, you might be interested in: Policy Svc. Tokens​ The User Svc produces a JWT (JSON Web Token) upon /user-svc/login in the token.token field (see the response documentation). You can either use this token as a proper JWT - parse it and inspect the contents, or you can just use the token to read the user account that belongs to the token with the /user-svc/self endpoint. Verifying a token​ The /user-svc/public-key will return you the public key of the User Svc which then you can use that to verify the token. Use the JWT libraries that are available in your programming language to do that, or use the Singularon SDK if your language is supported. Automatic token refresh​ 1Backend tokens are valid for a limited time (see OB_TOKEN_EXPIRATION). Once a token expires, 1Backend can either automatically refresh it (this is the default behaviour) or reject it based on configuration (see OB_TOKEN_AUTO_REFRESH_OFF). If automatic token refresh is disabled, clients are responsible for detecting expiration and refreshing the token themselves. If automatic refresh is enabled, expired tokens can still be reused indefinitely. Behind the scenes, 1Backend maps old tokens to their most recent valid version. Example flow​ To understand how automatic token refresh works in practice, consider the following scenario: A user acquires a token.The token is valid for X minutes.After expiration, Service A receives a request with the old token.Service A then has two options: Call the User Svc RefreshToken endpoint on every request to get a new token — which undermines the stateless nature of JWTs.Cache the refreshed token and continue accepting the expired one, internally mapping it to the latest valid token without calling 1Backend. When the refreshed token expires, this process repeats. Token Pruning​ You might wonder: if an old token keeps getting refreshed indefinitely, does that mean a new token is minted every OB_TOKEN_EXPIRATION interval — and do they pile up forever? While a new token is issued on each refresh, the system keeps track of which tokens are actively being refreshed and discards the rest. At any given time, a maximum of three tokens per device (see the device field in the token) are retained: The currently active tokenThe two most recently refreshed tokens (kept as a buffer to handle clock drift or retries) All other older tokens are pruned to avoid unbounded growth. Token structure​ The structure of the JWT is the following: # User Id oui: usr_dC4K75Cbp6 # Slug osl: test-user-slug-0 # Roles oro: - user-svc:user - user-svc:org:{org_dC4K7NNDCG}:user The field names are kept short to save space, so perhaps the Go definition is also educational: type Claims struct { UserId string `json:&quot;oui&quot;` // `oui`: 1backend user ids Slug string `json:&quot;osl&quot;` // `osl`: 1backend slug Roles []string `json:&quot;oro&quot;` // `oro`: 1backend roles jwt.RegisteredClaims } Roles​ Roles are simply strings. They are not a database record, they don't have an ID, name etc. They are simple strings, such as user-svc:admin. # Roles are not a database entity. A user token produced upon login contains all the roles a user has. Efficiency Tip: JWT tokens are sent with every request. Keeping the number of roles minimal improves performance. When checking if a user is authorized, there are a few common patterns to choose from: Roles without permissions​ Roles are powerful, even without specific permissions attached. One common use case is managing product subscriptions. Suppose you launch a new product called Funny Cats Newsletter with two subscription tiers: Pro and Ultra. You could create a service with the slug funny-cats-newsletter-svc and define custom static roles for each tier: funny-cats-newsletter-svc:pro funny-cats-newsletter-svc:ultra By checking if these roles exist in a user's token, you can authorize access to product-specific features. These roles can be created dynamically by calling the Create Role endpoint. Roles containing dynamic data​ You are free to make up your own roles which might even have dynamic data, just like the User Svc did with the organization ids. Example: user-svc:org:{org_dBZRCej3fo}:admin user-svc:org:{org_dBZRCej3fo}:user By convention these dynamic values are enclosed in {}. In this example, roles are assigned per organization. For more details, see the Organizations section. Owning roles vs. just having them​ When managing roles in 1Backend (especially through actions like SaveEnrolls), it's important to understand a key distinction: Just because you have a role doesn’t mean you can assign that role to others. For example, if an admin gives you the role user-svc:org:acme:user, that doesn’t mean you can turn around and give it to someone else. Only certain users or services can assign roles—they need to own them. What does it mean to own a role?​ A user (or service) owns a role if either of the following is true: ✅ 1. You created it (slug-based ownership)​ If a role starts with your slug, you automatically own it. Example: If your slug is funny-cats-svc, then you own roles like: funny-cats-svc:profunny-cats-svc:ultrafunny-cats-svc:admin These roles are yours — you can assign them, modify them, or revoke them. ✅ 2. You’re an admin of that role family​ If you hold a role like user-svc:org:{org_id}:admin, then you also own other roles that share the same prefix. Example: If you have: user-svc:org:org_xyz123:admin Then you also own: user-svc:org:org_xyz123:useruser-svc:org:org_xyz123:viewer That means you're authorized to assign those roles to others. Why role ownership matters​ This ownership rule prevents privilege escalation. Without this rule, anyone with a role could assign it to others — even roles they shouldn’t control. Enforcing ownership ensures only trusted users or services can delegate access. Enrolls​ Enrollments are a flexible way to assign roles to users, whether they already exist in the system or will be joining later. They enable role pre-assignment, which means users receive roles as soon as they register or log in, based on matching criteria like email. # Enrollment through contact ID id: &quot;admin-enrollment-1&quot; # Enrollment through contact ID # # `app` defines the scope in which the enrollment applies. # - A concrete app (e.g. &quot;shoes.com&quot;) means the role is only assigned in that app’s tenant. # - The special value &quot;*&quot; means the enrollment applies to **all apps** in the instance. # # ⚠️ Note: Using &quot;*&quot; is powerful but should be reserved for global roles # (e.g. &quot;user-svc:admin&quot;). In multitenant setups, this means the role # will show up in every user token across all apps. appHost: &quot;*&quot; role: &quot;user-svc:admin&quot; contactId: &quot;admin@company.com&quot; # Enrollment through user ID # IMPORTANT: `id` must be globally unique across ALL apps (not just within one app). # Prefer an explicit prefix tied to the app to avoid collisions in IaC workflows. # Example canonical form: &quot;&lt;app&gt;-&lt;purpose&gt;-enrollment&quot; # # Note: The system does not automatically enforce this naming convention, # but a save will fail if the same id is already bound to another app. id: &quot;shoes.com-payment-processor-enrollment&quot; appHost: &quot;shoes.com&quot; role: &quot;payment-svc:processor&quot; userId: &quot;usr_abc123&quot; For CLI usage see this section. Organizations​ Organizations provide a way for users to group together and collaborate. Think of them as user-defined domains of trust—similar to GitHub organizations, Slack workspaces, or Discord servers. They enable structured permissioning and scoped roles within a 1Backend application. # organization.yaml id: &quot;org_eZqC0BbdG2&quot; app: &quot;shoes.com&quot; name: &quot;Acme Corporation&quot; # Full name of the organization slug: &quot;acme-corporation&quot; # URL-friendly unique identifier for the organization createdAt: &quot;2025-01-15T12:00:00Z&quot; # Example ISO 8601 timestamp Organizations and apps​ Organizations belong to a specific app. Even if the same user is part of multiple apps, their roles and memberships in one app don’t carry over to another. This ensures that each app has its own separate set of organizations, users, and permissions—cleanly isolated and secure. +-------------------+ | User Svc | | (Shared Users) | +---------+---------+ | +-----------------------+----------------------+ | | +------+-------+ +-------+------+ | App A | | App B | | (socks.com) | | (shoes.com) | +------+--------+ +-------+------+ | | +----------+----------+ +------------+-----------+ | | | | +-------+-------+ +-------+-------+ +-------+--------+ +--------+-------+ | Org A1 | | Org A2 | | Org B1 | | Org B2 | +-------+-------+ +-------+-------+ +--------+--------+ +--------+-------+ Notes: All users are stored centrally in User Svc, but each App provides isolated &quot;worlds&quot;.Each App contains independent Organizations, Memberships, and Roles.A User can belong to multiple Apps and Organizations.Authentication logic respect app boundaries via the app field in the token. Access rules​ Create​ Any logged in user can create an organization, provided the Organization slug is not taken yet. The creator becomes the first admin of the organization, acquiring the role of user-svc:org:{orgId}:admin role. Membership​ A membership is a formal link between a user and an organization. It determines what organizations a user belongs to and enables organization-scoped roles to take effect (such as user-svc:org:{orgId}:user or user-svc:org:{orgId}:admin). Similarly how Enrolls add roles to users, memberships add organization roles to users. Memberships are created by the SaveMembership endpoint. # membership.yaml id: &quot;mem_123456789&quot; app: &quot;shoes.com&quot; createdAt: &quot;2025-08-16T12:34:56Z&quot; updatedAt: &quot;2025-08-16T12:45:30Z&quot; deletedAt: null organizationId: &quot;org_987654321&quot; userId: &quot;user_1122334455&quot; # Marks the user's default organization # - Only one membership per user can be active # - Stored in JWT under key `oao` active: true Permissions​ A permission is a simple string that represents a specific capability or access right within your service—e.g., petstore-svc:pet:create, payment-svc:process, or chat-svc:message:read. Permissions are purely convention-based and aren't backed by a database entity. They are just strings—but they become powerful when combined with permits. # Permissions are not a standalone database entity, # they are produced by Permits. Permissions typically correspond to protected API actions. They're meant to be human-readable and composable. Permissions alone don’t do anything. To make a permission meaningful, you must grant it to someone—either a user or a role. This is done by creating a Permit. Permits are the glue between permissions, roles, and service slugs. Permission access rules​ Each permission created must by prefixed by the slug of the account that created it. Said account becomes the owner of the permission and only that account can add the permission to a role. Once you (your service) own a permission (by creating it, and it being prefixed by your account slug), you can add it to any role, not just roles owned by you. Permission examples​ Permission\tPurposepetstore-svc:pet:read\tView pet data petstore-svc:pet:create\tAdd new pets petstore-svc:pet:delete\tRemove pets from the system petstore-svc:appointment:book\tBook appointments for pets petstore-svc:appointment:cancel\tCancel appointments Services with multiple nodes​ You might now wonder what happens when a service has multiple instances/nodes. Won't their user accounts &quot;clash&quot; in the User Svc? The answer to this is that from the User Svc point of view, each node/instance of a service is the same account. This is possible because the platform is designed with services having a &quot;Shared Database Access&quot;. Let's say you have a Cassandra network that spans multiple Availability Zones/Regions. Your nodes will also span multiple AZs/Regions and each instance of them will log in as X Svc. Apps​ Apps are the foundation of multitenancy in 1Backend. They act as namespaces that allow you to serve multiple clients, projects, or websites using the same set of microservices. It’s recommended to use the website's hostname (e.g., socks.com, shoes.com) as the app name. This helps clearly separate environments while remaining easy to manage. The current app is typically inferred from the authentication token. For public endpoints, it’s derived from the request host. As a result, even if a service API doesn’t explicitly mention &quot;App&quot; in its endpoints, it might still support multitenancy. On this documentation page, services marked with the multitenancy tag—such as User Svc, Config Svc, and Secret Svc—support apps. These services provide the essential building blocks for building robust, multi-tenant applications. CLI Reference​ Quick Start​ # Register a new user oo register alice Enter password: [hidden] # Login with existing credentials oo login alice Enter password: [hidden] # Check current authentication status oo whoami # View authentication token oo token # Switch between users (if multiple logged in) oo use bob Authentication Commands​ oo register - Create New Accounts​ Usage: oo register [slug] [password] # or oo register [slug] Enter password: [hidden] oo register [--contact-id email] [--contact-platform email] Examples: # Interactive registration (secure - no terminal history) oo register alice Enter password: [hidden] # User with contact information oo register john-doe --contact-id john@company.com --contact-platform email # Direct registration (automation only - avoid for security) oo register test-user test-password oo login - Authenticate​ Usage: oo login [slug] [password] Examples: # Interactive login (recommended) oo login alice Enter password: [hidden] # Quick development login (avoid in production) oo login dev-user dev-password oo whoami - Identity Information​ Usage: oo whoami [--all] Examples: # Current user information oo whoami # All logged in users oo whoami --all # Example output: # id: usr_abc123 # slug: alice # roles: # - user-svc:user # - user-svc:org:org_xyz789:admin # - payment-svc:processor oo use - Switch User Context​ Examples: # Switch to different authenticated user oo use payment-svc oo use alice oo use admin-user # Verify switch oo whoami oo token - Access Tokens​ # Get current authentication token oo token # Use in API calls curl -H &quot;Authorization: Bearer $(oo token)&quot; \\ https://api.1backend.com/user-svc/self User Management Commands​ oo user list - Browse Users​ Usage: oo user list [--userId id] [--contactId email] [--limit count] Examples: # List all users (admin required) oo user list # Find specific user oo user list --userId usr_abc123 # Find by email oo user list --contactId alice@company.com # Paginated results oo user list --limit 50 Permission Management​ oo permit save - Grant Permissions​ Usage: oo permit save &lt;permit-file.yaml&gt; oo permit save &lt;permits-directory&gt; Single Permit Example: # api-access-permit.yaml id: &quot;payment-api-access&quot; permission: &quot;payment-svc:process&quot; slugs: - &quot;order-service&quot; - &quot;subscription-service&quot; roles: - &quot;payment-svc:processor&quot; Multiple Permits Example: # service-permissions.yaml - id: &quot;chat-read-permit&quot; permission: &quot;chat-svc:message:read&quot; slugs: [&quot;frontend-app&quot;, &quot;mobile-app&quot;] - id: &quot;chat-write-permit&quot; permission: &quot;chat-svc:message:create&quot; roles: [&quot;chat-svc:user&quot;] - id: &quot;admin-chat-permit&quot; permission: &quot;chat-svc:admin&quot; roles: [&quot;user-svc:admin&quot;] Apply Permits: # Save single permit oo permit save api-access-permit.yaml # Save multiple permits oo permit save service-permissions.yaml # Save from directory oo permit save permissions/production/ oo permit list - View Permissions​ # List all permits (admin required) oo permit list # Example output: # PERMIT ID PERMISSION SLUGS ROLES # payment-api-access payment-svc:process order-service payment-svc:processor # chat-read-permit chat-svc:message:read frontend-app Enrollment​ oo enroll save - Assign Roles​ Usage: oo enroll save &lt;role&gt; --userId &lt;id&gt; oo enroll save &lt;role&gt; --contactId &lt;email&gt; oo enroll save &lt;enroll-file.yaml&gt; Direct Enrollment: # Enroll user to admin role oo enroll save user-svc:admin --userId usr_abc123 # Enroll by email (future user) oo enroll save payment-svc:processor --contactId alice@company.com # Organization role oo enroll save user-svc:org:org_xyz789:admin --userId usr_def456 File-Based Enrollment: # team-enrollments.yaml - id: &quot;admin-enrollment-1&quot; role: &quot;user-svc:admin&quot; contactId: &quot;admin@company.com&quot; - id: &quot;dev-team-enrollment&quot; role: &quot;dev-team:developer&quot; contactId: &quot;developer@company.com&quot; - id: &quot;payment-processor-enrollment&quot; role: &quot;payment-svc:processor&quot; userId: &quot;usr_abc123&quot; # Apply enrollments oo enroll save team-enrollments.yaml oo enroll list - View Enrollments​ Usage: oo enroll list [--role role] [--userId id] [--contactId email] # Apply service permissions oo permit save payment-service-permissions.yaml ","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Contribute to the Clients","type":0,"sectionRef":"#","url":"/docs/contributing/contributing-to-the-clients","content":"Contribute to the Clients TypeScript/JavaScript Clients​ Without some scripting making sweeping changes in the clients would be hard because of how they depend on each other: js/types (@singulatron/types) is a dependency of js/client (@singulatron/client). To fix this a tiny script link_local.sh was introduced. Your local workflow when editing the @singulatron/types should be is to issue the bash link_local.sh in the clients/js folder. The script links up and builds the packages in the correct order for local testing. Publishing​ Just bump the version number in the package.jsons and the clients will be automatically published when merged to main.","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Contribute to the Docs","type":0,"sectionRef":"#","url":"/docs/contributing/contributing-to-the-docs","content":"Contribute to the Docs Step into the docs-source folder from the repo root and run npm run start to see the Documentation section in live reload mode. However, the API section won't refresh automatically. To change the API, you must edit the Go endpoints and run bash build.sh in the docs-source folder. You can run bash build.sh while npm run start is active for a relatively quick feedback loop.","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Command line basics","type":0,"sectionRef":"#","url":"/docs/command-line/basics","content":"Command line basics CLI installation​ Currently you need Go to install the 1Backend CLI: go install github.com/1backend/1backend/cli/oo@latest CLI usage​ Assuming the daemon is running already (see this section about that), you can interact with it through the CLI. Logging in​ $ oo login 1backend Enter password: $ oo whoami slug: 1backend id: usr_eH9mXKgmb0 roles: - user-svc:admin Environments​ Local​ The local environment is included by default in the env list: $ oo env ls ENV NAME SELECTED URL DESCRIPTION REACHABLE local * http://127.0.0.1:11337 false Custom environments​ Adding your non-local (prod etc.) environment is very easy: $ oo env add prod https://yourdomain.com $ oo env ls ENV NAME SELECTED URL DESCRIPTION REACHABLE local * http://127.0.0.1:11337 false prod https://yourdomain.com true Then you can select your new environment: $ oo env select prod $ oo env ls ENV NAME SELECTED URL DESCRIPTION REACHABLE local http://127.0.0.1:11337 false prod * https://yourdomain.com true Endpoint calls​ Let's make a GET call: $ oo get /secret-svc/is-secure { &quot;isSecure&quot;:false } Or a POST call: $ oo post /user-svc/users { &quot;users&quot;: [ { &quot;id&quot;: &quot;usr_g5WbJXmxuQ&quot;, &quot;createdAt&quot;: &quot;2025-06-05T16:58:15.674576217+02:00&quot;, &quot;updatedAt&quot;: &quot;2025-06-05T16:58:15.674576217+02:00&quot;, &quot;name&quot;: &quot;Admin&quot;, &quot;slug&quot;: &quot;1backend&quot; } ], # Some other fields might be included such as for # pagination or count. } Or a POST call with some request body parameters: $ oo post /secret-svc/encrypt --value=hey { &quot;value&quot;: &quot;UsoGq6VCa0+89pzIPhgU49kgoL0p/3jc90IsOR/8ldk=&quot; } Here we should talk a bit about how CLI flags get mapped to request bodies. CLI flag to request body mapping​ When doing POST, PUT and DELETE queries, CLI flags can be turned into multilevel JSON request bodies, such as this: $ oo post /registry-svc/echo --value=hey Is roughly equivalent to the pseudocurl curl -XPOST -H &quot;Auth...&quot; $ADDR/registry-svc/echo -d '{&quot;value&quot;: &quot;hey&quot;}' Similarly, dot . and dash - delimiters get turned into a multidimensional JSON: $ oo post /registry-svc/echo --value-text=hey # turns into { &quot;value&quot;: { &quot;text&quot;: &quot;hey&quot; } } $ oo post /registry-svc/echo --value.text=hey # turns into { &quot;value&quot;: { &quot;text&quot;: &quot;hey&quot; } } $ oo post /registry-svc/echo --valueText=hey # turns into { &quot;valueText&quot;: &quot;hey&quot; } ","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Registry Svc","type":0,"sectionRef":"#","url":"/docs/built-in-services/registry-svc","content":"Registry Svc The Registry Svc is a comprehensive service discovery and registry system that manages service definitions, running instances, and distributed nodes in a microservices architecture. This page provides a comprehensive overview of Registry Svc. For detailed API information, refer to the Registry Svc API documentation. Architecture &amp; Purpose​ Registry Svc serves as the service discovery backbone for 1Backend, providing: Service Definitions: Template specifications for deployable services (images, repositories, APIs)Instance Management: Registry of running service instances with health trackingNode Discovery: Distributed node topology with resource monitoringService Discovery: Automatic routing and load balancing for microservicesHealth Monitoring: Real-time status tracking with heartbeat mechanisms Core Entities Relationship​ CLI Usage​ Instance Management​ # List all service instances oo instances list oo instances ls oo i ls # Remove a service instance oo instances remove inst_12345 oo instances rm inst_12345 oo i rm inst_12345 Definition Management​ # List all service definitions oo definitions list oo definitions ls oo def ls # Save a definition from YAML file oo definitions save my-service-def.yaml oo def save my-service-def.yaml # Remove a definition oo definitions remove test-service-a oo def rm test-service-a Node Management​ # List all nodes in the cluster oo nodes list oo nodes ls oo n ls # Remove a node from the cluster oo nodes remove http://node2.example.com:11337 oo n rm http://node2.example.com:11337 HTTP API Usage​ # List instances with filtering oo get /registry-svc/instances oo get /registry-svc/instances?slug=user-svc oo get /registry-svc/instances?host=api-server-1 # Register a new service instance oo put /registry-svc/instance \\ --url=&quot;http://user-service:8080&quot; \\ --slug=&quot;user-svc&quot; # List service definitions oo get /registry-svc/definitions # Save a service definition oo put /registry-svc/definition \\ --definition='{&quot;id&quot;: &quot;my-svc&quot;, &quot;image&quot;: {&quot;name&quot;: &quot;nginx:latest&quot;, &quot;internalPorts&quot;: [80]}}' # List nodes oo post /registry-svc/nodes # Get current node information oo get /registry-svc/node/self Service Definitions​ Container-Based Definitions​ Service definitions specify how services can be deployed and what they provide. Simple Container Definition​ # nginx-service.yaml id: &quot;nginx-svc&quot; image: name: &quot;nginx:alpine&quot; internalPorts: [80] ports: - internal: 80 host: 8080 envars: - key: &quot;NGINX_HOST&quot; value: &quot;localhost&quot; - key: &quot;NGINX_PORT&quot; value: &quot;80&quot; Advanced Container Definition​ # api-service.yaml id: &quot;api-svc&quot; image: name: &quot;mycompany/api-server:v1.2.0&quot; internalPorts: [8080, 9090] ports: - internal: 8080 host: 8080 - internal: 9090 host: 9090 envars: - key: &quot;DATABASE_URL&quot; value: &quot;postgresql://localhost:5432/mydb&quot; - key: &quot;REDIS_URL&quot; value: &quot;redis://localhost:6379&quot; - key: &quot;LOG_LEVEL&quot; value: &quot;info&quot; apiSpecs: - url: &quot;http://api-server:8080/openapi.json&quot; protocolType: &quot;OpenAPI&quot; version: &quot;3.0.0&quot; metadata: title: &quot;My API Service&quot; description: &quot;REST API for my application&quot; clients: - language: &quot;javascript&quot; url: &quot;https://npmjs.com/package/my-api-client&quot; - language: &quot;go&quot; url: &quot;https://github.com/mycompany/api-client-go&quot; Repository-Based Definitions​ # source-based-service.yaml id: &quot;custom-app&quot; repository: url: &quot;https://github.com/mycompany/custom-service.git&quot; version: &quot;v2.1.0&quot; buildContext: &quot;backend&quot; containerFile: &quot;docker/Dockerfile.prod&quot; internalPorts: [3000] envars: - key: &quot;NODE_ENV&quot; value: &quot;production&quot; - key: &quot;PORT&quot; value: &quot;3000&quot; apiSpecs: - url: &quot;/api/openapi.yaml&quot; protocolType: &quot;OpenAPI&quot; version: &quot;3.0.0&quot; Definition Management Commands​ # Save definitions oo definitions save nginx-service.yaml oo definitions save api-service.yaml oo definitions save custom-app.yaml # List all definitions oo definitions list # Remove a definition oo definitions remove nginx-svc Service Instance Registration​ Manual Instance Registration​ # Register a self-hosted service oo put /registry-svc/instance \\ --url=&quot;http://user-service:8080&quot; # Register with custom ID and deployment reference oo put /registry-svc/instance \\ --id=&quot;inst_custom_123&quot; \\ --url=&quot;http://api-service:8080&quot; \\ --deploymentId=&quot;depl_abc123&quot; # Register using individual components oo put /registry-svc/instance \\ --scheme=&quot;https&quot; \\ --host=&quot;api.example.com&quot; \\ --port=443 \\ --path=&quot;/v1&quot; # Register by IP address oo put /registry-svc/instance \\ --scheme=&quot;http&quot; \\ --ip=&quot;192.168.1.100&quot; \\ --port=8080 Service Instance Discovery​ # Find instances by service slug oo get /registry-svc/instances?slug=user-svc # Find instances by host oo get /registry-svc/instances?host=api-server-1 # Find instances by deployment oo get /registry-svc/instances?deploymentId=depl_abc123 # Find instances by node oo get /registry-svc/instances?nodeUrl=http://node1.cluster.local:11337 # List all healthy instances curl -H &quot;Authorization: Bearer $TOKEN&quot; \\ &quot;http://localhost:11337/registry-svc/instances&quot; | \\ jq '.instances[] | select(.status == &quot;Healthy&quot;)' Instance Status Management​ Instance Status Values: Unknown: Initial state, health not yet determinedHealthy: Service is responding and operationalUnhealthy: Service is not responding or failing health checksStarting: Service is in the process of starting upStopping: Service is shutting down # Monitor instance health monitor_instances() { while true; do echo &quot;=== Instance Health Status $(date) ===&quot; oo get /registry-svc/instances | jq -r '.instances[] | &quot;\\(.slug // &quot;N/A&quot;) \\(.url) \\(.status)&quot;' | \\ while read -r slug url status; do case $status in &quot;Healthy&quot;) echo &quot;✅ $slug ($url)&quot; ;; &quot;Unhealthy&quot;) echo &quot;❌ $slug ($url)&quot; ;; &quot;Starting&quot;) echo &quot;🔄 $slug ($url)&quot; ;; &quot;Stopping&quot;) echo &quot;⏹️ $slug ($url)&quot; ;; *) echo &quot;❓ $slug ($url) - $status&quot; ;; esac done echo &quot;---&quot; sleep 10 done } monitor_instances Node Management &amp; Cluster Topology​ Node Registration &amp; Heartbeat​ Nodes automatically register themselves and send periodic heartbeats with resource information. # View current node information oo get /registry-svc/node/self # List all nodes in cluster oo nodes list # Sample node output: NODE ID URL LAST HEARTBEAT prod-node-1 http://api-server-1:11337 8s ago prod-node-2 http://api-server-2:11337 12s ago gpu-node-1 http://gpu-server-1:11337 5s ago Node Configuration​ Proper node configuration is critical for distributed deployments: # Well-configured node environment variables export OB_SELF_URL=&quot;http://api-server-1.internal:11337&quot; export OB_NODE_ID=&quot;prod-node-1&quot; export OB_REGION=&quot;us-east-1&quot; export OB_AVAILABILITY_ZONE=&quot;us-east-1a&quot; # Poorly configured (will cause issues) export OB_SELF_URL=&quot;http://127.0.0.1:11337&quot; # Not accessible from other nodes # Missing OB_NODE_ID (auto-generated IDs are error-prone) Node Resource Monitoring​ # Get detailed node information with resource usage get_node_resources() { oo get /registry-svc/node/self | jq '{ id: .node.id, url: .node.url, region: .node.region, availabilityZone: .node.availabilityZone, cpu: .node.usage.cpu, memory: .node.usage.memory, disk: .node.usage.disk, gpus: .node.gpus | length }' } get_node_resources # Monitor cluster resources monitor_cluster_resources() { echo &quot;=== Cluster Resource Usage ===&quot; oo post /registry-svc/nodes | jq -r '.nodes[] | &quot;\\(.id) CPU:\\(.usage.cpu.percent)% MEM:\\(.usage.memory.percent)% DISK:\\(.usage.disk.percent)% GPUs:\\(.gpus | length)&quot;' } monitor_cluster_resources GPU Node Management​ # List nodes with GPU capabilities oo post /registry-svc/nodes | jq '.nodes[] | select(.gpus | length &gt; 0) | { id: .id, url: .url, gpuCount: (.gpus | length), gpus: [.gpus[] | {name: .name, memory: .memoryTotal, utilization: .gpuUtilization}] }' # Find available GPU resources find_available_gpus() { oo post /registry-svc/nodes | jq -r '.nodes[] | select(.gpus | length &gt; 0) | .gpus[] | select(.gpuUtilization &lt; 50) | &quot;\\(.name) (\\(.memoryUsage)MB/\\(.memoryTotal)MB used)&quot;' } find_available_gpus Node Removal &amp; Cleanup​ # Remove a node from the cluster oo nodes remove http://api-server-2:11337 # Clean up instances from removed nodes cleanup_dead_instances() { local dead_node_url=$1 echo &quot;Cleaning up instances from dead node: $dead_node_url&quot; # Find instances on the dead node dead_instances=$(oo get /registry-svc/instances | \\ jq -r &quot;.instances[] | select(.nodeUrl == \\&quot;$dead_node_url\\&quot;) | .id&quot;) # Remove each instance for instance_id in $dead_instances; do echo &quot;Removing instance: $instance_id&quot; oo instances remove &quot;$instance_id&quot; done } cleanup_dead_instances &quot;http://api-server-2:11337&quot; Service Discovery Integration​ Proxy Svc Integration​ Registry Svc works seamlessly with Proxy Svc for automatic service routing: # Register a service for proxy routing oo put /registry-svc/instance \\ --url=&quot;http://user-service:8080&quot; # Proxy Svc automatically discovers and routes to this instance curl http://localhost:11337/user-svc/health # Routes to: http://user-service:8080/user-svc/health # Load balancing with multiple instances oo put /registry-svc/instance --url=&quot;http://user-service-1:8080&quot; oo put /registry-svc/instance --url=&quot;http://user-service-2:8080&quot; oo put /registry-svc/instance --url=&quot;http://user-service-3:8080&quot; # Requests automatically load balanced across all instances curl http://localhost:11337/user-svc/api/users Real-World Usage Examples​ 1. Microservices E-Commerce Platform​ # user-service-def.yaml id: &quot;user-svc&quot; image: name: &quot;mycompany/user-service:v2.1.0&quot; internalPorts: [8080] envars: - key: &quot;DATABASE_URL&quot; value: &quot;postgresql://postgres:5432/users&quot; - key: &quot;REDIS_URL&quot; value: &quot;redis://redis:6379&quot; apiSpecs: - url: &quot;/openapi.json&quot; protocolType: &quot;OpenAPI&quot; version: &quot;3.0.0&quot; # product-service-def.yaml id: &quot;product-svc&quot; image: name: &quot;mycompany/product-service:v1.8.2&quot; internalPorts: [8080] envars: - key: &quot;DATABASE_URL&quot; value: &quot;postgresql://postgres:5432/products&quot; - key: &quot;ELASTICSEARCH_URL&quot; value: &quot;http://elasticsearch:9200&quot; # order-service-def.yaml id: &quot;order-svc&quot; image: name: &quot;mycompany/order-service:v3.0.1&quot; internalPorts: [8080] envars: - key: &quot;DATABASE_URL&quot; value: &quot;postgresql://postgres:5432/orders&quot; - key: &quot;PAYMENT_SERVICE_URL&quot; value: &quot;http://payment-svc:8080&quot; # Deploy the microservices oo definitions save user-service-def.yaml oo definitions save product-service-def.yaml oo definitions save order-service-def.yaml # Create deployments (handled by Deploy Svc) # Instances automatically registered and discoverable via: # http://localhost:11337/user-svc/* # http://localhost:11337/product-svc/* # http://localhost:11337/order-svc/* 2. Multi-Environment Service Management​ # Development environment setup_dev_services() { # Register local development services oo put /registry-svc/instance \\ --url=&quot;http://localhost:3001&quot; \\ --tags='[&quot;dev&quot;, &quot;user-service&quot;]' oo put /registry-svc/instance \\ --url=&quot;http://localhost:3002&quot; \\ --tags='[&quot;dev&quot;, &quot;product-service&quot;]' oo put /registry-svc/instance \\ --url=&quot;http://localhost:3003&quot; \\ --tags='[&quot;dev&quot;, &quot;order-service&quot;]' } # Staging environment setup_staging_services() { oo put /registry-svc/instance \\ --url=&quot;http://staging-user-svc:8080&quot; \\ --tags='[&quot;staging&quot;, &quot;user-service&quot;]' oo put /registry-svc/instance \\ --url=&quot;http://staging-product-svc:8080&quot; \\ --tags='[&quot;staging&quot;, &quot;product-service&quot;]' oo put /registry-svc/instance \\ --url=&quot;http://staging-order-svc:8080&quot; \\ --tags='[&quot;staging&quot;, &quot;order-service&quot;]' } # Production environment (handled by Deploy Svc) # Instances automatically registered with production configuration 3. AI/ML Service Discovery​ # model-inference-def.yaml id: &quot;model-inference-svc&quot; image: name: &quot;mycompany/ml-inference:gpu-v1.0.0&quot; internalPorts: [8080] envars: - key: &quot;MODEL_PATH&quot; value: &quot;/models/sentiment-analysis-v2&quot; - key: &quot;BATCH_SIZE&quot; value: &quot;32&quot; - key: &quot;CUDA_VISIBLE_DEVICES&quot; value: &quot;0&quot; # Deploy to GPU nodes oo definitions save model-inference-def.yaml # Query GPU-enabled instances oo get /registry-svc/instances | jq '.instances[] | select(.slug == &quot;model-inference-svc&quot;) | {id: .id, url: .url, nodeUrl: .nodeUrl}' # Find GPU availability for new deployments oo post /registry-svc/nodes | jq '.nodes[] | select(.gpus | length &gt; 0) | {id: .id, gpus: [.gpus[] | select(.gpuUtilization &lt; 80)]}' 4. Service Health Monitoring​ # Comprehensive health monitoring script monitor_service_health() { while true; do echo &quot;=== Service Health Report $(date) ===&quot; # Get all instances instances=$(oo get /registry-svc/instances) # Group by service slug echo &quot;$instances&quot; | jq -r '.instances[] | .slug // &quot;unknown&quot;' | sort | uniq | \\ while read -r service; do if [ &quot;$service&quot; != &quot;unknown&quot; ] &amp;&amp; [ &quot;$service&quot; != &quot;null&quot; ]; then echo &quot;Service: $service&quot; # Count instances by status healthy=$(echo &quot;$instances&quot; | jq -r &quot;.instances[] | select(.slug == \\&quot;$service\\&quot; and .status == \\&quot;Healthy\\&quot;) | .id&quot; | wc -l) unhealthy=$(echo &quot;$instances&quot; | jq -r &quot;.instances[] | select(.slug == \\&quot;$service\\&quot; and .status == \\&quot;Unhealthy\\&quot;) | .id&quot; | wc -l) total=$(echo &quot;$instances&quot; | jq -r &quot;.instances[] | select(.slug == \\&quot;$service\\&quot;) | .id&quot; | wc -l) echo &quot; Healthy: $healthy/$total&quot; if [ &quot;$unhealthy&quot; -gt 0 ]; then echo &quot; ⚠️ Unhealthy instances:&quot; echo &quot;$instances&quot; | jq -r &quot;.instances[] | select(.slug == \\&quot;$service\\&quot; and .status == \\&quot;Unhealthy\\&quot;) | \\&quot; - \\(.id) (\\(.url))\\&quot;&quot; fi # Test actual connectivity test_url=$(echo &quot;$instances&quot; | jq -r &quot;.instances[] | select(.slug == \\&quot;$service\\&quot; and .status == \\&quot;Healthy\\&quot;) | .url&quot; | head -1) if [ &quot;$test_url&quot; != &quot;null&quot; ] &amp;&amp; [ -n &quot;$test_url&quot; ]; then if curl -fsSL --max-time 5 &quot;$test_url/health&quot; &gt; /dev/null 2&gt;&amp;1; then echo &quot; ✅ Health check passed&quot; else echo &quot; ❌ Health check failed&quot; fi fi echo &quot;&quot; fi done sleep 30 done } monitor_service_health 5. Distributed Application Discovery​ # Service mesh monitoring monitor_service_mesh() { echo &quot;=== Service Mesh Topology ===&quot; # Get all services and their instances oo get /registry-svc/instances | jq -r ' .instances[] | select(.slug != null) | &quot;\\(.slug) \\(.url) \\(.status) \\(.nodeUrl // &quot;unknown&quot;)&quot;' | \\ while read -r service url status node; do node_short=$(echo &quot;$node&quot; | sed 's|http://||' | cut -d: -f1) echo &quot;$service -&gt; $url [$status] on $node_short&quot; done echo &quot;&quot; echo &quot;=== Node Distribution ===&quot; # Show service distribution across nodes oo post /registry-svc/nodes | jq -r '.nodes[] | .url' | \\ while read -r node_url; do node_short=$(echo &quot;$node_url&quot; | sed 's|http://||' | cut -d: -f1) instance_count=$(oo get /registry-svc/instances | jq -r &quot;.instances[] | select(.nodeUrl == \\&quot;$node_url\\&quot;) | .slug&quot; | wc -l) echo &quot;$node_short: $instance_count instances&quot; done } monitor_service_mesh 6. Service Auto-Discovery Script​ # Auto-discovery and registration for Docker Compose auto_register_docker_services() { local compose_file=${1:-docker-compose.yml} echo &quot;Auto-registering services from $compose_file&quot; # Extract service names and ports from docker-compose.yml docker-compose -f &quot;$compose_file&quot; config | yq eval '.services | to_entries[] | select(.value.ports != null) | {name: .key, port: .value.ports[0] | split(&quot;:&quot;)[0]}' -o json | \\ while read -r service_config; do service_name=$(echo &quot;$service_config&quot; | jq -r '.name') port=$(echo &quot;$service_config&quot; | jq -r '.port') echo &quot;Registering service: $service_name on port $port&quot; oo put /registry-svc/instance \\ --url=&quot;http://$service_name:$port&quot; \\ --tags='[&quot;docker-compose&quot;, &quot;auto-registered&quot;]' || \\ echo &quot;Failed to register $service_name&quot; done } # Usage auto_register_docker_services &quot;docker-compose.yml&quot; Advanced Service Discovery Patterns​ Circuit Breaker Integration​ # Monitor instance health and implement circuit breaker logic implement_circuit_breaker() { local service_slug=$1 local failure_threshold=${2:-3} local recovery_timeout=${3:-60} while true; do instances=$(oo get /registry-svc/instances?slug=&quot;$service_slug&quot;) echo &quot;$instances&quot; | jq -r '.instances[] | &quot;\\(.id) \\(.url) \\(.status)&quot;' | \\ while read -r id url status; do if [ &quot;$status&quot; = &quot;Unhealthy&quot; ]; then # Test instance directly if curl -fsSL --max-time 5 &quot;$url/health&quot; &gt; /dev/null 2&gt;&amp;1; then echo &quot;Instance $id recovered, updating status&quot; # Instance recovered - would need API to update status else echo &quot;Instance $id still failing&quot; fi fi done sleep 10 done } implement_circuit_breaker &quot;user-svc&quot; 3 60 Service Versioning​ # user-service-v1.yaml id: &quot;user-svc-v1&quot; image: name: &quot;mycompany/user-service:v1.0.0&quot; internalPorts: [8080] envars: - key: &quot;API_VERSION&quot; value: &quot;v1&quot; # user-service-v2.yaml id: &quot;user-svc-v2&quot; image: name: &quot;mycompany/user-service:v2.0.0&quot; internalPorts: [8080] envars: - key: &quot;API_VERSION&quot; value: &quot;v2&quot; # Deploy multiple versions oo definitions save user-service-v1.yaml oo definitions save user-service-v2.yaml # Route traffic based on version # V1: http://localhost:11337/user-svc-v1/* # V2: http://localhost:11337/user-svc-v2/* Blue-Green Deployment Discovery​ # Blue-green deployment management deploy_blue_green() { local service_name=$1 local new_version=$2 echo &quot;Starting blue-green deployment for $service_name:$new_version&quot; # Deploy green version oo put /registry-svc/instance \\ --url=&quot;http://$service_name-green:8080&quot; \\ --tags='[&quot;green&quot;, &quot;staging&quot;]' # Test green version if curl -f &quot;http://$service_name-green:8080/health&quot;; then echo &quot;Green version healthy, switching traffic&quot; # Remove blue instances blue_instances=$(oo get /registry-svc/instances | \\ jq -r &quot;.instances[] | select(.tags[]? == \\&quot;blue\\&quot;) | .id&quot;) for instance_id in $blue_instances; do oo instances remove &quot;$instance_id&quot; done # Promote green to blue oo put /registry-svc/instance \\ --url=&quot;http://$service_name:8080&quot; \\ --tags='[&quot;blue&quot;, &quot;production&quot;]' echo &quot;Blue-green deployment completed&quot; else echo &quot;Green version unhealthy, aborting deployment&quot; return 1 fi } deploy_blue_green &quot;user-service&quot; &quot;v2.1.0&quot; Monitoring &amp; Observability​ Registry Health Dashboard​ # Registry service health dashboard registry_dashboard() { while true; do clear echo &quot;╔══════════════════════════════════════════════════════════════╗&quot; echo &quot;║ Registry Svc Dashboard ║&quot; echo &quot;╚══════════════════════════════════════════════════════════════╝&quot; echo &quot;&quot; # Cluster overview echo &quot;📊 Cluster Overview:&quot; node_count=$(oo post /registry-svc/nodes | jq '.nodes | length') instance_count=$(oo get /registry-svc/instances | jq '.instances | length') definition_count=$(oo get /registry-svc/definitions | jq '.definitions | length') echo &quot; Nodes: $node_count&quot; echo &quot; Instances: $instance_count&quot; echo &quot; Definitions: $definition_count&quot; echo &quot;&quot; # Instance health summary echo &quot;🏥 Instance Health:&quot; instances=$(oo get /registry-svc/instances) healthy=$(echo &quot;$instances&quot; | jq '[.instances[] | select(.status == &quot;Healthy&quot;)] | length') unhealthy=$(echo &quot;$instances&quot; | jq '[.instances[] | select(.status == &quot;Unhealthy&quot;)] | length') unknown=$(echo &quot;$instances&quot; | jq '[.instances[] | select(.status == &quot;Unknown&quot;)] | length') echo &quot; ✅ Healthy: $healthy&quot; echo &quot; ❌ Unhealthy: $unhealthy&quot; echo &quot; ❓ Unknown: $unknown&quot; echo &quot;&quot; # Service distribution echo &quot;🔀 Service Distribution:&quot; echo &quot;$instances&quot; | jq -r '.instances[] | .slug // &quot;unknown&quot;' | sort | uniq -c | \\ while read -r count service; do echo &quot; $service: $count instances&quot; done echo &quot;&quot; # Node resource usage echo &quot;💾 Node Resources:&quot; oo post /registry-svc/nodes | jq -r '.nodes[] | &quot;\\(.id): CPU \\(.usage.cpu.percent // 0)% | Memory \\(.usage.memory.percent // 0)% | GPUs \\(.gpus | length)&quot;' echo &quot;&quot; echo &quot;Last updated: $(date)&quot; echo &quot;Press Ctrl+C to exit&quot; sleep 5 done } registry_dashboard Automated Instance Cleanup​ # Clean up dead instances cleanup_dead_instances() { echo &quot;🧹 Cleaning up dead instances...&quot; instances=$(oo get /registry-svc/instances) echo &quot;$instances&quot; | jq -r '.instances[] | &quot;\\(.id) \\(.url) \\(.status)&quot;' | \\ while read -r id url status; do if [ &quot;$status&quot; = &quot;Unhealthy&quot; ]; then # Test if instance is truly dead if ! curl -fsSL --max-time 5 &quot;$url/health&quot; &gt; /dev/null 2&gt;&amp;1; then echo &quot;Removing dead instance: $id ($url)&quot; oo instances remove &quot;$id&quot; else echo &quot;Instance $id recovered: $url&quot; fi fi done } # Run cleanup every 5 minutes while true; do cleanup_dead_instances sleep 300 done Service Dependency Mapping​ # Map service dependencies map_service_dependencies() { echo &quot;🗺️ Service Dependency Map:&quot; # Get all service instances instances=$(oo get /registry-svc/instances) echo &quot;$instances&quot; | jq -r '.instances[] | select(.slug != null) | .slug' | sort | uniq | \\ while read -r service; do echo &quot;&quot; echo &quot;Service: $service&quot; # Find instances service_instances=$(echo &quot;$instances&quot; | jq -r &quot;.instances[] | select(.slug == \\&quot;$service\\&quot;) | .url&quot;) echo &quot; Instances:&quot; echo &quot;$service_instances&quot; | while read -r url; do echo &quot; - $url&quot; done # Test external dependencies (simplified - would need service-specific logic) echo &quot; Dependencies:&quot; for dependency in &quot;database&quot; &quot;redis&quot; &quot;elasticsearch&quot;; do if echo &quot;$service_instances&quot; | head -1 | xargs -I {} curl -fsSL --max-time 3 {}/dependencies 2&gt;/dev/null | grep -q &quot;$dependency&quot;; then echo &quot; - $dependency ✅&quot; fi done done } map_service_dependencies Troubleshooting​ Common Issues​ Service Not Discoverable​ # Check if service is registered oo get /registry-svc/instances?slug=your-service # Verify instance status oo get /registry-svc/instances | jq '.instances[] | select(.slug == &quot;your-service&quot;)' # Test direct connectivity curl -v http://your-service:8080/health # Check proxy routing curl -v http://localhost:11337/your-service/health Instances Showing as Unhealthy​ # Check instance endpoint directly test_instance_health() { local instance_url=$1 echo &quot;Testing: $instance_url&quot; # Basic connectivity if curl -fsSL --max-time 5 &quot;$instance_url&quot; &gt; /dev/null; then echo &quot;✅ Instance responds&quot; else echo &quot;❌ Instance not responding&quot; fi # Health endpoint if curl -fsSL --max-time 5 &quot;$instance_url/health&quot; &gt; /dev/null; then echo &quot;✅ Health endpoint OK&quot; else echo &quot;❌ Health endpoint failed&quot; fi # Network connectivity host=$(echo &quot;$instance_url&quot; | sed 's|http://||' | cut -d: -f1) port=$(echo &quot;$instance_url&quot; | sed 's|http://||' | cut -d: -f2) if nc -zv &quot;$host&quot; &quot;$port&quot; 2&gt;/dev/null; then echo &quot;✅ Network connectivity OK&quot; else echo &quot;❌ Network connectivity failed&quot; fi } test_instance_health &quot;http://user-service:8080&quot; Node Communication Issues​ # Test node connectivity test_node_connectivity() { local node_url=$1 echo &quot;Testing node: $node_url&quot; # Basic HTTP connectivity if curl -fsSL --max-time 5 &quot;$node_url/health&quot; &gt; /dev/null; then echo &quot;✅ Node responds&quot; else echo &quot;❌ Node not responding&quot; fi # Registry API access if curl -fsSL --max-time 5 &quot;$node_url/registry-svc/node/self&quot; &gt; /dev/null; then echo &quot;✅ Registry API accessible&quot; else echo &quot;❌ Registry API failed&quot; fi } # Test all nodes oo post /registry-svc/nodes | jq -r '.nodes[].url' | \\ while read -r node_url; do test_node_connectivity &quot;$node_url&quot; done Definition Deployment Issues​ # Validate definition format validate_definition() { local definition_file=$1 echo &quot;Validating: $definition_file&quot; # Check YAML syntax if yq eval '.' &quot;$definition_file&quot; &gt; /dev/null; then echo &quot;✅ YAML syntax valid&quot; else echo &quot;❌ YAML syntax error&quot; return 1 fi # Check required fields if yq eval '.id' &quot;$definition_file&quot; | grep -v null &gt; /dev/null; then echo &quot;✅ ID field present&quot; else echo &quot;❌ Missing required 'id' field&quot; fi # Check image or repository if yq eval '.image.name' &quot;$definition_file&quot; | grep -v null &gt; /dev/null; then echo &quot;✅ Image specification found&quot; elif yq eval '.repository.url' &quot;$definition_file&quot; | grep -v null &gt; /dev/null; then echo &quot;✅ Repository specification found&quot; else echo &quot;❌ Missing image or repository specification&quot; fi } validate_definition &quot;my-service-def.yaml&quot; API Reference Summary​ Endpoint\tMethod\tPurpose/registry-svc/instances\tGET\tList service instances with filtering /registry-svc/instance\tPUT\tRegister a new service instance /registry-svc/instance/{id}\tDELETE\tRemove a service instance /registry-svc/definitions\tGET\tList service definitions /registry-svc/definition\tPUT\tSave a service definition /registry-svc/definition/{id}\tDELETE\tRemove a service definition /registry-svc/nodes\tPOST\tList cluster nodes /registry-svc/node/self\tGET\tGet current node information /registry-svc/node/{url}\tDELETE\tRemove a node from cluster Permissions &amp; Security​ # Required permissions registry-svc:instance:view # List and view service instances registry-svc:instance:edit # Register service instances registry-svc:instance:delete # Remove service instances registry-svc:definition:view # List and view service definitions registry-svc:definition:edit # Save service definitions registry-svc:definition:delete # Remove service definitions registry-svc:node:view # List and view cluster nodes registry-svc:node:delete # Remove nodes from cluster # Service isolation # Services can only see their own instances unless they have admin privileges # or are specifically permitted services (proxy-svc) Related Services​ Proxy Svc: Discovers instances for load balancing and routingContainer Svc: Manages container instances on individual nodes Environment Variables​ # Node configuration (critical for distributed deployments) OB_SELF_URL=&quot;http://api-server-1.internal:11337&quot; # Node's accessible URL OB_NODE_ID=&quot;prod-node-1&quot; # Unique node identifier OB_REGION=&quot;us-east-1&quot; # Geographic region OB_AVAILABILITY_ZONE=&quot;us-east-1a&quot; # Availability zone # Poor configuration examples (avoid these) OB_SELF_URL=&quot;http://127.0.0.1:11337&quot; # Not accessible from other nodes # Missing OB_NODE_ID # Auto-generated IDs cause issues Production Best Practices​ Multi-Node Setup​ # Node 1 configuration export OB_SELF_URL=&quot;http://node1.cluster.local:11337&quot; export OB_NODE_ID=&quot;node-1&quot; export OB_REGION=&quot;us-east-1&quot; export OB_AVAILABILITY_ZONE=&quot;us-east-1a&quot; # Node 2 configuration export OB_SELF_URL=&quot;http://node2.cluster.local:11337&quot; export OB_NODE_ID=&quot;node-2&quot; export OB_REGION=&quot;us-east-1&quot; export OB_AVAILABILITY_ZONE=&quot;us-east-1b&quot; # GPU node configuration export OB_SELF_URL=&quot;http://gpu-node1.cluster.local:11337&quot; export OB_NODE_ID=&quot;gpu-node-1&quot; export OB_REGION=&quot;us-east-1&quot; export OB_AVAILABILITY_ZONE=&quot;us-east-1c&quot; Health Monitoring​ # Comprehensive health monitoring setup_health_monitoring() { # Monitor instance health ( monitor_instances ) &amp; # Monitor node health ( monitor_cluster_resources ) &amp; # Clean up dead instances ( cleanup_dead_instances ) &amp; # Registry dashboard registry_dashboard } setup_health_monitoring Service Mesh Observability​ # Service mesh monitoring setup setup_observability() { # Export metrics to monitoring system monitor_service_metrics() { while true; do # Instance metrics oo get /registry-svc/instances | jq '{ total_instances: (.instances | length), healthy_instances: ([.instances[] | select(.status == &quot;Healthy&quot;)] | length), unhealthy_instances: ([.instances[] | select(.status == &quot;Unhealthy&quot;)] | length), services: ([.instances[].slug | select(. != null)] | unique | length) }' &gt; /var/metrics/registry-instances.json # Node metrics oo post /registry-svc/nodes | jq '{ total_nodes: (.nodes | length), total_gpus: ([.nodes[].gpus[]] | length), avg_cpu_usage: ([.nodes[].usage.cpu.percent // 0] | add / length), avg_memory_usage: ([.nodes[].usage.memory.percent // 0] | add / length) }' &gt; /var/metrics/registry-nodes.json sleep 60 done } monitor_service_metrics &amp; } setup_observability Registry Svc provides the foundation for distributed service architecture in 1Backend, enabling automatic service discovery, load balancing, and health monitoring across multi-node clusters with comprehensive GPU and resource management capabilities.","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Supported LLMs","type":0,"sectionRef":"#","url":"/docs/platform-capabilities/supported-llms","content":"Supported LLMs LLaMA 🦙 LLaMA 2 🦙🦙 LLaMA 3 🦙🦙🦙 Mistral 7B Mixtral MoE DBRX Falcon Chinese LLaMA / Alpaca and Chinese LLaMA-2 / Alpaca-2 Vigogne (French) BERT Koala Baichuan 1 &amp; 2 + derivations Aquila 1 &amp; 2 Starcoder models Refact MPT Bloom Yi models StableLM models Deepseek models Qwen models PLaMo-13B Phi models GPT-2 Orion 14B InternLM2 CodeShell Gemma Mamba Grok-1 Xverse Command-R models SEA-LION GritLM-7B + GritLM-8x7B OLMo GPT-NeoX + Pythia ChatGLM3-6b + ChatGLM4-9b","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Welcome to 1Backend","type":0,"sectionRef":"#","url":"/docs/intro","content":"Welcome to 1Backend 1Backend is the culmination of nearly two decades of microservices veterans’ journey toward productivity in distributed‑systems environments. Although web frameworks are abundant and sophisticated, they’re not built with microservices architectures in mind and often struggle to scale across large fleets of servers. As a result, many startups and enterprise teams hand‑roll their own distributed platforms—there simply isn’t a clear winner in this space. Unlike the more unified JavaScript ecosystem, the backend world remains highly fragmented by a multitude of languages and tools. When organizations venture into this territory, they can suffer—and even endure a 100×—productivity drop. At first, they may shrug it off—after all, they can hire more expensive engineers—but in practice, lengthy rewrites or “next‑generation platforms” can grind an entire company to a halt, costing market leaders their competitive edge. Conceived in the author’s mind for over ten years, 1Backend aspires to be the operating system for distributed backend applications—offering a unified, scalable foundation that finally brings cohesion and efficiency to a fragmented landscape. Running the server​ The first step is to run the daemon. For details about that, see Running the Server. Built-in services​ For a quick overview about what the system is capable, read through the Built-in Service Docs. Building your services​ To build and run your own services on 1Backend, see Your First Service Privacy notice​ Privacy is of prime importance to us. To learn more about the privcy aspects of this software, visit the Privacy Notice page.","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Privacy Notice","type":0,"sectionRef":"#","url":"/docs/privacy-notice","content":"Privacy Notice This document details the privacy considerations of 1Backend. Overview​ By running AIs locally/on-premise with 1Backend, neither the questions nor the answers leave your computer/premises. There are a few dependencies that are so huge that they are not bundled with 1Backend and must be downloaded at the start of the application: Things 1Backend downloads​ Model Files​ The model weights themselves are downloaded from https://huggingface.co. Docker Containers​ Docker containers are a form of lightweight virtualization technology that enables 1Backend to run a wide range of AI architectures. Things 1Backend uploads​ None.","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Frontend Environment Variables","type":0,"sectionRef":"#","url":"/docs/running-the-server/frontend-environment-variables","content":"Frontend Environment Variables BACKEND_ADDRESS​ In a publicly accessible setup should be something like https://singulatron-api.yourdomain.com. The point is that it must be accessible from the outside/browser.","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Running the 1Backend server with Docker Compose and prebuilt images","type":0,"sectionRef":"#","url":"/docs/running-the-server/docker-compose","content":"Running the 1Backend server with Docker Compose and prebuilt images This deployment method is one step above local development in terms of sophistication. It’s suitable for a development server or simple production environments. This snippet will give you a quick idea about how to deploy the frontend and backend containers so they play nicely together: version: &quot;3.8&quot; volumes: 1backend-data: name: 1backend-data driver: local services: 1backend-ui: image: crufter/1backend-ui:latest ports: - &quot;3901:80&quot; environment: # `BACKEND_ADDRESS` must be reachable from the browser. # This is the API the browser will communicate with, not an internal address. - BACKEND_ADDRESS=http://127.0.0.1:11337 1backend: image: crufter/1backend:default-1-latest # Use a version that matches your GPU architecture for GPU acceleration, e.g.: # crufter/1backend:cuda-12.2.0-latest # For available versions, see: # - https://hub.docker.com/r/crufter/1backend/tags # - The build file `1backend-docker-build.yaml` ports: - &quot;11337:11337&quot; volumes: # We mount the hostname to have a sensible fallback node URL - /etc/hostname:/etc/host_hostname:ro # We mount the docker socket so the backend can start containers - /var/run/docker.sock:/var/run/docker.sock # We mount a volume so data will be persisted - 1backend-data:/root/.1backend # Permits 1Backend access to GPU metrics. # Containers launched by 1Backend can still use GPU acceleration even if 1Backend lacks direct GPU access. # deploy: # resources: # reservations: # devices: # - driver: nvidia # count: all # capabilities: [gpu] environment: # Volume mounted by AI containers launched by 1Backend to access models downloaded by the 1Backend File Svc. - OB_VOLUME_NAME=1backend-data # # Enables GPU acceleration for NVIDIA GPUs. # This flag controls GPU access for AI containers launched by 1Backend. # # - OB_GPU_PLATFORM=cuda Put the above into a file called docker-compose.yaml in a folder on your computer and run it with the following command: docker compose up Once it's running​ After the containers successfully start, you can go to 127.0.0.1:3901 and log in with the Default Credentials. Configuring​ See the Backend Environment Variables and Frontend Environment Variables.","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Once the 1Backend server is running","type":0,"sectionRef":"#","url":"/docs/running-the-server/using","content":"Once the 1Backend server is running Using the 1Backend UI​ Depending on how you started 1Backend, you can access the 1Backend UI on http://127.0.0.1:3901 (if you use Docker Compose), or http://127.0.0.1:4200 (if you use Angular). Using the 1Backend CLI​ See the oo CLI page for more information about CLI usage. Default Credentials​ Unless you configured otherwise, you can log in with the following default credentials: username: 1backend password: changeme ","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Running the 1Backend server locally","type":0,"sectionRef":"#","url":"/docs/running-the-server/locally","content":"Running the 1Backend server locally The easiest way to run 1Backend is to use Docker Compose. Using Docker Compose​ The easiest way to run this is to clone the repo, step into the repo root and run: git clone git@github.com:1backend/1backend.git cd 1backend docker compose up # or use the -d flag to run it in the background # docker compose up -d The docker-compose-yaml in the root folder is designed to build and run the current code. For a more production ready Docker Compose file see the Running the 1Backend server with Docker Compose and prebuilt images. Once it's running in Docker Compose​ After the containers successfully start, you can go to http://127.0.0.1:3901 and log in with the Default Credentials. Running natively (Go &amp; Angular)​ If you have both Go and Angular installed on your computer, the easiest way to dip your feet into 1Backend is to run things locally. Running the backend natively (with Go)​ cd server; go run main.go Running the frontend natively (with Angular)​ cd desktop/workspaces/angular-app/; npm run start Once it's running on the host​ After the both the backend and frontend starts, you can go to http://127.0.0.1:4200 and log in with the Default Credentials. Administration​ Local files​ By default 1Backend uses the folder ~/.1backend on your machine for data tables, file downloads, file uploads. The ~/.1backend/cliConfig.yaml file is where the oo CLI stores all its data. Download &amp; Uploads​ Downloads and uploads are managed by the File Svc, and by default are stored here: ~/.1backend/downloads ~/.1backend/uploads Data files​ By default 1Backend uses local gzipped json files to store database entries. Data access across 1Backend is interface based so the this implementation can be easily swapped out for PostgreSQL and other database backends. These files are located at ls ~/.1backend/data Each file is prefixed by the owner service slug, so the User Svc users table becomes userSvcUsers. If you want to view the contents of a file: cat ~/.1backend/data/userSvcUsers.zip | gzip -dc # or if you jave jq installed cat ~/.1backend/data/userSvcUsers.zip | gzip -dc | jq ","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Backend Environment Variables","type":0,"sectionRef":"#","url":"/docs/running-the-server/backend-environment-variables","content":"Backend Environment Variables OB_CONTACT_EMAIL​ Specifies the system-wide contact email address for operational and administrative use. This email is used in various backend components, including: ACME TLS certificate registration (e.g., Let's Encrypt)System notifications or future alerting mechanismsRecovery options for certain services that require a fallback contact While optional, it is strongly recommended to set this in production environments so you can receive: Expiration or renewal notices for HTTPS certificatesWarnings about rate limits or configuration issuesFuture administrative alerts from the system This address will not be used for login or user account purposes. OB_DB​ You can use this envar to make 1Backend actually use a database instead of local file storage to store data. OB_DB_PREFIX​ When specified, all tables in the database will be prefixed by this strings. Mostly useful for testing. PostgreSQL​ OB_DB=postgres OB_DB_DRIVER=&quot;postgres&quot; # or &quot;mysql&quot; OB_DB_CONNECTION_STRING=&quot;postgres://postgres:mysecretpassword@localhost:5432/mydatabase?sslmode=disable&quot; Naturally, you should change the details of the connection string to reflect your environment. OB_EDGE_PROXY​ When set to true, 1Backend will enable the edge proxy feature. This feature configures the system to listen for incoming HTTP and HTTPS traffic on ports 80 and 443, respectively. OB_EDGE_PROXY=true The edge proxy acts as a public-facing reverse proxy, handling domain-based routing and TLS termination for external requests. It is typically used to: Serve ACME HTTP-01 challenges (for automated TLS certificates, e.g., via Let's Encrypt) on port 80.Handle public HTTPS traffic on port 443, routing incoming domain-based requests to appropriate backends or services based on their domain. When OB_EDGE_PROXY is not set to true, 1Backend will not start these public-facing routers. Only the internal API server on the OB_SERVER_URL port (default: 11337) will be active. Typical Use Case: Use this flag when 1Backend is running as a publicly accessible server that needs to: Terminate TLS (HTTPS) at the edge.Serve automated certificates via ACME.Route external requests based on domain names. OB_EDGE_PROXY_TEST_MODE​ Enables test mode for the edge proxy. Contrary to the production edge proxy, the dev mode: Does not try to redirect to 443Does no certificate requests and renewalRoutes HTTP requests (vs HTTP for prod). OB_EDGE_PROXY_HTTP_PORT​ Sets the HTTP port for the edge proxy. In production, this must be 80. Any other value is only for testing purposes. OB_EDGE_PROXY_HTTPS_PORT​ Sets the HTTPS port for the edge proxy. In production, this must be 443. Any other value is only useful in testing. OB_ENCRYPTION_KEY​ This key is used in the Secret Svc so secrets are encrypted at rest. OB_FOLDER​ When specified, all data (uploads, downloads, image resize caches, models etc.) will be stored in this folder. Defaults to ~/.1backend. OB_GPU_PLATFORM​ This envar is used to enabel GPU acceleration. Supported platforms: cuda Do not set this if your card doesn't support the given architecture or things will break. OB_LLM_HOST​ This flag is typically unnecessary since 1Backend retrieves the IP of the Docker bridge. Use it only as a corrective action. When 1Backend is running in a container, it needs to know how to address its siblings (other containers it started): Host | |-&gt; 1Backend Container |-&gt; Container Launched By 1Backend The 1Backend Container uses the envar OB_LLM_HOST to address Container Launched By 1Backend. Typically this value should be 172.17.0.1 if you are using the default docker network. If you are using an other network than default, use docker network inspect to find out the IP of your docker bridge for that network. Usually it's going to be 172.18.0.1. This envar is not needed if 1Backend runs directly on the host: Host With 1Backend | |-&gt; Container Launched By 1Backend OB_NODE_ID​ For information about this, please refer to the Registry Svc Node section OB_VERIFY_CONTACTS​ When set to true, registration of new users with a contact address requires an OTP to prove ownership of the contact. OB_SERVER_URL​ The OB_SERVER_URL is the internally addressable (non-public-facing) URL of an 1Backend server. It should point to the local 1Backend instance on each physical node. Ideally, every node should have its own 1Backend instance. This envar should be set only for microservices built on 1Backend. The 1Backend server itself should use OB_SELF_URL. OB_SELF_URL​ Microservices use this to register themselves in the 1Backend registry. The 1Backend server uses this to address itself. OB_SYNC_CERTS_TO_FILES​ Also save certificates to disk. By default, certificates are stored in the internal datastore managed by the proxy service. However, in some cases — for example, when other containers need to access the certificates — it's useful to have them available on the filesystem as well. When this flag is set to true, the server will write certificates to the OB_FOLDER/certs directory (by default, ~/.1backend/certs) using a standard directory layout compatible with common infrastructure software like Let's Encrypt (Certbot), NGINX, and Apache. Directory Structure​ Certificates are organized under: &lt;OB_FOLDER&gt;/certs/live/&lt;domain&gt;/ Within each domain directory, files are saved as: cert.pem — the domain’s public certificateprivkey.pem — the private key corresponding to the certificatechain.pem — intermediate certificates forming the chain (if any)fullchain.pem — concatenation of cert.pem and chain.pem This structure aligns with what many TLS tools and web servers expect, making it easy to integrate with existing systems that rely on file-based certificates. Example​ For the domain singulatron.com, files will be saved as: ~/.1backend/certs/live/singulatron.com/cert.pem ~/.1backend/certs/live/singulatron.com/privkey.pem ~/.1backend/certs/live/singulatron.com/chain.pem ~/.1backend/certs/live/singulatron.com/fullchain.pem This standard layout ensures compatibility with web servers like NGINX and Apache, as well as automation tools like Certbot, enabling easy mounting of certificates into containers or configuring HTTPS endpoints. OB_TEST​ Microservices and the 1Backend server uses this envar to detect if they are running as part of a test. When set to true, subsystems act accordingly: for example the datastore will prefix tables with random numbers to provide a unique and clean environment for each test. First startup is also significantly faster when this flag is enabled, as 1Backend uses bcrypt.MinCost instead of bcrypt.DefaultCost for password generation, and sets the RSA key size to 512 bits in test mode instead of the default 4096. OB_TOKEN_AUTO_REFRESH_OFF​ When set to true, clients are responsible for handling the refresh of expired tokens themselves. This overrides the default behavior, where expired tokens are automatically accepted and refreshed by the system. OB_TOKEN_EXPIRATION​ Specifies the duration before a token expires. Use formats like 5m for five minutes, 10h for ten hours, etc. OB_VOLUME_NAME​ This flag is typically unnecessary since 1Backend automatically detects the volume that is bound to /root/.1backend. Use it only as a corrective action. This envar is needed when 1Backend runs as a container next to containers it starts: Host | |-&gt; 1Backend Container |-&gt; Container Launched By 1Backend For the containers like llama-cpp to be able to read the models downloaded by 1Backend we they must both mount the same docker volume. An example of this can be seen in the root docker-compose.yaml file: OB_VOLUME_NAME=singulatron-data. So cycle goes like this: 1Backend container writes to /root/.1backend, which is mounted to the volume singulatron-dataAssets (which are basically downloaded files) will be passed to containers created by 1Backend by mounting files in singulatron-data.","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"System design guidelines","type":0,"sectionRef":"#","url":"/docs/writing-custom-services/system-design-guidelines","content":"System design guidelines 1Backend doesn't force you to use any particular patterns, languages, stacks, databases, or even conventions. 1Backend services themselves however follow some light conventions. Pagination​ Offset vs. cursor pagination in distributed systems​ In distributed systems—especially when dealing with large datasets or high write volumes—OFFSET-based pagination is inefficient and unstable because: Performance: The database still has to scan through all skipped rows before returning results.Consistency: New inserts or deletes between requests can cause missing or duplicated results. Cursor-Based Pagination​ Cursor-based pagination is the preferred strategy in distributed systems because it avoids the problems of offset-based pagination — such as inconsistent results when data changes between pages, and performance issues with large offsets. Instead of skipping rows, cursor-based pagination uses a cursor value to mark the position in the dataset and fetch the next page relative to that position. How It Works​ The client receives a cursor from the API in each paginated response.The client includes that cursor in the next request to fetch the next page.The server uses the cursor to determine where to resume from in the dataset. Cursor Format​ The cursor is typically represented as a slice of values ([]any), such as: [&quot;2023-08-01T12:00:00Z&quot;, &quot;user-123&quot;] This allows precise pagination even when multiple records share the same timestamp (e.g., createdAt). The second element (like a unique ID) ensures deterministic ordering and avoids skipping or duplicating records. Example​ Request 1: GET /items?limit=10 Response 1: { &quot;items&quot;: [...], // This is actually optional, one can easily take the fields from the last item in the list. &quot;nextCursor&quot;: [&quot;2023-08-01T12:00:00Z&quot;, &quot;user-123&quot;] } GET /items?limit=10&amp;after=[&quot;2023-08-01T12:00:00Z&quot;,&quot;user-123&quot;] Field Name Conventions​ Pagination parameters should be top-level fields in a List request. For example: { &quot;limit&quot;: 10, &quot;after&quot;: [&quot;2023-08-01T12:00:00Z&quot;, &quot;user-123&quot;], &quot;order&quot;: &quot;asc&quot;, &quot;orderBy&quot;: &quot;createdAt&quot; } Common Ordering Strategies​ createdAt (ascending): Use when exporting or scanning all records from the beginning. This gives a complete, chronological view of the dataset. updatedAt (descending): Use when syncing recent changes (e.g., polling for updates). Returns the newest records first. Why Timestamps Alone Are Not Enough​ Timestamps like createdAt or updatedAt are commonly used for ordering, but they are not unique. Multiple records can share the same timestamp, leading to unstable or overlapping pagination. To prevent this, always pair the timestamp with a unique, stable identifier (like an ID). This ensures: Deterministic orderingNo records are skipped or repeatedProper continuation across pages, even when timestamps collide No special parsing is required — the cursor is passed as a JSON array and can be unmarshaled directly as []any in Go. API naming guidelines​ List* endpoints​ It is advised that endpoints returning entities are called ListEntities, eg. ListMessages. Do not create read/query endpoints that return a single entity unless you have good reasons to do so. The list endpoints should have a few standard filters ideally: ids field​ The field ids should enable single and multiread by ID queries in list endpoints. Save* endpoints​ For endpoints that create or update entities, it’s recommended to use a unified SaveEntities naming convention (e.g., SaveMessages). While separating Create and Update operations allows for more precise request schemas (since the required fields may differ), 1Backend favors the following principles: Minimize the number of endpoints — simpler APIs are easier to maintain and evolve. Prioritize idempotency — Create endpoints typically aren't idempotent, while Save can be designed to be. Optimize for batch operations — network calls are costly. Design endpoints to handle multiple entities at once. This not only improves efficiency but also makes it easier to scale or create specialized multi-* versions of your endpoint when performance demands arise. IDs​ Ids are by convention prefixed by a shorthand inspired by the entity name, think thread IDs being prefixed by thr_.","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"},{"title":"Your first service","type":0,"sectionRef":"#","url":"/docs/writing-custom-services/your-first-service","content":"Your first service While 1Backend itself is written in Go, services that run on it can be written in any language. A service only needs a few things to fully function: Register a user account, just like a human user. For details, see the User Svc.Register its instance in the registry so 1Backend knows where to route requests. A Go example​ The following Go service demonstrates these steps: Registers itself as a user with the slug basic-svcRegisters or updates its URL (http://127.0.0.1:9111) in the Registry. You may notice that the following code uses a &quot;Go SDK&quot;—this is simply a set of convenience functions built on top of the 1Backend API. 1Backend is language-agnostic and can be used with any language, even if no SDK is available in the repository. The full code, including tests, is available in the examples directory. // &lt;!-- INCLUDE: ../../../examples/go/services/basic/internal/basic_service.go --&gt; package basicservice import ( &quot;context&quot; &quot;net/http&quot; openapi &quot;github.com/1backend/1backend/clients/go&quot; basic &quot;github.com/1backend/1backend/examples/go/services/basic/internal/types&quot; sdk &quot;github.com/1backend/1backend/sdk/go&quot; &quot;github.com/1backend/1backend/sdk/go/auth&quot; &quot;github.com/1backend/1backend/sdk/go/boot&quot; &quot;github.com/1backend/1backend/sdk/go/client&quot; &quot;github.com/1backend/1backend/sdk/go/datastore&quot; &quot;github.com/1backend/1backend/sdk/go/infra&quot; &quot;github.com/gorilla/mux&quot; &quot;github.com/pkg/errors&quot; ) const RolePetManager = &quot;basic-svc:pet:manager&quot; type BasicService struct { Options *boot.Options token string userSvcPublicKey string dataStoreFactory infra.DataStoreFactory petsStore datastore.DataStore credentialStore datastore.DataStore Router *mux.Router } type Options struct { Test bool ServerUrl string SelfUrl string } func NewService(options *boot.Options) (*BasicService, error) { options.LoadEnvars() dconf := infra.DataStoreConfig{} if options.Test { dconf.Test = true dconf.TablePrefix = &quot;t_&quot; + sdk.Id(&quot;&quot;) } service := &amp;BasicService{ Options: options, } dsf, err := infra.NewDataStoreFactory(dconf) if err != nil { return nil, errors.Wrap(err, &quot;cannot create datastore factory&quot;) } service.dataStoreFactory = dsf petStore, err := dsf.Create(&quot;basicSvcPets&quot;, &amp;basic.Pet{}) if err != nil { return nil, err } service.petsStore = petStore service.registerAccount() service.registerRoutes() return service, nil } func (service *BasicService) Start() error { client := client.NewApiClientFactory(service.Options.ServerUrl). Client(client.WithToken(service.token)) _, _, err := client.RegistrySvcAPI. RegisterInstance(context.Background()). Body(openapi.RegistrySvcRegisterInstanceRequest{ Url: service.Options.SelfUrl, }).Execute() if err != nil { return errors.Wrap(err, &quot;cannot register instance&quot;) } return nil } func (service *BasicService) registerAccount() error { credentialStore, err := service.dataStoreFactory.Create(&quot;basicSvcCredentials&quot;, &amp;auth.Credential{}) if err != nil { return errors.Wrap(err, &quot;cannot create credential store&quot;) } service.credentialStore = credentialStore obClient := client.NewApiClientFactory(service.Options.ServerUrl).Client() token, err := boot.RegisterServiceAccount( obClient.UserSvcAPI, &quot;basic-svc&quot;, &quot;Basic Svc&quot;, service.credentialStore, ) if err != nil { return errors.Wrap(err, &quot;cannot register service&quot;) } service.token = token.Token obClient = client.NewApiClientFactory(service.Options.ServerUrl). Client(client.WithToken(service.token)) _, _, err = obClient.RegistrySvcAPI. RegisterInstance(context.Background()). Body(openapi.RegistrySvcRegisterInstanceRequest{ Url: service.Options.SelfUrl, }).Execute() if err != nil { return errors.Wrap(err, &quot;cannot register instance&quot;) } pk, _, err := obClient. UserSvcAPI.GetPublicKey(context.Background()). Execute() if err != nil { return err } service.userSvcPublicKey = pk.PublicKey return nil } func (service *BasicService) registerRoutes() { appl := service.Options.Middlewares service.Router = mux.NewRouter() service.Router.HandleFunc(&quot;/basic-svc/pet&quot;, appl(func(w http.ResponseWriter, r *http.Request) { service.SavePet(w, r) })). Methods(&quot;OPTIONS&quot;, &quot;PUT&quot;) service.Router.HandleFunc(&quot;/basic-svc/pets&quot;, appl(func(w http.ResponseWriter, r *http.Request) { service.ListPets(w, r) })). Methods(&quot;OPTIONS&quot;, &quot;POST&quot;) service.Router.HandleFunc(&quot;/basic-svc/error&quot;, appl(func(w http.ResponseWriter, r *http.Request) { service.Error(w, r) })). Methods(&quot;OPTIONS&quot;, &quot;POST&quot;) } // &lt;!-- /INCLUDE --&gt; Make sure to run it with the appropriate environment variables: OB_SERVER_URL=http://127.0.0.1:11337 OB_SELF_URL=http://127.0.0.1:9111 go run main.go Once it's running, you'll be able to call the 1Backend server proxy, which will forward the request to your basic service: # 127.0.0.1:11337 here is the address of the 1Backend server $ curl 127.0.0.1:11337/basic-svc/hello {&quot;hello&quot;: &quot;world&quot;} This means you don't have to expose your basic service to the outside world—only the 1Backend server needs to be accessible. Let's recap how the proxying works: Service registers an account, acquires the basic-svc slug.Service calls the 1Backend Registry Svc to tell the system an instance of the Basic service is available under the URL http://127.0.0.1:9111When you send a request to the 1Backend server with a path like 127.0.0.1:11337/basic-svc/hello, the first section of the path is interpreted as a user account slug. The server checks what instances are owned by that slug and routes the request to one of those instances. $ oo instance ls ID URL STATUS OWNER SLUG LAST HEARTBEAT inst_eHFTNvAlk9 http://127.0.0.1:9111 Healthy basic-svc 10s ago Things to understand​ Instance registration​ Like most other things on the platform, service instances are owned by a user account slug. When the basic service calls RegisterInstance, the host will be associated with the basic-svc slug. Updates to this host won’t be possible unless the caller is the basic service itself or an admin. In essence, the service becomes the owner of that URL. This is the same ownership model used throughout the 1Backend system.","keywords":"ai  llm  free gpt  gpt  open-source  open source  ai framework  ai server","version":"Next"}],"options":{"id":"default"}}